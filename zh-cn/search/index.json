[{"content":"GitHub Actions：定时发送天气邮件 2019年底的时候，GitHub正式开放了GitHub Actions这个功能，可以免费使用。\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n这里使用GitHub Actions完成一个实例：每天定时运行一次脚本，获取天气预报，发送电子邮件。\n完整代码可以从GitHub仓库获取。\n获取天气预报 网站wttr.in支持使用命令行请求天气预报。\n1 curl wttr.in 上面的命令会返回，当前IP地址的天气。\n我们可以在URL中指定城市。\n1 curl wttr.in/Xian 返回的数据可以通过curl命令的-o参数，保存成文件，以便后面发送。\n1 curl -o result.html wttr.in/Xian wttr.in允许定制天气预报的格式和内容，详见https://github.com/chubin/wttr.in，这里就不展开了。最后封装好的脚本weather.sh，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh set -eux CITY=Xian LANGUAGE=\u0026#34;zh-CN\u0026#34; UNIT=m curl \\ -H \u0026#34;Accept-Language: $LANGUAGE\u0026#34; \\ -o result.html \\ wttr.in/$CITY?format=4\\\u0026amp;$UNIT 配置发送邮件账户 我使用的是网易163邮箱的免费发送服务，也可以使用其他邮箱。\n需要首先在网易163邮箱中生成授权码。\n登录网易163邮箱（https://mail.163.com/）\n点击设置，选择设置POP3/SMTP/IMAP\n点击新增授权密码，保存好该授权密码。 配置GitHub Actions 触发GitHub Actions需要在项目仓库新建一个.github/workflows子目录，里面是YAML格式配置文件，文件名可以随便取。GitHub只要发现配置文件，就会运行Actions。\n配置文件的第一部分是触发条件。\n1 2 3 4 5 6 name: \u0026#39;GitHub Action Weather Bot\u0026#39; on: push: schedule: - cron: \u0026#39;0 0 * * *\u0026#39; 上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码Push进仓库，第二种是定时任务，每天在国际标准时间0点（北京时间早上8点）运行。\n接着，就是运行流程。\n1 2 3 4 runs-on: ubuntu-latest steps: - name: \u0026#39;Checkout codes\u0026#39; uses: actions/checkout@v1 上面代码中，运行环境指定为最新版的 Ubuntu。流程的第一步是从代码仓库获取代码。\n拿到代码以后，就可以获取天气预报了。\n1 2 - name: \u0026#39;Get Weather\u0026#39; run: bash ./weather.sh 上面代码中，run字段就是所要运行的命令。\n最后，发送邮件。\n1 2 3 4 5 6 7 8 9 10 11 12 - name: \u0026#39;Send mail\u0026#39; uses: dawidd6/action-send-mail@master with: server_address: smtp.163.com server_port: 465 username: ${{ secrets.MAIL_USERNAME }} password: ${{ secrets.MAIL_PASSWORD }} subject: Xian Weather Report (${{env.REPORT_DATE}}) body: file://result.html to: ${{ secrets.TO_EMAIL_ADDRESS }} from: GitHub Actions content_type: text/html 上面代码中，发送邮件使用的是一个已经写好的action，只要配几个参数就可以用。参数之中，邮件SMTP服务器的用户名和密码，使用的是加密变量，需要在项目的settings/secrets菜单里面设置。\n完整的配置文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 name: \u0026#39;GitHub Action Weather Bot\u0026#39; on: push: schedule: - cron: \u0026#39;0 0 * * *\u0026#39; jobs: bot: runs-on: ubuntu-latest steps: - name: \u0026#39;Checkout codes\u0026#39; uses: actions/checkout@v1 - name: \u0026#39;Get Weather\u0026#39; run: bash ./weather.sh - name: \u0026#39;Get Date\u0026#39; run: echo \u0026#34;REPORT_DATE=$(TZ=\u0026#39;:Asia/Xian\u0026#39; date \u0026#39;+%Y-%m-%d %T\u0026#39;)\u0026#34; \u0026gt;\u0026gt; $GITHUB_ENV - name: \u0026#39;Send mail\u0026#39; uses: dawidd6/action-send-mail@master with: server_address: smtp.163.com server_port: 465 username: ${{ secrets.MAIL_USERNAME }} password: ${{ secrets.MAIL_PASSWORD }} subject: Xian Weather Report (${{env.REPORT_DATE}}) body: file://result.html to: ${{ secrets.TO_EMAIL_ADDRESS }} from: GitHub Actions content_type: text/html 写好配置，推送到仓库以后，就可以每天清早收到一封天气预报邮件了。在这个基础上不难扩展，可以定时执行各种脚本（比如每5分钟检查一次某个网站是否在线），然后将结果发到指定的渠道等等。\n成功发送 配置成功后，每天固定时间都会接收到当天的天气邮件。\n","date":"2023-11-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/github-actions%E5%AE%9A%E6%97%B6%E5%8F%91%E9%80%81%E5%A4%A9%E6%B0%94%E9%82%AE%E4%BB%B6/","title":"GitHub Actions：定时发送天气邮件"},{"content":"InfluxDB 时间序列数据平台 InfluxDB属于时序数据库。\nInfluxDB的数据元素 https://docs.influxdata.com/influxdb/v2.1/reference/key-concepts/data-elements/\n_time _measurement location scientist _field _value 2019-08-18T00:00:00Z census klamath anderson bees 23 2019-08-18T00:00:00Z census portland mullen ants 30 2019-08-18T00:06:00Z census klamath anderson bees 28 2019-08-18T00:06:00Z census portland mullen ants 32 时间戳(timestamp)\n所有存储在InfluxDB的数据都有一个_time列，用来存储时间戳。\n测量(measurement)\n_measurement列显示测量的名称。测量的名称是字符串。一个测量作为tag、field和timestamp的容器。\n字段(field)\n一个字段包括存储在_field列的字段键和存储在_value列的字段值。一个测量至少需要一个字段。\n字段键(field key)\n字段键是一个字符串，代表字段的名称。在上面的样本数据中，bees和ants是字段键。\n字段值(field value)\n一个字段值代表一个相关字段的值。字段值可以是字符串、浮点数、整数或布尔值。样本数据中的字段值显示了指定时间的蜜蜂数量：23和28，以及指定时间的蚂蚁数量：30和32。\n字段集(field set)\n一个字段集是一个与时间戳相关的字段键值对的集合。一个测量至少需要一个字段。样本数据包括以下字段集：\n1 2 3 4 census bees=23i,ants=30i 1566086400000000000 census bees=28i,ants=32i 1566086760000000000 ----------------- Field set 标签(tags)\n标签包括标签键和标签值，以字符串形式存储。\n标签键(tag key)\n样本数据中的标签键是location和scientist。\n标签值(tag value)\n标签键location有两个标签值：klamath和portland。标签键scientist也有两个标签值：Anderson和Mullen。\n标签集(tag set)\n标签的键值对的集合构成了一个标签集。样本数据包括以下四个标签集。\n1 2 3 4 location = klamath, scientist = anderson location = portland, scientist = anderson location = klamath, scientist = mullen location = portland, scientist = mullen 系列(series)\n一个系列键是共享一个测量、标签集和字段键的点的集合。例如，样本数据包括两个独特的系列键。\n_measurement tag set _field census location=klamath,scientist=anderson bees census location=portland,scientist=mullen ants 一个系列包括时间戳和给定系列键的字段值。从样本数据来看，这里有一个系列键和相应的系列。\n1 2 3 4 5 6 # series key census,location=klamath,scientist=anderson bees # series 2019-08-18T00:00:00Z 23 2019-08-18T00:06:00Z 28 C#的InfluxDB库 支持C#的InfluxDB库由官方维护：influxdb-client-csharp(https://github.com/influxdata/influxdb-client-csharp)\n该官方库不支持SQL语言，而使用了官方提出的Flux语言。\nInfluxDB可以使用InfluxQL和Flux以及api查询数据。\nInfluxQL语言与SQL语言非常相似，但它似乎只用于api查询使用。\nInfluxQL和Flux在功能上基本等同。只有代码看起来不同。（https://docs.influxdata.com/influxdb/v2.1/reference/syntax/flux/flux-vs-influxql/#influxql-and-flux-parity）\nFlux Flux是一种开源的功能性数据脚本语言（https://docs.influxdata.com/flux/v0.x/）\nshow databases\n1 buckets() show tables\n1 2 3 import \u0026#34;influxdata/influxdb/schema\u0026#34; schema.measurements(bucket: \u0026#34;javen\u0026#34;) show columns （需要手动添加_time和_value）\n1 2 3 4 5 6 import \u0026#34;influxdata/influxdb/sample\u0026#34; sample.data(set: \u0026#34;sampleTableName\u0026#34;) |\u0026gt; keys() |\u0026gt; keep(columns: [\u0026#34;_value\u0026#34;]) |\u0026gt; distinct() 数据类型 InfluxDB datatype C# datatype dateTime:RFC3339 DateTimeOffset dateTime:RFC3339Nano DateTimeOffset string String double Double boolean Boolean long Int64 unsignedLong UInt64 base64Binary Byte[] duration TimeSpan 连接配置 https://github.com/influxdata/influxdb-client-csharp/tree/master/Client#client-connection-string\n可以使用一个连接字符串构建一个客户端，该字符串可以包含编码在URL中的InfluxDBClientOptions参数。\n1 connectionString = \u0026#34;http://localhost:8086?token=myToken\u0026amp;org=myOrg\u0026#34; 支持以下选项：\nProperty default description org - default destination organization for writes and queries bucket - default destination bucket for writes token - the token to use for the authorization logLevel NONE rest client verbosity level timeout 10000 ms socket timeout allowHttpRedirects false Configure automatically following HTTP 3xx redirects verifySsl true Ignore Certificate Validation Errors when false The timeout supports ms, s and m as unit. Default is milliseconds.\n","date":"2023-11-24T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/influxdb-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/","title":"InfluxDB 时间序列数据平台"},{"content":"如何在 SQL Server 数据库中使用Stored Procedure进行分析 假设我们目前使用有一个标准的Northwind数据源（sql-server-samples/Northwind）。\n它所包含的Table请查阅：Northwind Database\n它包括以下Table：\nProducts\n1 2 3 4 5 6 7 SELECT [ProductID], [ProductName], |[SupplierID], |[CategoryID] FROM [dbo].[Products]; ProductID ProductName SupplierID CategoryID 1 Chai 1 1 2 Chang 1 1 3 Aniseed Syrup 1 2 4 Chef Anton\u0026rsquo;s Cajun Seasoning 2 2 5 Chef Anton\u0026rsquo;s Gumbo Mix 2 2 6 Grandma\u0026rsquo;s Boysenberry Spread 3 2 7 Uncle Bob\u0026rsquo;s Organic Dried Pears 3 7 8 Northwoods Cranberry Sauce 3 2 9 Mishi Kobe Niku 4 6 10 Ikura 4 8 11 Queso Cabrales 5 4 12 Queso Manchego La Pastora 5 4 13 Konbu 6 8 14 Tofu 6 7 15 Genen Shouyu 6 2 16 Pavlova 7 3 17 Alice Mutton 7 6 18 Carnarvon Tigers 7 8 19 Teatime Chocolate Biscuits 8 3 20 Sir Rodney\u0026rsquo;s Marmalade 8 3 21 Sir Rodney\u0026rsquo;s Scones 8 3 22 Gustaf\u0026rsquo;s Knäckebröd 9 5 23 Tunnbröd 9 5 24 Guaraná Fantástica 10 1 25 NuNuCa Nuß-Nougat-Creme 11 3 26 Gumbär Gummibärchen 11 3 27 Schoggi Schokolade 11 3 28 Rössle Sauerkraut 12 7 29 Thüringer Rostbratwurst 12 6 30 Nord-Ost Matjeshering 13 8 31 Gorgonzola Telino 14 4 32 Mascarpone Fabioli 14 4 33 Geitost 15 4 34 Sasquatch Ale 16 1 35 Steeleye Stout 16 1 36 Inlagd Sill 17 8 37 Gravad lax 17 8 38 Côte de Blaye 18 1 39 Chartreuse verte 18 1 40 Boston Crab Meat 19 8 41 Jack\u0026rsquo;s New England Clam Chowder 19 8 42 Singaporean Hokkien Fried Mee 20 5 43 Ipoh Coffee 20 1 44 Gula Malacca 20 2 45 Rogede sild 21 8 46 Spegesild 21 8 47 Zaanse koeken 22 3 48 Chocolade 22 3 49 Maxilaku 23 3 50 Valkoinen suklaa 23 3 51 Manjimup Dried Apples 24 7 52 Filo Mix 24 5 53 Perth Pasties 24 6 54 Tourtière 25 6 55 Pâté chinois 25 6 56 Gnocchi di nonna Alice 26 5 57 Ravioli Angelo 26 5 58 Escargots de Bourgogne 27 8 59 Raclette Courdavault 28 4 60 Camembert Pierrot 28 4 61 Sirop d\u0026rsquo;érable 29 2 62 Tarte au sucre 29 3 63 Vegie-spread 7 2 64 Wimmers gute Semmelknödel 12 5 65 Louisiana Fiery Hot Pepper Sauce 2 2 66 Louisiana Hot Spiced Okra 2 2 67 Laughing Lumberjack Lager 16 1 68 Scottish Longbreads 8 3 69 Gudbrandsdalsost 15 4 70 Outback Lager 7 1 71 Flotemysost 15 4 72 Mozzarella di Giovanni 14 4 73 Röd Kaviar 17 8 74 Longlife Tofu 4 7 75 Rhönbräu Klosterbier 12 1 76 Lakkalikööri 23 1 77 Original Frankfurter grüne Soße 12 2 它包含以下两个Stored Procedure：\nTenMostExpensiveProducts\n1 2 3 4 5 create procedure \u0026#34;Ten Most Expensive Products\u0026#34; AS SET ROWCOUNT 10 SELECT Products.ProductName AS TenMostExpensiveProducts, Products.UnitPrice FROM Products ORDER BY Products.UnitPrice DESC; 1 EXEC [dbo].[Ten Most Expensive Products]; TenMostExpensiveProducts UnitPrice Côte de Blaye 263.5000 Thüringer Rostbratwurst 123.7900 Mishi Kobe Niku 97.0000 Sir Rodney\u0026rsquo;s Marmalade 81.0000 Carnarvon Tigers 62.5000 Raclette Courdavault 55.0000 Manjimup Dried Apples 53.0000 Tarte au sucre 49.3000 Ipoh Coffee 46.0000 Rössle Sauerkraut 45.6000 CustOrderHist\n1 2 3 4 5 6 7 CREATE PROCEDURE CustOrderHist @CustomerID nchar(5) AS SELECT ProductName, Total=SUM(Quantity) FROM Products P, [Order Details] OD, Orders O, Customers C WHERE C.CustomerID = @CustomerID AND C.CustomerID = O.CustomerID AND O.OrderID = OD.OrderID AND OD.ProductID = P.ProductID GROUP BY ProductName 1 EXEC \u0026#34;CustOrderHist\u0026#34; @CustomerID = \u0026#39;ALFKI\u0026#39;; ProductName Total Aniseed Syrup 6 Chartreuse verte 21 Escargots de Bourgogne 40 Flotemysost 20 Grandma\u0026rsquo;s Boysenberry Spread 16 Lakkalikööri 15 Original Frankfurter grüne Soße 2 Raclette Courdavault 15 Rössle Sauerkraut 17 Spegesild 2 Vegie-spread 20 我们无法直接对Stored Procedure进行join操作，因此有以下两种方案可以解决该问题。\n使用DECLARE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 DECLARE @TenMostExpensiveProducts TABLE ( [TenMostExpensiveProducts] nvarchar(40), [UnitPrice] money ); INSERT INTO @TenMostExpensiveProducts EXEC [dbo].[Ten Most Expensive Products]; SELECT [Products].[ProductID], [Ten Most Expensive Products].[TenMostExpensiveProducts], [Ten Most Expensive Products].[UnitPrice], [Products].[SupplierID], [Products].[CategoryID] FROM @TenMostExpensiveProducts [Ten Most Expensive Products] LEFT JOIN [dbo].[Products] [Products] ON [Ten Most Expensive Products].[TenMostExpensiveProducts] = [Products].[ProductName]; ProductID TenMostExpensiveProducts UnitPrice SupplierID CategoryID 38 Côte de Blaye 263.5000 18 1 29 Thüringer Rostbratwurst 123.7900 12 6 9 Mishi Kobe Niku 97.0000 4 6 20 Sir Rodney\u0026rsquo;s Marmalade 81.0000 8 3 18 Carnarvon Tigers 62.5000 7 8 59 Raclette Courdavault 55.0000 28 4 51 Manjimup Dried Apples 53.0000 24 7 62 Tarte au sucre 49.3000 29 3 43 Ipoh Coffee 46.0000 20 1 28 Rössle Sauerkraut 45.6000 12 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 DECLARE @CustOrderHist TABLE ( [ProductName] nvarchar(40), [Total] int ); INSERT INTO @CustOrderHist EXEC [dbo].[CustOrderHist] @CustomerID = \u0026#39;ALFKI\u0026#39;; SELECT [Products].[ProductID], [CustOrderHist].[ProductName], [CustOrderHist].[Total], [Products].[SupplierID], [Products].[CategoryID] FROM @CustOrderHist [CustOrderHist] LEFT JOIN [dbo].[Products] [Products] ON [CustOrderHist].[ProductName] = [Products].[ProductName]; ProductID ProductName Total SupplierID CategoryID 3 Aniseed Syrup 6 1 2 39 Chartreuse verte 21 18 1 58 Escargots de Bourgogne 40 27 8 71 Flotemysost 20 15 4 6 Grandma\u0026rsquo;s Boysenberry Spread 16 3 2 76 Lakkalikööri 15 23 1 77 Original Frankfurter grüne Soße 2 12 2 59 Raclette Courdavault 15 28 4 28 Rössle Sauerkraut 17 12 7 46 Spegesild 2 21 8 63 Vegie-spread 20 7 2 使用Temporal tables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 CREATE TABLE #TenMostExpensiveProducts ( [TenMostExpensiveProducts] nvarchar(40), [UnitPrice] money ); INSERT INTO #TenMostExpensiveProducts EXEC [dbo].[Ten Most Expensive Products]; SELECT [Products].[ProductID], [Ten Most Expensive Products].[TenMostExpensiveProducts], [Ten Most Expensive Products].[UnitPrice], [Products].[SupplierID], [Products].[CategoryID] FROM #TenMostExpensiveProducts [Ten Most Expensive Products] LEFT JOIN [dbo].[Products] [Products] ON [Ten Most Expensive Products].[TenMostExpensiveProducts] = [Products].[ProductName]; ProductID TenMostExpensiveProducts UnitPrice SupplierID CategoryID 38 Côte de Blaye 263.5000 18 1 29 Thüringer Rostbratwurst 123.7900 12 6 9 Mishi Kobe Niku 97.0000 4 6 20 Sir Rodney\u0026rsquo;s Marmalade 81.0000 8 3 18 Carnarvon Tigers 62.5000 7 8 59 Raclette Courdavault 55.0000 28 4 51 Manjimup Dried Apples 53.0000 24 7 62 Tarte au sucre 49.3000 29 3 43 Ipoh Coffee 46.0000 20 1 28 Rössle Sauerkraut 45.6000 12 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 CREATE TABLE #CustOrderHist ( [ProductName] nvarchar(40), [Total] int ); INSERT INTO #CustOrderHist EXEC [dbo].[CustOrderHist] @CustomerID = \u0026#39;ALFKI\u0026#39;; SELECT [Products].[ProductID], [CustOrderHist].[ProductName], [CustOrderHist].[Total], [Products].[SupplierID], [Products].[CategoryID] FROM #CustOrderHist [CustOrderHist] LEFT JOIN [dbo].[Products] [Products] ON [CustOrderHist].[ProductName] = [Products].[ProductName]; ProductID ProductName Total SupplierID CategoryID 3 Aniseed Syrup 6 1 2 39 Chartreuse verte 21 18 1 58 Escargots de Bourgogne 40 27 8 71 Flotemysost 20 15 4 6 Grandma\u0026rsquo;s Boysenberry Spread 16 3 2 76 Lakkalikööri 15 23 1 77 Original Frankfurter grüne Soße 2 12 2 59 Raclette Courdavault 15 28 4 28 Rössle Sauerkraut 17 12 7 46 Spegesild 2 21 8 63 Vegie-spread 20 7 2 ","date":"2023-11-23T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%A6%82%E4%BD%95%E5%9C%A8-sql-server-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E4%BD%BF%E7%94%A8stored-procedure%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90/","title":"如何在 SQL Server 数据库中使用Stored Procedure进行分析"},{"content":"MySQL 命令行客户端 mysql 是一个简单的 SQL shell，具有输入行编辑功能。它支持交互式和非交互式使用。交互式使用时，查询结果以 ASCII 表格格式显示。非交互式使用时（例如，作为过滤器），结果以制表符分隔的格式显示。输出格式可以通过命令选项进行更改。\n如果因内存不足而无法处理大型结果集，请使用 --quick 选项。这会强制mysql每次从服务器检索一行结果，而不是检索整个结果集，并在显示之前将其缓冲在内存中。具体做法是使用客户端/服务器库中的 mysql_use_result() C API 函数而不是 mysql_store_result()来返回结果集。\n注意： 另外，MySQL Shell 还提供对 X DevAPI 的访问。有关详情，请参阅 MySQL Shell 8.0。\n使用 mysql 非常简单。在命令解释器的提示符下调用它，如下所示：\n1 mysql db_name 或者：\n1 mysql --user=user_name --password db_name 在这种情况下，您需要根据 mysql 显示的提示输入密码：\n1 Enter password: your_password 然后键入一条 SQL 语句，以 ;、\\g 或 \\G 结尾并按 Enter。\n如果有当前语句，键入 Control+C 会中断该语句，否则会取消任何部分输入行。\n您可以像这样在脚本文件（批处理文件）中执行 SQL 语句：\n1 mysql db_name \u0026lt; script.sql \u0026gt; output.tab 在 Unix 上，mysql 客户端会将交互执行的语句记录到历史文件中。请参阅 mysql Client Logging。\nmysql 客户端选项 mysql supports the following options, which can be specified on the command line or in the [mysql] and [client] groups of an option file. For information about option files used by MySQL programs, see Using Option Files.\nmysql支持以下选项，这些选项可以在命令行或选项文件的[mysql]和[client]组中指定。有关 MySQL 程序使用的选项文件的信息，请参阅 Using Option Files。\n选项名称 描述 引入版本 废弃版本 --auto-rehash 启用自动重新哈希 --auto-vertical-output 启用自动垂直结果集显示 --batch 不使用历史记录文件 --binary-as-hex 以十六进制显示二进制值 --binary-mode 禁用 \\r \\n 到 -n 转换和将 \\0 视为查询结束 --bind-address 使用指定的网络接口连接 MySQL Server --character-sets-dir 安装字符集的目录 --column-names 在结果中写入列名 --column-type-info 显示结果集元数据 --comments 是否保留或删除发送到服务器的语句中的注释 --compress 压缩客户端和服务器之间发送的所有信息 8.0.18 --compression-algorithms 用于连接服务器的允许压缩算法 8.0.18 --connect-expired-password 指示服务器客户端可以处理过期密码沙箱模式 --connect-timeout 连接超时之前的秒数 --database 要使用的数据库 --debug 编写调试日志；仅当MySQL使用调试支持构建时才受支持 --debug-check 程序退出时打印调试信息 --debug-info 程序退出时打印调试信息，内存和CPU统计信息 --default-auth 身份验证插件使用 --default-character-set 指定默认字符集 --defaults-extra-file 除了通常的选项文件，还读取命名的选项文件 --defaults-file 只读命名的选项文件 --defaults-group-suffix 选项组后缀值 --delimiter 设置语句定界符 --dns-srv-name 使用 DNS SRV 查找主机信息 8.0.22 --enable-cleartext-plugin 启用明文身份验证插件 --execute 执行语句并退出 --fido-register-factor 必须进行注册的多因素身份验证因素 8.0.27 8.0.35 --force 即使发生SQL错误，也要继续 --get-server-public-key 从服务器请求RSA公钥 --help 显示帮助信息并退出 --histignore 模式指定日志记录要忽略的语句 --host MySQL服务器所在的主机 --html 生成 HTML 输出 --ignore-spaces 忽略函数名称后的空格 --init-command 连接后执行的SQL语句 --line-numbers 输入行号以查找错误 --load-data-local-dir LOAD DATA LOCAL 语句中命名的文件目录 8.0.21 --local-infile 启用或禁用LOAD DATA的LOCAL功能 --login-path 从.mylogin.cnf中读取登录路径选项 --max-allowed-packet 发送到服务器或从服务器接收的最大数据包长度 --max-join-size 使用--safe-updates时联接中行的自动限制 --named-commands 启用命名的mysql命令 --net-buffer-length TCP/IP和套接字通信的缓冲区大小 --network-namespace 指定网络命名空间 8.0.22 --no-auto-rehash 禁用自动重新哈希 --no-beep 发生错误时不发出蜂鸣声 --no-defaults 不读取选项文件 --oci-config-file 定义 Oracle 云计算基础架构 CLI 配置文件的备用位置。 8.0.27 --one-database 忽略命令行中指定的默认数据库的语句以外的语句 --pager 使用给定命令进行分页查询输出 --password 连接服务器时使用的密码 --password1 连接服务器时使用的第一个多因素身份验证密码 8.0.27 --password2 连接服务器时使用的第二个多因素身份验证密码 8.0.27 --password3 连接服务器时使用的第三个多因素身份验证密码 8.0.27 --pipe 使用命名管道连接到服务器（仅Windows） --plugin-authentication-kerberos-client-mode 允许通过 Windows 上的 MIT Kerberos 库进行 GSSAPI 可插拔身份验证 8.0.32 --plugin-dir 安装插件的目录 --port 用于连接的TCP/IP端口号 --print-defaults 打印默认选项 --prompt 将提示设置为指定格式 --protocol 使用的连接协议 --quick 不要缓存每个查询结果 --raw 写入列值而不进行转义转换 --reconnect 如果与服务器的连接丢失，则自动尝试重新连接 --safe-updates, --i-am-a-dummy 仅允许指定键值的UPDATE和DELETE语句 --select-limit 使用--safe-updates时SELECT语句的自动限制 --server-public-key-path 包含RSA公钥的文件的路径名 --shared-memory-base-name 共享内存连接的共享内存名称（仅限 Windows） --show-warnings 在每条语句后显示警告（如果有的话） --sigint-ignore 忽略 SIGINT 信号（通常是输入 Control+C 的结果） --silent 静音模式 --skip-auto-rehash 禁用自动重新哈希 --skip-column-names 不要在结果中写入列名 --skip-line-numbers 跳过行号以获取错误 --skip-named-commands 禁用命名的mysql命令 --skip-pager 禁用分页 --skip-reconnect 禁用重新连接 --socket Unix套接字文件或Windows命名管道使用 --ssl-ca 包含受信任的SSL证书颁发机构列表的文件 --ssl-capath 包含受信任的SSL证书颁发机构证书文件的目录 --ssl-cert 包含X.509证书的文件 --ssl-cipher 连接加密的允许密码 --ssl-crl 包含证书吊销列表的文件 --ssl-crlpath 包含证书吊销列表文件的目录 --ssl-fips-mode 是否在客户端启用FIPS模式 8.0.34 --ssl-key 包含X.509密钥的文件 --ssl-mode 与服务器连接的所需安全状态 --ssl-session-data 包含 SSL 会话数据的文件 8.0.29 --ssl-session-data-continue-on-failed-reuse 会话重用失败时是否建立连接 8.0.29 --syslog 将交互式语句记录到syslog --table 以表格格式显示输出结果 --tee 将输出副本附加到命名文件中 --tls-ciphersuites 允许用于加密连接的 TLSv1.3 密码套件 8.0.16 --tls-version 允许的加密连接 TLS 协议 --unbuffered 每次查询后清空缓冲区 --user 连接服务器时使用的 MySQL 用户名 --verbose 详细模式 --version 显示版本信息并退出 --vertical 垂直打印查询输出行（每列值一行） --wait 如果无法建立连接，请等待并重试，而不是终止连接 --xml 生成 XML 输出 --zstd-compression-level 使用 zstd 压缩的服务器连接的压缩级别 8.0.18 --help, -? Command-Line Format --help 显示帮助信息并退出。\n--auto-rehash Command-Line Format --auto-rehash Disabled by skip-auto-rehash Enable automatic rehashing. This option is on by default, which enables database, table, and column name completion. Use --disable-auto-rehash to disable rehashing. That causes mysql to start faster, but you must issue the rehash command or its \\# shortcut if you want to use name completion.\n启用自动哈希。该选项默认为开启，可启用数据库、表和列名补全。使用--disable-auto-rehash禁用哈希。这会使 mysql 启动得更快，但如果你想使用名称补全，就必须发出 rehash 命令或其快捷方式。\n要补全名称，请输入第一部分并按 Tab 键。如果名称不明确，mysql 将完成它。否则，您可以再次按 Tab 键，查看以您目前键入的内容开头的可能名称。如果没有默认数据库，则不会完成。\n注意： 此功能需要使用 readline 库编译的 MySQL 客户端。通常情况下，Windows 上没有 readline 库。\n--auto-vertical-output Command-Line Format --auto-vertical-output 如果结果集对于当前窗口来说太宽，则使其垂直显示，否则使用正常的表格格式。（这适用于以 ; 或 \\G 结束的语句）。\n--batch, -B Command-Line Format --batch 使用制表符作为列分隔符打印结果，每行打印一行。使用该选项后，mysql 不会使用历史文件。\n批处理模式会导致非表格输出格式和特殊字符转义。使用原始模式可以禁用转义；请参阅--raw选项的说明。\n--binary-as-hex Command-Line Format --binary-as-hex Type Boolean Default Value(≥ 8.0.19) FALSE in noninteractive mode Default Value(≤ 8.0.18) FALSE 给定该选项后，mysql 将使用十六进制符号（0xvalue）显示二进制数据。无论整体输出显示格式是表格、垂直、HTML 还是 XML，都会出现这种情况。\n启用 --binary-as-hex 后，将影响所有二进制字符串的显示，包括那些由 CHAR() 和 UNHEX() 等函数返回的字符串。下面的示例使用 A 的 ASCII 码（十进制 65 位，十六进制 41 位）进行了演示：\n禁用--binary-as-hex: 1 2 3 4 5 6 mysql\u0026gt; SELECT CHAR(0x41), UNHEX(\u0026#39;41\u0026#39;); +------------+-------------+ | CHAR(0x41) | UNHEX(\u0026#39;41\u0026#39;) | +------------+-------------+ | A | A | +------------+-------------+ 启用--binary-as-hex: 1 2 3 4 5 6 mysql\u0026gt; SELECT CHAR(0x41), UNHEX(\u0026#39;41\u0026#39;); +------------------------+--------------------------+ | CHAR(0x41) | UNHEX(\u0026#39;41\u0026#39;) | +------------------------+--------------------------+ | 0x41 | 0x41 | +------------------------+--------------------------+ 要编写二进制字符串表达式，使其无论是否启用--binary-as-hex都能显示为字符串，请使用以下技巧：\n函数 CHAR() 有一个 USING charset 子句： 1 2 3 4 5 6 mysql\u0026gt; SELECT CHAR(0x41 USING utf8mb4); +--------------------------+ | CHAR(0x41 USING utf8mb4) | +--------------------------+ | A | +--------------------------+ 更一般地说，使用 CONVERT() 可以将表达式转换为给定的字符集： 1 2 3 4 5 6 mysql\u0026gt; SELECT CONVERT(UNHEX(\u0026#39;41\u0026#39;) USING utf8mb4); +------------------------------------+ | CONVERT(UNHEX(\u0026#39;41\u0026#39;) USING utf8mb4) | +------------------------------------+ | A | +------------------------------------+ 从MySQL 8.0.19开始，当mysql在交互模式下运行时，默认启用该选项。此外，在隐式或显式启用该选项时，status（或 \\s）命令的输出也会包含这一行：\n1 Binary data as: Hexadecimal 要禁用十六进制符号，请使用 --skip-binary-as-hex\n--binary-model Command-Line Format --binary-mode 该选项有助于处理可能包含BLOB值的mysqlbinlog输出。默认情况下，mysql会将语句字符串中的\\r\\n翻译成\\n，并将\\0解释为语句结束符。--binary-mode禁用了这两个功能。在非交互模式下，除了 charset 和 delimiter 之外，它还禁用了所有 mysql 命令（对于通过管道输入到 mysql 或使用源代码命令加载的输入）。\n--bind-address=ip_address Command-Line Format --bind-address=ip_address 在有多个网络接口的计算机上，使用此选项选择用于连接 MySQL 服务器的接口。\n--character-sets-dir=dir_name Command-Line Format --character-sets-dir=dir_name Type Directory name 安装字符集的目录。请参阅\u0026ldquo;Character Set Configuration\u0026rdquo;。\n--column-names Command-Line Format --column-names 在结果中写入列名。\n--column-type-info Command-Line Format --column-type-info 显示结果集元数据。这些信息与 C API MYSQL_FIELD 数据结构的内容相对应。请参阅 C API Basic Data Structures。\n--comments, -c Command-Line Format --comments Type Boolean Default Value FALSE 在发送到服务器的语句中剥离或保留注释。默认值是 -skip-comments（去除注释），启用时使用 -comments（保留注释）。\n注意： 无论是否给出此选项，mysql 客户端都会将优化器提示传递给服务器。注释剥离已被弃用。预计在未来的 MySQL 版本中，该功能和控制该功能的选项将被移除。\n--compress, -C Command-Line Format --compress[={OFF|ON}] Deprecated 8.0.18 Type Boolean Default Value OFF 尽可能压缩客户端与服务器之间发送的所有信息。请参阅\u0026ldquo;Connection Compression Control\u0026rdquo;。\n自 MySQL 8.0.18 起，该选项已被弃用。预计未来的 MySQL 版本将删除该选项。请参阅 Configuring Legacy Connection Compression。\n--compression-algorithms=value Command-Line Format --compression-algorithms=value Deprecated 8.0.18 Type Set Default Value uncompressed Valid Values zlib / zstd / uncompressed 与服务器连接时允许使用的压缩算法。可用算法与 protocol_compression_algorithms 系统变量相同。默认值为 uncompressed。\n更多信息，请参阅\u0026ldquo;Connection Compression Control\u0026rdquo;。\n此选项在 MySQL 8.0.18 中添加。\n--connect-expired-password Command-Line Format --connect-expired-password 如果用于连接的账户密码已过期，则向服务器表明客户端可以处理沙箱模式。这对非交互式调用 mysql 很有用，因为通常情况下，服务器会断开试图使用密码过期账户进行连接的非交互式客户端。（请参阅\u0026ldquo;Server Handling of Expired Passwords\u0026rdquo;）。\n--connect-timeout=value Command-Line Format --connect-timeout=value Type Numeric Default Value 0 连接超时前的秒数。（默认值为 0）。\n--database=db_name, -D db_name Command-Line Format --database=dbname Type String 要使用的数据库。这主要在选项文件中有用。\n--debug [=debug_options], -# [debug_options] Command-Line Format --debug[=debug_options] Type String Default Value d:t:o,/tmp/mysql.trace 编写调试日志。典型的 debug_options 字符串为 d:t:o,file_name。默认值为 d:t:o,/tmp/mysql.trace。\n只有在使用WITH_DEBUG构建 MySQL 时，该选项才可用。Oracle 提供的 MySQL 发行版二进制文件不使用此选项构建。\n--debug-check Command-Line Format --debug-check Type Boolean Default Value FALSE 在程序退出时打印一些调试信息。\n只有在使用WITH_DEBUG构建 MySQL 时，该选项才可用。Oracle 提供的 MySQL 发行版二进制文件不使用此选项构建。\n--debug-info, -T Command-Line Format --debug-info Type Boolean Default Value FALSE 在程序退出时打印调试信息以及内存和 CPU 使用率统计信息。\n只有在使用WITH_DEBUG构建 MySQL 时，该选项才可用。Oracle 提供的 MySQL 发行版二进制文件不使用此选项构建。\n--default-auth=plugin Command-Line Format --default-auth=plugin Type String 关于使用哪个客户端身份验证插件的提示。请参阅\u0026ldquo;Pluggable Authentication\u0026rdquo;。\n--default-character-set=charset_name Command-Line Format --default-character-set=charset_name Type String 使用 charset_name 作为客户端和连接的默认字符集。\n如果操作系统使用一种字符集，而 mysql 客户端默认使用另一种字符集，则该选项会很有用。在这种情况下，输出的格式可能不正确。使用该选项强制客户端使用系统字符集，通常可以解决此类问题。\n更多信息，请参阅\u0026ldquo;Connection Character Sets and Collations\u0026rdquo; 和\u0026ldquo;Character Set Configuration\u0026rdquo;。\n--defaults-extra-file=file-name Command-Line Format --defaults-extra-file=file_name Type File name 在全局选项文件之后、用户选项文件之前（在 Unix 上）读取该选项文件。如果文件不存在或无法访问，则会出错。如果 file_name 不是绝对路径名，则解释为相对于当前目录。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--defaults-file=file_name Command-Line Format --defaults-file=file_name Type File name 只使用给定的选项文件。如果文件不存在或无法访问，则会出错。如果 file_name 不是绝对路径名，则解释为相对于当前目录。\n异常： 即使使用 --defaults-file，客户端程序也会读取 .mylogin.cnf。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--defaults-group-suffix=str Command-Line Format --defaults-group-suffix=str Type String 不仅读取通常的选项组，也读取通常名称和后缀为 str 的组。例如，mysql 通常读取[client]和[mysql]组。如果将此选项设置为 --defaults-group-suffix=_other，mysql 也会读取 [client_other] 和 [mysql_other] 组。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--delimiter=str Command-Line Format --delimiter=str Type String Default Value ; 设置语句分隔符。默认为分号（;）。\n--disable-named-commands 禁用命名命令。只使用 \\* 形式，或只在以分号（;）结尾的行首使用命名命令。默认情况下，mysql启动时该选项已enabled。不过，即使使用该选项，长格式命令仍可从第一行开始执行。参见\u0026ldquo;mysql Client Commands\u0026rdquo;。\n--dns-srv-name=name Command-Line Format --dns-srv-name=name Introduced 8.0.22 Type String 指定 DNS SRV 记录的名称，该记录用于确定与 MySQL 服务器建立连接时要使用的候选主机。有关 MySQL 支持 DNS SRV 的信息，请参阅\u0026ldquo;Connecting to the Server Using DNS SRV Records\u0026rdquo;。\n假设 DNS 已为 example.com 域配置了此 SRV 信息：\n1 2 3 4 5 Name TTL Class Priority Weight Port Target _mysql._tcp.example.com. 86400 IN SRV 0 5 3306 host1.example.com _mysql._tcp.example.com. 86400 IN SRV 0 10 3306 host2.example.com _mysql._tcp.example.com. 86400 IN SRV 10 5 3306 host3.example.com _mysql._tcp.example.com. 86400 IN SRV 20 5 3306 host4.example.com 要使用 DNS SRV 记录，请像这样调用 mysql：\n1 mysql --dns-srv-name=_mysql._tcp.example.com 然后，mysql 会尝试与组中的每个服务器建立连接，直到连接成功为止。只有在无法与任何服务器建立连接时，才会发生连接失败。DNS SRV 记录中的优先级和权重值决定了尝试服务器的顺序。\n使用--dns-srv-name调用时，mysql 只尝试建立 TCP 连接。\nThe --dns-srv-name option takes precedence over the --host option if both are given. --dns-srv-name causes connection establishment to use the mysql_real_connect_dns_srv() C API function rather than mysql_real_connect(). However, if the connect command is subsequently used at runtime and specifies a host name argument, that host name takes precedence over any --dns-srv-name option given at mysql startup to specify a DNS SRV record.\n如果同时给出--dns-srv-name和--host选项，--dns-srv-name选项优先于--host选项。--dns-srv-name会导致连接的建立使用mysql_real_connect_dns_srv() C API函数，而不是 mysql_real_connect()。不过，如果随后在运行时使用 connect 命令并指定了主机名参数，则该主机名优先于在 mysql 启动时指定 DNS SRV 记录的任何 --dns-srv-name 选项。\n此选项在 MySQL 8.0.22 中添加。\n--enable-cleartext-plugin Command-Line Format --enable-cleartext-plugin Type Boolean Default Value FALSE 启用mysql_clear_password明文身份验证插件。（请参阅\u0026ldquo;Client-Side Cleartext Pluggable Authentication\u0026rdquo;）。\n--execute=statement, -e statement Command-Line Format --execute=statement Type String 执行语句并退出。默认输出格式与使用 --batch 生成的格式相同。请参阅\u0026ldquo;Using Options on the Command Line\u0026rdquo;，了解一些示例。使用该选项后，mysql 不使用历史文件。\n--fido-register-factor=value Command-Line Format --fido-register-factor=value Introduced 8.0.27 Deprecated 8.0.35 Type String 注意： 自 MySQL 8.0.35 起，该选项已被弃用，并可能在未来的 MySQL 版本中删除。\n必须进行 FIDO 设备注册的一个或多个因素。该选项值必须是单个值，或用逗号分隔的两个值。每个值必须是 2 或 3，因此允许的选项值有 \u0026ldquo;2\u0026rdquo;、\u0026ldquo;3\u0026rdquo;、\u0026ldquo;2,3 \u0026ldquo;和 \u0026ldquo;3,2\u0026rdquo;。\n例如，需要注册第 3 个身份验证因素的账户调用 mysql 客户端的步骤如下：\n1 mysql --user=user_name --fido-register-factor=3 需要注册第 2 和第 3 个身份验证因素的账户调用 mysql 客户端的方式如下：\n1 mysql --user=user_name --fido-register-factor=2,3 如果注册成功，就会建立连接。如果存在待注册的身份验证因素，则在尝试连接服务器时，连接会进入待注册模式。在这种情况下，请断开连接，然后使用正确的 -fido-register-factor 值重新连接，以完成注册。\n注册分两个步骤，包括initiate registration和finish registration两个步骤。启动注册步骤执行本语句：\n1 ALTER USER user factor INITIATE REGISTRATION 语句会返回一个结果集，其中包含一个 32 字节的challenge、user name和relying party ID（请参阅\u0026rdquo;\u0026ldquo;authentication_fido_rp_id\u0026rdquo;\u0026quot;）。\nfinish registration步骤将执行该语句：\n1 ALTER USER user factor FINISH REGISTRATION SET CHALLENGE_RESPONSE AS \u0026#39;auth_string\u0026#39; 语句完成注册并向服务器发送以下信息，作为 auth_string 的一部分：验证器数据、X.509 格式的可选认证证书和签名。\n启动和注册步骤必须在单个连接中执行，因为客户端在启动步骤中收到的挑战会保存到客户端连接处理程序中。如果在不同的连接中执行注册步骤，注册就会失败。使用--fido-register-factor选项可同时执行启动和注册步骤，从而避免上述失败情况，并避免手动执行ALTER USER启动和注册语句。\n--fido-register-factor选项仅适用于mysql客户端和 MySQL Shell。其他 MySQL 客户端程序不支持该选项。\n相关信息请参阅\u0026ldquo;Using FIDO Authentication\u0026rdquo;。\n--force, -f Command-Line Format --force 即使出现 SQL 错误也要继续。\n--get-server-public-key Command-Line Format --get-server-public-key Type Boolean 向服务器请求基于 RSA 密钥对的密码交换所需的公钥。该选项适用于使用 caching_sha2_password 验证插件进行验证的客户端。对于该插件，除非请求，否则服务器不会发送公钥。对于不使用该插件进行身份验证的账户，该选项将被忽略。如果不使用基于 RSA 的密码交换，如客户端使用安全连接连接到服务器时，该选项也会被忽略。\n如果给出了 --server-public-key-path=file_name，并指定了一个有效的公钥文件，则它优先于 --get-server-public-key。\n有关 caching_sha2_password 插件的信息，请参阅\u0026ldquo;Caching SHA-2 Pluggable Authentication\u0026rdquo;。\n--histignore Command-Line Format --histignore=pattern_list Type String 由一个或多个冒号分隔模式组成的列表，用于指定忽略日志记录的语句。这些模式会添加到默认模式列表（\u0026rdquo;*IDENTIFIED*:*PASSWORD*\u0026quot;）中。为该选项指定的值会影响写入历史文件的语句的日志记录，如果给定了 --syslog选项，还会影响写入 syslog 的日志记录。更多信息，请参阅\u0026ldquo;mysql Client Logging\u0026rdquo;。\n--host=host_name, -h host_name Command-Line Format --host=host_name Type String Default Value localhost 连接指定主机上的 MySQL 服务器。\n如果同时给出--dns-srv-name和--host选项，--dns-srv-name选项优先于--host选项。dns-srv-name会导致连接的建立使用mysql_real_connect_dns_srv() C API函数，而不是mysql_real_connect()。但是，如果随后在运行时使用 connect 命令并指定了主机名参数，则该主机名优先于在 mysql 启动时指定 DNS SRV 记录的任何 --dns-srv-name 选项。\n--html, -H Command-Line Format --html 生成 HTML 输出。\n--ignore-spaces, -i Command-Line Format --ignore-spaces 忽略函数名称后的空格。其效果在有关 IGNORE_SPACE SQL 模式的讨论中有所描述（参见\u0026ldquo;Server SQL Modes\u0026rdquo;）。\n--init-command=str Command-Line Format --init-command=str 连接服务器后要执行的 SQL 语句。如果启用了自动重新连接，则会在重新连接后再次执行语句。\n--line-numbers Command-Line Format --line-numbers Disabled by skip-line-numbers 为错误写入行号。使用 -skip-line-numbers禁用此功能。\n--load-data-local-dir=dir_name Command-Line Format --load-data-local-dir=dir_name Introduced 8.0.21 Type Directory name Default Value empty string 该选项会影响客户机端 LOCAL 功能对 LOAD DATA 操作的影响。它指定了在 LOAD DATA LOCAL 语句中命名的文件必须位于的目录。load-data-local-dir的效果取决于 LOCAL 数据加载是启用还是禁用：\n如果启用了本地数据加载（在 MySQL 客户端库中默认启用或通过指定 --local-infile[=1]），则会忽略 --load-data-local-dir选项。\n如果 MySQL 客户端库默认或通过指定 --local-infile=0禁用了本地数据加载，则 --load-data-local-dir选项适用。\n当使用--load-data-local-dir时，选项值指定了本地数据文件所在的目录。无论底层文件系统的大小写敏感性如何，目录路径名和要加载的文件路径名的比较都是区分大小写的。如果选项值为空字符串，则不命名任何目录，结果是不允许加载本地数据文件。\n例如，要显式禁用本地数据加载（位于 /my/local/data 目录下的文件除外），请像这样调用 mysql ：\n1 mysql --local-infile=0 --load-data-local-dir=/my/local/data 当同时给出 --local-infile 和 --load-data-local-dir 时，它们的顺序并不重要。\n在 mysql 中成功使用 LOCAL 加载操作还要求服务器允许本地加载；请参阅\u0026ldquo;Security Considerations for LOAD DATA LOCAL\u0026rdquo;\n在 MySQL 8.0.21 中添加了--load-data-local-dir选项。\n--local-infile[={0|1}] Command-Line Format --local-infile[={0|1}] Type Boolean Default Value FALSE 默认情况下，LOAD DATA的本地能力由编译到 MySQL 客户端库中的默认值决定。要明确启用或禁用本地数据加载，请使用 --local-infile 选项。如果不指定值，该选项将启用本地数据加载。如果给出的是--local-infile=0或--local-infile=1，则该选项会禁用或启用本地数据加载。\n如果禁用了 LOCAL 功能，则可以使用 --load-data-local-dir 选项来限制本地加载指定目录中的文件。\n在 mysql 中成功使用 LOCAL 加载操作还要求服务器允许本地加载；请参阅\u0026ldquo;Security Considerations for LOAD DATA LOCAL\u0026rdquo;\n--login-path=name Command-Line Format --login-path=name Type String Read options from the named login path in the .mylogin.cnf login path file. A \u0026ldquo;login path\u0026rdquo; is an option group containing options that specify which MySQL server to connect to and which account to authenticate as. To create or modify a login path file, use the mysql_config_editor utility. See \u0026ldquo;mysql_config_editor — MySQL Configuration Utility\u0026rdquo;.\n从 .mylogin.cnf 登录路径文件中指定的登录路径读取选项。登录路径 \u0026ldquo;是一个选项组，包含指定连接到哪个 MySQL 服务器和以哪个账户进行身份验证的选项。要创建或修改登录路径文件，请使用mysql_config_editor工具。参见\u0026ldquo;mysql_config_editor — MySQL Configuration Utility\u0026rdquo;。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--max-allowed-packet=value Command-Line Format --max-allowed-packet=value Type Numeric Default Value 16777216 客户端/服务器通信缓冲区的最大大小。默认为 16MB，最大为 1GB。\n--max-join-size=value Command-Line Format --max-join-size=value Type Numeric Default Value 1000000 使用 --safe-updates 时连接中记录的自动限制。（默认值为 1,000,000）。\n--named-commands, -G Command-Line Format --named-commands Disabled by skip-named-commands Enable named mysql commands. Long-format commands are permitted, not just short-format commands. For example, quit and \\q both are recognized. Use --skip-named-commands to disable named commands. See \u0026ldquo;mysql Client Commands\u0026rdquo;.\n启用已命名的 mysql 命令。允许使用长格式命令，而不仅仅是短格式命令。例如，quit和\\q都能被识别。使用 -skip-named-commands禁用命名命令。参见\u0026ldquo;mysql Client Commands\u0026rdquo;。\n--net-buffer-length=value Command-Line Format --net-buffer-length=value Type Numeric Default Value 16384 TCP/IP 和套接字通信的缓冲区大小。（默认值为 16KB）。\n--network-namespace=name Command-Line Format --network-namespace=name Introduced 8.0.22 Type String TCP/IP 连接使用的网络命名空间。如果省略，连接将使用默认（全局）命名空间。有关网络命名空间的信息，请参阅\u0026ldquo;Network Namespace Support\u0026rdquo;。\n此选项在 MySQL 8.0.22 中添加。它仅适用于支持网络命名空间的平台。\n--no-auto-rehash, -A Command-Line Format --no-auto-rehash Deprecated Yes 与--skip-auto-rehash效果相同。请参阅--auto-rehash的说明。\n--no-beep, -b Command-Line Format --no-beep 发生错误时不发出蜂鸣声。\n--no-defaults Command-Line Format --no-defaults 不读取任何选项文件。如果从选项文件中读取未知选项导致程序启动失败，可以使用--no-defaults来阻止读取这些选项。\n例外情况是，如果存在 .mylogin.cnf 文件，则在所有情况下都会读取该文件。这样，即使使用了--no-defaults，也能以比命令行更安全的方式指定密码。要创建 .mylogin.cnf，请使用 mysql_config_editor 工具。请参阅\u0026ldquo;mysql_config_editor — MySQL Configuration Utility\u0026rdquo;。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--one-database, -o Command-Line Format --one-database 忽略语句，但默认数据库为命令行中指定的数据库时出现的语句除外。该选项非常简单，应谨慎使用。语句过滤只基于 USE 语句。\n最初，mysql 执行输入中的语句，因为在命令行中指定数据库 db_name 等于在输入的开头插入 USE db_name。然后，对于遇到的每一条 USE 语句，mysql 都会接受或拒绝以下语句，这取决于所指定的数据库是否是命令行中的数据库。语句的内容无关紧要。\n假设调用 mysql 处理这组语句：\n1 2 3 4 5 6 7 DELETE FROM db2.t2; USE db2; DROP TABLE db1.t1; CREATE TABLE db1.t1 (i INT); USE db1; INSERT INTO t1 (i) VALUES(1); CREATE TABLE db2.t1 (j INT); 如果命令行是 mysql --force --one-database db1，mysql 会如下处理输入：\n由于默认数据库是 db1，所以执行了 DELETE 语句，尽管该语句命名的是另一个数据库中的表。\n由于默认数据库不是 db1，所以未执行 DROP TABLE 和 CREATE TABLE 语句，即使这些语句命名了 db1 中的表。\n由于默认数据库是 db1，因此会执行 INSERT 和 CREATE TABLE 语句，即使 CREATE TABLE 语句命名了不同数据库中的表。\n--pager[=command] Command-Line Format --pager[=command] Disabled by skip-pager Type String 使用给定命令对查询输出进行分页。如果省略该命令，默认分页器就是 PAGER 环境变量的值。有效的分页器有less、more、cat [\u0026gt; filename] 等。该选项仅在 Unix 和交互模式下有效。要禁用分页功能，请使用 -skip-pager。请参阅\u0026ldquo;mysql Client Commands\u0026rdquo;节将进一步讨论输出分页。\n--password[=password], -p [password] Command-Line Format --password[=password] Type String 用于连接服务器的 MySQL 账户密码。密码值是可选的。如果未给出，mysql 会提示输入密码。如果指定了密码，--password=或-p与后面的密码之间必须无空格。如果没有指定密码选项，默认情况下不发送密码。\n在命令行中指定密码是不安全的。为避免在命令行上提供密码，请使用选项文件。请参阅\u0026ldquo;End-User Guidelines for Password Security\u0026rdquo;。\n要明确指定不需要密码，也不提示mysql输入密码，可使用--skip-password选项。\n--password1[=pass_val] 用于连接服务器的 MySQL 账户的多因素身份验证因素 1 的密码。密码值是可选的。如果未给出，mysql 会提示输入密码。如果给定，--password1=和后面的密码之间必须没有空格。如果未指定密码选项，默认情况下不发送密码。\n在命令行中指定密码是不安全的。为避免在命令行上提供密码，请使用选项文件。请参阅\u0026ldquo;End-User Guidelines for Password Security\u0026rdquo;。\n要明确指定没有密码，且 mysql 不提示输入密码，请使用 --skip-password1 选项。\n--password1和--password是同义词，--skip-password1和--skip-password也是同义词。\n--password2[=pass_val] 用于连接服务器的 MySQL 账户的多因素身份验证因素 2 的密码。该选项的语义类似于--password1的语义；详情请参见该选项的说明。\n--password3[=pass_val] 用于连接服务器的 MySQL 账户的多因素身份验证因素 3 的密码。该选项的语义类似于--password1的语义；详情请参见该选项的说明。\n--pipe, -W Command-Line Format --pipe Type String 在 Windows 系统中，使用命名管道连接服务器。只有在服务器启动时启用了支持命名管道连接的系统变量named_pipe，此选项才适用。此外，进行连接的用户必须是由 named_pipe_full_access_group 系统变量指定的 Windows 组的成员。\n--plugin-authentication-kerberos-client-mode=value Command-Line Format --plugin-authentication-kerberos-client-mode Introduced 8.0.32 Type String Default Value SSPI Valid Values GSSAPI / SSPI 在 Windows 系统中，authentication_kerberos_client 身份验证插件支持该插件选项。它提供两种可能的值，客户端用户可在运行时进行设置： SSPI 和 GSSAPI。\n客户端插件选项的默认值使用安全支持提供程序接口（SSPI），该接口可从 Windows 内存缓存中获取凭证。另外，客户端用户也可以选择通过 Windows 上的 MIT Kerberos 库支持通用安全服务应用程序接口（GSSAPI）的模式。GSSAPI 能够获取以前使用 kinit 命令生成的缓存凭证。\n更多信息，请参阅 Commands for Windows Clients in GSSAPI Mode。\n--plugin-dir=dir_name Command-Line Format --plugin-dir=dir_name Type Directory name 查找插件的目录。如果使用--default-auth选项指定了一个身份验证插件，但mysql没有找到它，则指定此选项。参见\u0026ldquo;Pluggable Authentication\u0026rdquo;。\n--port=port_num, -P port_num Command-Line Format --port=port_num Type Numeric Default Value 3306 对于 TCP/IP 连接，要使用的端口号。\n--print-defaults Command-Line Format --print-defaults 打印程序名称及其从选项文件中获取的所有选项。\n有关该选项和其他选项文件选项的更多信息，请参阅\u0026ldquo;Command-Line Options that Affect Option-File Handling\u0026rdquo;。\n--protocol={TCP|SOCKET|PIPE|MEMORY} Command-Line Format --protocol=type Type String Default Value [see text] Valid Values TCP / SOCKET / PIPE / MEMORY 用于连接服务器的传输协议。当其他连接参数通常会导致使用与所需协议不同的协议时，该协议非常有用。有关允许值的详细信息，请参阅章节\u0026ldquo;Connection Transport Protocols\u0026rdquo;。\n--quick, -q Command-Line Format --quick 不要缓存每个查询结果，而是在收到每一行时打印出来。如果暂停输出，服务器速度可能会变慢。使用此选项后，mysql 不会使用历史文件。\n--raw, -r Command-Line Format --raw 对于表格输出，列周围的 \u0026ldquo;方框\u0026rdquo; 可使一列值与另一列值区分开来。对于非表格输出（例如在批处理模式下或使用 --batch 或 --silent 选项时产生的输出），特殊字符会在输出中转义，以便于识别。换行符、制表符、NUL 和反斜线被写成 \\n、\\t、\\0 和 \\\\。--raw 选项会禁用这种字符转义。\n下面的示例演示了表格输出与非表格输出，以及使用原始模式禁用转义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 % mysql mysql\u0026gt; SELECT CHAR(92); +----------+ | CHAR(92) | +----------+ | \\ | +----------+ % mysql -s mysql\u0026gt; SELECT CHAR(92); CHAR(92) \\\\ % mysql -s -r mysql\u0026gt; SELECT CHAR(92); CHAR(92) \\ --reconnect Command-Line Format --reconnect Disabled by skip-reconnect 如果与服务器的连接丢失，会自动尝试重新连接。每次连接丢失都会尝试一次重新连接。要抑制重新连接行为，请使用 -skip-reconnect。\n--asfe-updates, --i-am-a-dummy, -U Command-Line Format --safe-updates / --i-am-a-dummy Type Boolean Default Value FALSE 如果启用了该选项，在 WHERE 子句中未使用键或 LIMIT 子句的 UPDATE 和 DELETE 语句将产生错误。此外，对产生（或估计会产生）超大结果集的 SELECT 语句也会进行限制。如果在选项文件中设置了该选项，可以在命令行中使用 -skip-safe-updates来覆盖它。有关该选项的更多信息，请参阅Using Safe-Updates Mode (\u0026ndash;safe-updates)。\n--select-limit=value Command-Line Format --select-limit=value Type Numeric Default Value 1000 使用 --safe-updates 时 SELECT 语句的自动限制。（默认值为 1,000）。\n--server-public-key-path=file_name Command-Line Format --server-public-key-path=file_name Type File name PEM 格式文件的路径名，该文件包含服务器在基于 RSA 密钥对的密码交换中需要的公钥的客户端副本。该选项适用于使用 sha256_password 或 caching_sha2_password 身份验证插件进行身份验证的客户端。对于未使用上述插件之一进行身份验证的账户，该选项将被忽略。如果不使用基于 RSA 的密码交换，如客户端使用安全连接连接到服务器时，该选项也会被忽略。\n如果给出了 --server-public-key-path=file_name，并指定了一个有效的公钥文件，则它优先于 --get-server-public-key。\n对于 sha256_password，该选项仅适用于使用 OpenSSL 构建的 MySQL。\n有关 sha256_password 和 caching_sha2_password 插件的信息，请参阅第 \u0026ldquo;SHA-256 Pluggable Authentication\u0026rdquo; 和第 \u0026ldquo;Caching SHA-2 Pluggable Authentication\u0026rdquo; 。\n--shared-memory-base-name=name Command-Line Format --shared-memory-base-name=name Platform Specific Windows 在 Windows 中，使用共享内存连接本地服务器时要使用的共享内存名称。默认值为 MYSQL。共享内存名称区分大小写。\n该选项仅适用于服务器启动时启用了 shared_memory 系统变量以支持共享内存连接的情况。\n--show-warnings Command-Line Format --show-warnings 在每条语句后显示警告（如果有的话）。该选项适用于交互式和批处理模式。\n--sigint-ignore Command-Line Format --sigint-ignore 忽略 SIGINT 信号（通常是输入 Control+C 的结果）。\n如果没有该选项，键入 Control+C 会中断当前语句，否则会取消任何部分输入行。\n--silent, -s Command-Line Format --silent 静音模式。减少输出。该选项可多次使用，以减少输出。\n该选项会导致非表格输出格式和特殊字符转义。使用原始模式可以禁用 \u0026ldquo;转义\u0026rdquo;；请参阅--raw选项的说明。\n--skip-column-names, -N Command-Line Format --skip-column-names 不要在结果中写入列名。\n--skpi-line-numbers, -L Command-Line Format --skpi-line-numbers 不写入错误的行号。在比较包含错误信息的结果文件时非常有用。\n--socket=path, -S path Command-Line Format --socket={file_name|pipe_name} Type String 对于与 localhost 的连接，要使用的 Unix 套接字文件，或者在 Windows 下，要使用的命名管道名称。\n在 Windows 系统中，只有在服务器启动时启用了named_pipe系统变量以支持命名管道连接的情况下，该选项才适用。此外，进行连接的用户必须是由 named_pipe_full_access_group 系统变量指定的 Windows 组的成员。\n--ssl* 以--ssl开头的选项指定是否使用加密方式连接服务器，并指明在哪里可以找到 SSL 密钥和证书。请参阅Command Options for Encrypted Connections。\n--ssl-fips-mode={OFF|ON|STRICT} Command-Line Format --ssl-fips-mode={OFF|ON|STRICT} Deprecated 8.0.34 Type Enumeration Default Value OFF Valid Values OFF / ON / STRICT 控制是否在客户端启用 FIPS 模式。--ssl-fips-mode选项与其他--ssl-xxx选项不同，它不是用来建立加密连接，而是影响允许哪些加密操作。请参阅\u0026ldquo;FIPS Support\u0026rdquo;。\n允许使用这些--ssl-fips-mode值：\nOFF: 禁用 FIPS 模式。\nON: 启用 FIPS 模式。\nSTRICT: 启用 \u0026ldquo;strict\u0026rdquo; FIPS 模式。\n**注意：**如果 OpenSSL FIPS 对象模块不可用，-ssl-fips-mode 的唯一允许值是 OFF。在这种情况下，将 -ssl-fips-mode 设置为 ON 或 STRICT 会导致客户端在启动时发出警告，并以非 FIPS 模式运行。\n自 MySQL 8.0.34 起，该选项已被弃用。预计未来的 MySQL 版本将删除该选项。\n--syslog, -j Command-Line Format --syslog 该选项会使mysql向系统日志设备发送交互式语句。在 Unix 系统中，这是 syslog；在 Windows 系统中，这是 Windows 事件日志。记录信息的目的地取决于系统。在 Linux 系统中，目的地通常是 /var/log/messages 文件。\n下面是使用 --syslog 在 Linux 上生成的输出示例。为便于阅读，该输出已格式化；每条记录的信息实际上只占一行。\n1 2 3 4 5 6 Mar 7 12:39:25 myhost MysqlClient[20824]: SYSTEM_USER:\u0026#39;oscar\u0026#39;, MYSQL_USER:\u0026#39;my_oscar\u0026#39;, CONNECTION_ID:23, DB_SERVER:\u0026#39;127.0.0.1\u0026#39;, DB:\u0026#39;--\u0026#39;, QUERY:\u0026#39;USE test;\u0026#39; Mar 7 12:39:28 myhost MysqlClient[20824]: SYSTEM_USER:\u0026#39;oscar\u0026#39;, MYSQL_USER:\u0026#39;my_oscar\u0026#39;, CONNECTION_ID:23, DB_SERVER:\u0026#39;127.0.0.1\u0026#39;, DB:\u0026#39;test\u0026#39;, QUERY:\u0026#39;SHOW TABLES;\u0026#39; 更多信息，请参阅\u0026ldquo;mysql Client Logging\u0026rdquo;。\n--table, -t Command-Line Format --table 以表格格式显示输出。这是交互式使用的默认设置，但也可用于在批处理模式下生成表格输出。\n--tee-file_name Command-Line Format --tee=file_name Type File name 将输出副本附加到指定文件。该选项仅在交互模式下有效。请参阅\u0026ldquo;mysql Client Commands\u0026rdquo; ，将进一步讨论 tee 文件。\n--tls-ciphersuites=ciphersuite_list Command-Line Format --tls-ciphersuites=ciphersuite_list Introduced 8.0.16 Type String 使用 TLSv1.3 的加密连接允许使用的密码套件。该值是一个或多个以冒号分隔的密码组名称列表。可为该选项命名的密码库取决于编译 MySQL 时使用的 SSL 库。详情请参阅\u0026ldquo;Encrypted Connection TLS Protocols and Ciphers\u0026rdquo;。\nThis option was added in MySQL 8.0.16.\n--tls-version=protocol_list Command-Line Format --tls-version=protocol_list Type String Default Value(≥ 8.0.19) TLSv1,TLSv1.1,TLSv1.2,TLSv1.3 (OpenSSL 1.1.1 or higher) / TLSv1,TLSv1.1,TLSv1.2 (otherwise) Default Value(≤ 8.0.18) TLSv1,TLSv1.1,TLSv1.2 允许用于加密连接的 TLS 协议。值是一个或多个以逗号分隔的协议名称列表。可以为该选项命名的协议取决于编译 MySQL 时使用的 SSL 库。详情请参阅\u0026ldquo;Encrypted Connection TLS Protocols and Ciphers\u0026rdquo;。\n--unbuffered, -n Command-Line Format --unbuffered 每次查询后清空缓冲区。\n--user=user_name, -u user_name Command-Line Format --user=user_name Type String 用于连接服务器的 MySQL 账户的用户名。\n--verbose, -v Command-Line Format --verbose 详细模式。输出更多有关程序运行的信息。该选项可以多次使用，以产生越来越多的输出。（例如，-v -v -v 即使在批处理模式下也能产生表格输出格式）。\n--version, -V Command-Line Format --version 显示版本信息并退出。\n--vertical, -E Command-Line Format --vertical 垂直打印查询输出行（每列值一行）。如果不使用该选项，可以通过以 \\G 结束单个语句来指定垂直输出。\n--wait, -w Command-Line Format --wait 如果无法建立连接，请等待并重试，而不是放弃。\n--xml, -X Command-Line Format --xml 生成 XML 输出。\n1 \u0026lt;field name=\u0026#34;column_name\u0026#34;\u0026gt;NULL\u0026lt;/field\u0026gt; 当 --xml 与 mysql 一起使用时，输出结果与 mysqldump --xml 的输出结果一致。详见\u0026ldquo;mysqldump — A Database Backup Program\u0026rdquo;。\nXML 输出也使用 XML 命名空间，如图所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $\u0026gt; mysql --xml -uroot -e \u0026#34;SHOW VARIABLES LIKE \u0026#39;version%\u0026#39;\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;resultset statement=\u0026#34;SHOW VARIABLES LIKE \u0026#39;version%\u0026#39;\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;row\u0026gt; \u0026lt;field name=\u0026#34;Variable_name\u0026#34;\u0026gt;version\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;Value\u0026#34;\u0026gt;5.0.40-debug\u0026lt;/field\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;row\u0026gt; \u0026lt;field name=\u0026#34;Variable_name\u0026#34;\u0026gt;version_comment\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;Value\u0026#34;\u0026gt;Source distribution\u0026lt;/field\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;row\u0026gt; \u0026lt;field name=\u0026#34;Variable_name\u0026#34;\u0026gt;version_compile_machine\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;Value\u0026#34;\u0026gt;i686\u0026lt;/field\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;row\u0026gt; \u0026lt;field name=\u0026#34;Variable_name\u0026#34;\u0026gt;version_compile_os\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;Value\u0026#34;\u0026gt;suse-linux-gnu\u0026lt;/field\u0026gt; \u0026lt;/row\u0026gt; \u0026lt;/resultset\u0026gt; --zstd-compression-level=level Command-Line Format --zstd-compression-level=# Introduced 8.0.18 Type Integer 使用 zstd 压缩算法的服务器连接所使用的压缩级别。允许的压缩级别从 1 到 22，数值越大，压缩级别越高。默认的 zstd 压缩级别为 3。 压缩级别设置对不使用 zstd 压缩的连接没有影响。\n更多信息，请参阅\u0026ldquo;Connection Compression Control\u0026rdquo;。\n此选项在 MySQL 8.0.18 中添加。\nmysql 客户端命令 mysql 会将你发出的每条 SQL 语句发送到服务器执行。此外，mysql本身也会解释一组命令。要查看这些命令的列表，请在 mysql\u0026gt; 提示符下键入 help 或 \\h：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 mysql\u0026gt; help List of all MySQL commands: Note that all text commands must be first on line and end with \u0026#39;;\u0026#39; ? (\\?) Synonym for `help\u0026#39;. clear (\\c) Clear the current input statement. connect (\\r) Reconnect to the server. Optional arguments are db and host. delimiter (\\d) Set statement delimiter. edit (\\e) Edit command with $EDITOR. ego (\\G) Send command to mysql server, display result vertically. exit (\\q) Exit mysql. Same as quit. go (\\g) Send command to mysql server. help (\\h) Display this help. nopager (\\n) Disable pager, print to stdout. notee (\\t) Don\u0026#39;t write into outfile. pager (\\P) Set PAGER [to_pager]. Print the query results via PAGER. print (\\p) Print current command. prompt (\\R) Change your mysql prompt. quit (\\q) Quit mysql. rehash (\\#) Rebuild completion hash. source (\\.) Execute an SQL script file. Takes a file name as an argument. status (\\s) Get status information from the server. system (\\!) Execute a system shell command. tee (\\T) Set outfile [to_outfile]. Append everything into given outfile. use (\\u) Use another database. Takes database name as argument. charset (\\C) Switch to another charset. Might be needed for processing binlog with multi-byte charsets. warnings (\\W) Show warnings after every statement. nowarning (\\w) Don\u0026#39;t show warnings after every statement. resetconnection(\\x) Clean session context. query_attributes Sets string parameters (name1 value1 name2 value2 ...) for the next query to pick up. ssl_session_data_print Serializes the current SSL session data to stdout or file. For server side help, type \u0026#39;help contents\u0026#39; 如果在调用mysql时使用了--binary-mode选项，那么在非交互模式下（对于通过管道输入到mysql或使用source命令加载的输入），除了charset和delimiter之外，所有mysql命令都会被禁用。\n每条命令都有长、短两种形式。长命令不区分大小写，短命令区分大小写。长命令后可以加上分号结束符，但短命令则不可以。\n不支持在多行 /* \u0026hellip; */ 注释中使用短格式命令。短格式命令可以在单行 /*! \u0026hellip; */ 版本注释中使用，存储在对象定义中的 /*+ \u0026hellip; */ 优化器提示注释也是如此。如果担心优化器提示注释可能存储在对象定义中，从而导致在使用 mysql 重载转储文件时执行此类命令，则应使用 --binary-mode 选项调用 mysql，或使用 mysql以外的重载客户端。\nhelp [arg], \\h [arg], \\? [arg], ? [arg]\n显示帮助信息，列出可用的 mysql 命令。\n如果为 help 命令提供参数，mysql 会将其用作搜索字符串，从《MySQL 参考手册》的内容中访问服务器端帮助。更多信息，请参阅\u0026ldquo;mysql Client Server-Side Help\u0026rdquo;。\ncharset charset_name, \\C charset_name\n更改默认字符集并发布一条 SET NAMES 语句。这样，如果 mysql 运行时启用了自动重新连接（不建议这样做），客户端和服务器上的字符集就能保持同步，因为重新连接时会使用指定的字符集。\nclear, \\c\n清除当前输入。如果改变主意不执行正在输入的语句，请使用此功能。\nconnect [db_name [host_name]], \\r [db_name [host_name]]\n重新连接服务器。可选的数据库名称和主机名称参数可用于指定默认数据库或运行服务器的主机。如果省略，则使用当前值。\n如果 connect 命令指定了主机名参数，则该主机优先于在 mysql 启动时指定 DNS SRV 记录的任何 --dns-srv-name 选项。\ndelimiter str, \\d str\n更改mysql解释为 SQL 语句之间分隔符的字符串。默认为分号（;）。\n分隔符字符串可以在 delimiter 命令行中指定为无引号或有引号参数。引号可以使用单引号（\u0026rsquo;）、双引号（\u0026quot;）或回车键（`）字符。要在引号字符串中包含引号，可以使用不同的引号字符或反斜杠（\\）字符转义引号。在引号字符串之外应避免使用反斜杠，因为它是 MySQL 的转义字符。对于未加引号的参数，分隔符一直读到第一个空格或行尾。对于带引号的参数，分隔符读到行中匹配的引号为止。\n除了在带引号的字符串中，mysql 会将任何分隔符字符串实例解释为语句分隔符。在定义可能出现在其他单词中的分隔符时要小心。例如，如果将分隔符定义为 X，就不能在语句中使用 INDEX 这个词。mysql 会将其解释为 INDE，后跟分隔符 X。\n当mysql识别的分隔符设置为默认的;以外的字符时，该字符的实例无需解释即可发送到服务器。不过，服务器本身仍会将;解释为语句分隔符，并据此处理语句。服务器端的这种行为适用于多语句执行（参见Multiple Statement Execution Support），以及解析存储过程和函数、触发器和事件的正文（参见\u0026ldquo;Defining Stored Programs\u0026rdquo;）。\nedit, \\e\n编辑当前输入语句。mysql 会检查 EDITOR 和 VISUAL 环境变量的值，以确定使用哪个编辑器。如果两个变量都未设置，则默认编辑器为 vi。\nedit 命令只在 Unix 下运行。\nego, \\G\n将当前语句发送到服务器执行，并使用垂直格式显示结果。\nexit, \\q\n退出 mysql。\ngo, \\g\n将当前语句发送到服务器执行。\nnopaper, \\n\n禁用输出分页。请参阅 pager 的说明。\nnopaper命令仅在Unix系统中有效。\nnotee, \\t\n禁用向 tee 文件复制输出。请参阅 tee 的说明。\nnowarning, \\w\n禁止在每个语句后显示警告。\npager [command], \\P [command]\n启用输出分页。通过在调用 mysql 时使用 --pager 选项，可以使用 Unix 程序（如 less、more 或其他类似程序）在交互模式下浏览或搜索查询结果。如果不指定该选项的值，mysql 会检查 PAGER 环境变量的值，并将寻呼器设置为该值。寻呼器功能仅在交互模式下工作。\n输出分页可以通过 pager 命令交互式启用，也可以通过 nopager 命令禁用。该命令包含一个可选参数；如果给出该参数，则分页程序将被设置为该参数。如果没有参数，分页程序将设置为命令行设置的分页程序，如果没有指定分页程序，则设置为 stdout。\n输出分页功能仅适用于 Unix 系统，因为它使用了 popen() 函数，而 Windows 系统中不存在该函数。在 Windows 中，可以使用 tee 选项来保存查询输出，但在某些情况下，它不如 pager 方便浏览输出。\nprint, \\p\n打印当前输入语句，但不执行该语句。\nprompt [str], \\R [str]\n将 mysql 提示符重新配置为给定字符串。提示符中可使用的特殊字符序列将在本节后面介绍。\n如果指定不带参数的 prompt 命令，mysql 会将提示重置为默认的 mysql\u0026gt;。\nquery_attributes name value [name value \u0026hellip;]\n定义适用于下一次发送到服务器的查询的查询属性。有关查询属性的目的和用途，请参阅\u0026ldquo;Query Attributes\u0026rdquo;。\nquery_attributes 命令遵循这些规则：\n属性名和值的格式和引号规则与 delimiter 命令相同。\n该命令最多允许 32 个属性名/值对。名称和值的长度最多为 1024 个字符。如果给出的名称没有值，则会出错。\n如果在执行查询之前发布了多条query_attributes命令，则只有最后一条命令适用。发送查询后，mysql 会清除属性集。\n如果用相同的名称定义了多个属性，尝试检索属性值的结果将是未定义的。\n用空名称定义的属性无法通过名称检索。\n如果在mysql执行查询时发生重新连接，mysql会在重新连接后恢复属性，这样就可以用相同的属性再次执行查询。\nquit, \\q\n退出 mysql。\nrehash, \\#\nRebuild the completion hash that enables database, table, and column name completion while you are entering statements. (See the description for the --auto-rehash option.)\n重建完成哈希值，以便在输入语句时启用数据库、表和列名完成。（请参阅--auto-rehash选项的说明）。\nresetconnection, \\x\n重置连接以清除会话状态。这包括清除使用 query_attributes 命令定义的任何当前查询属性。\n重置连接的效果与 mysql_change_user() 或自动重新连接类似，但连接不会关闭和重新打开，也不会重新进行身份验证。请参阅 mysql_change_user() 和 Automatic Reconnection Control。\n本例展示了 resetconnection 如何清除会话状态中的一个值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 mysql\u0026gt; SELECT LAST_INSERT_ID(3); +-------------------+ | LAST_INSERT_ID(3) | +-------------------+ | 3 | +-------------------+ mysql\u0026gt; SELECT LAST_INSERT_ID(); +------------------+ | LAST_INSERT_ID() | +------------------+ | 3 | +------------------+ mysql\u0026gt; resetconnection; mysql\u0026gt; SELECT LAST_INSERT_ID(); +------------------+ | LAST_INSERT_ID() | +------------------+ | 0 | +------------------+ source file_name, \\. file_name\n读取指定文件并执行其中包含的语句。在 Windows 系统中，指定路径名分隔符为 / 或 \\\\。\n引号字符作为文件名本身的一部分。为达到最佳效果，文件名不应包含空格字符。\nssl_session_data_print [file_name]\n获取、序列化并存储成功连接的会话数据。可选的文件名和参数可用于指定存储序列化会话数据的文件。如果省略，会话数据将打印到 stdout。\n如果 MySQL 会话配置为重复使用，文件中的会话数据将被反序列化，并提供给 connect 命令以重新连接。会话重用成功后，status 命令将包含一行显示 SSL session reused: true 的内容，同时客户端将保持与服务器的重新连接。\nstatus, \\s\n提供连接和服务器的状态信息。如果启用了 --safe-updates 功能，status 还会打印影响查询的 mysql 变量的值。\nsystem command, \\! command\n使用默认命令解释器执行给定命令。\n在 MySQL 8.0.19 之前，system 命令只能在 Unix 下运行。从 8.0.19 开始，它也能在 Windows 上运行。\ntee [file_name], \\T [file_name]\n在调用 mysql 时使用 --tee 选项，可以记录语句及其输出。屏幕上显示的所有数据都会追加到指定文件中。这对调试也非常有用。每条语句结束后，mysql 会在打印下一条提示语之前将结果刷新到文件中。此功能仅在交互模式下有效。\n您可以使用 tee 命令交互式地启用这一功能。如果没有参数，则使用前一个文件。可以使用 notee 命令禁用 tee 文件。再次执行 tee 可重新启用日志记录功能。\nuse db_name, \\u db_name\n使用 db_name 作为默认数据库。\nwarnings, \\W\n启用在每条语句后显示警告（如果有的话）。\n下面是一些关于 pager 命令的提示：\n您可以用它来写入文件，而且结果只写入文件：\n1 mysql\u0026gt; pager cat \u0026gt; /tmp/log.txt You can also pass any options for the program that you want to use as your pager:\n1 mysql\u0026gt; pager less -n -i -S 在前面的示例中，请注意-S选项。您可能会发现它在浏览宽查询结果时非常有用。有时，很宽的结果集很难在屏幕上阅读。使用less的-S选项可以使结果集更易于阅读，因为你可以使用左箭头键和右箭头键水平滚动结果集。您还可以在less中交互式地使用-S来开关水平浏览模式。更多信息，请阅读less手册页面：\n1 man less -F和-X选项可与less一起使用，使其在输出适合一个屏幕时退出，这在无需滚动时非常方便：\n1 mysql\u0026gt; pager less -n -i -S -F -X You can specity very complex pager commands for handling query output:\n您可以指定非常复杂的pager commands来处理查询输出：\n1 2 mysql\u0026gt; pager cat | tee /dr1/tmp/res.txt \\ | tee /dr2/tmp/res2.txt | less -n -i -S 在本例中，该命令将把查询结果发送到挂载在 /dr1 和 /dr2 上的两个不同文件系统的两个不同目录中的两个文件，但仍使用 less 在屏幕上显示结果。\n您还可以将tee和pager功能结合起来。启用tee文件并将pager设置为less，就可以使用less程序浏览结果，并同时将所有内容添加到文件中。与pager命令一起使用的Unixtee和mysql内置tee命令的区别在于，即使没有Unixtee，内置tee也能工作。内置 tee 还会记录屏幕上打印的所有内容，而与 pager 一起使用的 Unix tee 则不会记录这么多内容。此外，tee文件日志记录可以在mysql中以交互方式打开或关闭。当你想将某些查询记录到文件中，而不是其他查询时，这一点非常有用。\nprompt命令用于重新配置默认的mysql\u0026gt;提示符。用于定义提示符的字符串可以包含以下特殊序列。\n选项 描述 \\C 当前连接的标识符 \\c 一个计数器，您每发出一条语句，计数器就递增一次 \\D 完整的当前日期 \\d 默认数据库 \\h 服务器主机 \\l 当前分隔符 \\m 当前时间的分钟数 \\n 换行符 \\O 以三个字母格式表示的当前月份（Jan, Feb, …） \\o 数字格式的当前月份 \\P am/pm \\p 当前 TCP/IP 端口或套接字文件 \\R 当前时间，24 小时军用时间（0-23）。 \\r 当前时间，标准 12 小时制时间 (1-12) \\S 分号 \\s 当前时间的秒数 \\T 如果当前会话位于事务块内，则打印星号 (*)（来自 MySQL 8.0.28） \\t 制表符 \\U 您的 user_name@host_name 完整账户名 \\u 您的用户名 \\v 服务器版本 \\w 用三个字母表示的当前星期（Mon, Tue, …） \\Y 当前年，四位数 \\y 当前年，两位数 \\_ 空格 \\ 空格（反斜杠后的空格） \\' 单引号 \\\u0026rdquo; 双引号 \\\\ 一个字面的反斜杠字符 \\x x，针对上面未列出的任何 \u0026ldquo;x\u0026rdquo; 您可以通过多种方式设置提示：\nUse an environment variable。可以将 MYSQL_PS1 环境变量设置为提示字符串。例如：\n1 export MYSQL_PS1=\u0026#34;(\\u@\\h) [\\d]\u0026gt; \u0026#34; Use a command-line option。你可以将命令行上的--prompt选项设置为 \u0026ldquo;mysql\u0026quot;。例如：\n1 2 $\u0026gt; mysql --prompt=\u0026#34;(\\u@\\h) [\\d]\u0026gt; \u0026#34; (user@host) [database]\u0026gt; Use an option file。你可以在任何 MySQL 选项文件的[mysql]组中设置prompt选项，例如*/etc/my.cnf或你主目录中的.my.cnf*文件。例如：\n1 2 [mysql] prompt=(\\\\u@\\\\h) [\\\\d]\u0026gt;\\\\_ 在本例中，请注意反斜线是加倍的。如果使用选项文件中的提示选项设置prompt，建议在使用特殊提示选项时将反斜线加倍。允许使用的提示选项集与选项文件中可识别的特殊转义序列集有一些重叠。（选项文件中的转义序列规则见\u0026ldquo;Using Option Files\u0026rdquo;）。如果使用单反斜线，重叠可能会造成问题。例如，\\s 会被解释为空格，而不是当前的秒值。下面的示例展示了如何在选项文件中定义提示符，以 hh:mm:ss\u0026gt; 格式包含当前时间：\n1 2 [mysql] prompt=\u0026#34;\\\\r:\\\\m:\\\\s\u0026gt; \u0026#34; Set the prompt interactively。可以使用 prompt（或 \\R）命令交互式更改提示符。例如\n1 2 3 4 5 6 mysql\u0026gt; prompt (\\u@\\h) [\\d]\u0026gt;\\_ PROMPT set to \u0026#39;(\\u@\\h) [\\d]\u0026gt;\\_\u0026#39; (user@host) [database]\u0026gt; (user@host) [database]\u0026gt; prompt Returning to default PROMPT of mysql\u0026gt; mysql\u0026gt; mysql 客户端日志 mysql 客户端可以为交互式执行的语句记录这些类型的日志：\n在 Unix 上，mysql 会将语句写入历史文件。默认情况下，该文件名为.mysql_history，位于你的主目录中。要指定不同的文件，请设置 MYSQL_HISTFILE环境变量的值。\n在所有平台上，如果给出 --syslog 选项，mysql 会将语句写入系统日志设施。在 Unix 上，这是 syslog; 在 Windows 上，这是 Windows 事件日志。记录信息的目的地取决于系统。在 Linux 上，目的地通常是 /var/log/messages 文件。\n以下讨论介绍了适用于所有记录类型的特征，并提供了每种记录类型的特定信息。\n如何记录日志\n控制历史文件\nsyslog 日志特征\n如何记录日志 对于每个已启用的日志记录目标，语句记录发生的情况如下：\n语句只有在交互执行时才会被记录。例如，从文件或管道读取语句时，语句是非交互式的。也可以使用 --batch 或 --execute 选项来抑制语句记录。\n如果语句与 \u0026ldquo;ignore\u0026rdquo; 列表中的任何模式匹配，就会被忽略，也不会被记录。稍后将对该列表进行说明。\nmysql 会单独记录每一行未忽略、非空的语句。\n如果一条未忽略的语句跨越多行（不包括终止分隔符），mysql 会将这些行连接起来形成完整的语句，将换行符映射为空格，并记录结果和分隔符。\n因此，跨越多行的输入语句可能会被记录两次。请看下面的输入\n1 2 3 4 5 mysql\u0026gt; SELECT -\u0026gt; \u0026#39;Today is\u0026#39; -\u0026gt; , -\u0026gt; CURDATE() -\u0026gt; ; 在这种情况下，mysql 会在读取时记录 \u0026ldquo;SELECT\u0026rdquo;、\u0026quot;\u0026lsquo;Today is\u0026rsquo;\u0026quot;、\u0026rdquo;,\u0026quot;、\u0026ldquo;CURDATE() \u0026ldquo;和\u0026rdquo;;\u0026ldquo;行。在将 SELECT\\n'Today is'\\n,\\nCURDATE() 映射为 SELECT 'Today is' , CURDATE() 后，它还会记录完整的语句，并加上分隔符。因此，这些行将出现在日志输出中：\n1 2 3 4 5 6 SELECT \u0026#39;Today is\u0026#39; , CURDATE() ; SELECT \u0026#39;Today is\u0026#39; , CURDATE(); 为了记录日志，mysql 会忽略与 \u0026ldquo;ignore\u0026rdquo; 列表中任何模式匹配的语句。默认情况下，模式列表为 \u0026quot;*IDENTIFIED*:*PASSWORD*\u0026quot;，以忽略涉及密码的语句。模式匹配不区分大小写。在模式中，有两个字符是特殊字符：\n? 匹配任何单个字符。\n* 匹配任何由 0 个或多个字符组成的序列。\n要指定其他模式，请使用 --histignore 选项或设置 MYSQL_HISTIGNORE 环境变量。（如果同时指定了这两个选项，则以选项值为准。）值应该是一个或多个以冒号分隔的模式列表，这些模式会被追加到默认模式列表中。\n命令行中指定的模式可能需要加引号或转义，以防止命令解释器对其进行特殊处理。例如，要禁止记录 UPDATE 和 DELETE 语句以及引用密码的语句，可以这样调用 mysql：\n1 mysql --histignore=\u0026#34;*UPDATE*:*DELETE*\u0026#34; 控制历史文件 应使用限制访问模式保护 .mysql_history 文件，因为敏感信息（如包含密码的 SQL 语句文本）可能会被写入该文件。请参阅\u0026ldquo;End-User Guidelines for Password Security\u0026rdquo;。使用up-arrow键调用历史记录时，可从mysql客户端访问文件中的语句。请参阅 Disabling Interactive History。\n如果不想维护历史文件，首先删除存在的 .mysql_history。然后使用以下任一技术防止再次创建该文件：\n将 MYSQL_HISTFILE 环境变量设置为 /dev/null。要使该设置在每次登录时生效，请将其放在 shell 的某个启动文件中。\n将 .mysql_history 创建为指向 /dev/null的符号链接；只需创建一次：\n1 ln -s /dev/null $HOME/.mysql_history syslog 日志特征 如果给定了 --syslog 选项，mysql 会将交互式语句写入系统日志设施。消息日志具有以下特点。\n日志记录发生在 \u0026ldquo;information\u0026rdquo; 级别。这相当于 Unix/Linux syslog 功能中 syslog 的 LOG_INFO 优先级，以及 Windows 事件日志的 EVENTLOG_INFORMATION_TYPE 优先级。有关日志功能的配置，请查阅系统文档。\n信息大小限制为 1024 字节。\n信息由标识符 MysqlClient 和这些值组成：\nSYSTEM_USER\n操作系统用户名（登录名），如果用户未知，则使用 -- 表示。\nMYSQL_USER\nMySQL 用户名（使用 --user 选项指定），如果用户未知，则使用 --。\nCONNECTION_ID:\n客户端连接标识符。它与会话中的 CONNECTION_ID() 函数值相同。\nDB_SERVER\n服务器主机，如果主机未知，则为--。\nDB\n默认数据库，如果没有选择数据库，则使用 --。\nQUERY\n记录的声明文本。\n下面是使用 --syslog 在 Linux 上生成的输出示例。为便于阅读，该输出已格式化；每条记录的信息实际上只占一行。\n1 2 3 4 5 6 Mar 7 12:39:25 myhost MysqlClient[20824]: SYSTEM_USER:\u0026#39;oscar\u0026#39;, MYSQL_USER:\u0026#39;my_oscar\u0026#39;, CONNECTION_ID:23, DB_SERVER:\u0026#39;127.0.0.1\u0026#39;, DB:\u0026#39;--\u0026#39;, QUERY:\u0026#39;USE test;\u0026#39; Mar 7 12:39:28 myhost MysqlClient[20824]: SYSTEM_USER:\u0026#39;oscar\u0026#39;, MYSQL_USER:\u0026#39;my_oscar\u0026#39;, CONNECTION_ID:23, DB_SERVER:\u0026#39;127.0.0.1\u0026#39;, DB:\u0026#39;test\u0026#39;, QUERY:\u0026#39;SHOW TABLES;\u0026#39; mysql 客户端服务器端帮助 1 mysql\u0026gt; help search_string 如果为 help 命令提供一个参数，mysql会将其作为搜索字符串，从《MySQL参考手册》的内容中访问服务器端帮助。该命令的正确操作要求mysql数据库中的帮助表用帮助主题信息初始化（参见\u0026ldquo;Server-Side Help Support\u0026rdquo;）。\n如果搜索字符串没有匹配项，则搜索失败：\n1 2 3 4 mysql\u0026gt; help me Nothing found Please try to run \u0026#39;help contents\u0026#39; for a list of all accessible topics 使用 help contents 查看帮助类别列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 mysql\u0026gt; help contents You asked for help about help category: \u0026#34;Contents\u0026#34; For more information, type \u0026#39;help \u0026lt;item\u0026gt;\u0026#39;, where \u0026lt;item\u0026gt; is one of the following categories: Account Management Administration Data Definition Data Manipulation Data Types Functions Functions and Modifiers for Use with GROUP BY Geographic Features Language Structure Plugins Storage Engines Stored Routines Table Maintenance Transactions Triggers 如果搜索字符串匹配多个项目，mysql 会显示匹配主题的列表：\n1 2 3 4 5 6 7 8 mysql\u0026gt; help logs Many help items for your request exist. To make a more specific request, please type \u0026#39;help \u0026lt;item\u0026gt;\u0026#39;, where \u0026lt;item\u0026gt; is one of the following topics: SHOW SHOW BINARY LOGS SHOW ENGINE SHOW LOGS 使用主题作为搜索字符串，可查看该主题的帮助条目：\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; help show binary logs Name: \u0026#39;SHOW BINARY LOGS\u0026#39; Description: Syntax: SHOW BINARY LOGS SHOW MASTER LOGS Lists the binary log files on the server. This statement is used as part of the procedure described in [purge-binary-logs], that shows how to determine which logs can be purged. 1 2 3 4 5 6 7 mysql\u0026gt; SHOW BINARY LOGS; +---------------+-----------+-----------+ | Log_name | File_size | Encrypted | +---------------+-----------+-----------+ | binlog.000015 | 724935 | Yes | | binlog.000016 | 733481 | Yes | +---------------+-----------+-----------+ 搜索字符串可以包含通配符 % 和 _。这些字符的含义与使用 LIKE 操作符执行的模式匹配操作相同。例如，HELP rep% 返回以rep开头的主题列表：\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; HELP rep% Many help items for your request exist. To make a more specific request, please type \u0026#39;help \u0026lt;item\u0026gt;\u0026#39;, where \u0026lt;item\u0026gt; is one of the following topics: REPAIR TABLE REPEAT FUNCTION REPEAT LOOP REPLACE REPLACE FUNCTION 从文本文件执行 SQL 语句 mysql 客户端通常是交互式使用的，就像这样：\n1 mysql db_name 不过，也可以将 SQL 语句放在一个文件中，然后告诉 mysql 从该文件读取输入。为此，请创建一个文本文件 text_file，其中包含要执行的语句。然后调用 mysql，如下所示：\n1 mysql db_name \u0026lt; text_file 如果将 USE db_name 语句作为文件中的第一条语句，则无需在命令行中指定数据库名称：\n1 mysql \u0026lt; text_file 如果已在运行 mysql，则可以使用 source 命令或 \\. 命令执行 SQL 脚本文件：\n1 2 mysql\u0026gt; source file_name mysql\u0026gt; \\. file_name 有时，您可能希望脚本向用户显示进度信息。为此，您可以插入如下语句\n1 SELECT \u0026#39;\u0026lt;info_to_display\u0026gt;\u0026#39; AS \u0026#39; \u0026#39;; 所示语句输出\u0026lt;info_to_display\u0026gt;。\n你也可以在调用 mysql 时使用 --verbose 选项，这将导致在显示每条语句产生的结果之前显示其结果。\nmysql 忽略输入文件开头的 Unicode 字节序号 (BOM) 字符。以前，它会读取这些字符并将其发送到服务器，从而导致语法错误。BOM 字符的存在不会导致 mysql 更改默认字符集。要做到这一点，请在调用 mysql 时加入一个选项，如 --default-character-set=utf8mb4。\n有关批处理模式的更多信息，请参阅章节\u0026ldquo;Using mysql in Batch Mode\u0026rdquo;。\nmysql 客户端提示 本节介绍更有效使用 mysql 的技巧以及 mysql 的操作行为。\n输入行编辑\n禁用交互式历史记录\nWindows 支持 Unicode\n垂直显示查询结果\n使用安全更新模式 (\u0026ndash;safe-updates)\n禁用 mysql 自动重新连接功能\nmysql 客户端解析器与服务器解析器对比\n输入行编辑 mysql支持输入行编辑，这使你可以就地修改当前输入行或调用以前的输入行。例如，left-arrow 和 right-arrow 键可在当前输入行内水平移动，up-arrow 和 down-arrow 键可在以前输入的行中上下移动。Backspace 删除光标前的字符，输入新字符时则在光标位置输入。要输入一行，按 Enter。\n在 Windows 上，编辑键序与控制台窗口中的命令编辑所支持的键序相同。在 Unix 上，键序取决于用于构建 mysql 的输入库（例如，libedit 或 readline 库）。\nlibedit 或 readline 库的文档可在线获取。要更改特定输入库允许的键序列集，请在库启动文件中定义键绑定。这是一个位于你的主目录下的文件：libedit 为 .editrc，readline 为 .inputrc。\n例如，在 libedit 中，Control+W 删除当前光标位置前的所有内容，Control+U 删除整行。在 readline 中，Control+W 删除光标前的单词，Control+U 删除当前光标位置前的所有内容。如果mysql是使用libedit创建的，那么如果用户喜欢这两个键的readline行为，可以在.editrc文件中加入以下几行（必要时创建文件）：\n1 2 bind \u0026#34;^W\u0026#34; ed-delete-prev-word bind \u0026#34;^U\u0026#34; vi-kill-line-prev 要查看当前的按键绑定集，可暂时在 .editrc. mysql启动时显示绑定。\n禁用交互式历史记录 up-arrow可以调用当前和以前会话中的输入行。在共享控制台的情况下，这种行为可能不合适。根据主机平台的不同，mysql 支持部分或完全禁用交互式历史记录。\n在 Windows 中，历史记录存储在内存中。Alt+F7会删除当前历史记录缓冲区内存中存储的所有输入行。它还会删除用 F7显示并用 F9调用（按编号）的输入行前面的顺序编号列表。按 Alt+F7 键后输入的新输入行将重新填充当前历史记录缓冲区。如果在启动 mysql 时使用了 --syslog 选项，则清除缓冲区并不会阻止向 Windows 事件查看器记录日志。关闭控制台窗口也会清除当前的历史记录缓冲区。\n要在 Unix 上禁用交互式历史记录，首先要删除 .mysql_history 文件（如果存在）（否则会调用以前的条目）。然后使用 --histignore=\u0026quot;*\u0026quot;选项启动mysql，以忽略所有新输入行。要重新启用调用（和记录）行为，请在重启 mysql 时不带该选项。\n如果阻止创建.mysql_history文件（请查阅Controlling the History File），并使用--histignore=\u0026quot;*\u0026quot;来启动mysql客户端，交互式历史记录调用功能就会被完全禁用。另外，如果省略--histignore选项，则可以调用当前会话中输入的行。\nWindows 支持 Unicode Windows 提供了基于 UTF-16LE 的 API，用于从控制台读取数据和向控制台写入数据；Windows 的 mysql 客户端可以使用这些 API。Windows 安装程序会在 MySQL 菜单中创建一个名为 \u0026ldquo;MySQL command line client - Unicode\u0026rdquo; 的项目。此项目调用mysql客户端，其属性设置为使用Unicode通过控制台与MySQL服务器通信。\n要手动利用这一支持，请在使用兼容 Unicode 字体的控制台中运行 mysql，并将默认字符集设置为与服务器通信时支持的 Unicode 字符集：\n打开控制台窗口。\n进入控制台窗口属性，选择字体选项卡，选择 Lucida Console 或其他兼容的 Unicode 字体。这是必要的，因为控制台窗口启动时默认使用的 DOS 栅格字体不适合 Unicode。\n执行 mysql.exe，并设置 --default-character-set=utf8mb4 （或 utf8mb3）选项。该选项是必要的，因为 utf16le 是不能用作客户端字符集的字符集之一。请参阅 Impermissible Client Character Sets。\n作出这些更改后，mysql 将使用 Windows API，使用 UTF-16LE 与控制台通信，并使用 UTF-8 与服务器通信。（前面提到的菜单项可以设置字体和字符集）。\n为了避免每次运行mysql时都要进行这些步骤，可以创建一个调用mysql.exe的快捷方式。快捷方式应将控制台字体设置为 Lucida Console 或其他兼容的 Unicode 字体，并将 --default-character-set=utf8mb4（或 utf8mb3）选项传递给 mysql.exe。\n或者，创建一个只设置控制台字体的快捷方式，并在my.ini文件的[mysql]组中设置字符集：\n1 2 [mysql] default-character-set=utf8mb4 # or utf8mb3 垂直显示查询结果 有些查询结果如果以垂直方式显示，而不是通常的水平表格格式，会更易读。可以用 \\G 代替分号来结束查询，从而垂直显示查询结果。例如，包含换行符的较长文本值通常在垂直输出时更容易阅读：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 mysql\u0026gt; SELECT * FROM mails WHERE LENGTH(txt) \u0026lt; 300 LIMIT 300,1\\G *************************** 1. row *************************** msg_nro: 3068 date: 2000-03-01 23:29:50 time_zone: +0200 mail_from: Jones reply: jones@example.com mail_to: \u0026#34;John Smith\u0026#34; \u0026lt;smith@example.com\u0026gt; sbj: UTF-8 txt: \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34;John\u0026#34; == John Smith writes: John\u0026gt; Hi. I think this is a good idea. Is anyone familiar John\u0026gt; with UTF-8 or Unicode? Otherwise, I\u0026#39;ll put this on my John\u0026gt; TODO list and see what happens. Yes, please do that. Regards, Jones file: inbox-jani-1 hash: 190402944 1 row in set (0.09 sec) 使用安全更新模式 (\u0026ndash;safe-updates) 对于初学者来说，一个有用的启动选项是 -safe-updates（或 --i-am-a-dummy，效果相同）。安全更新模式对以下情况很有帮助：你可能已经发出了一条 UPDATE 或 DELETE 语句，但却忘记了指示要修改哪些行的 WHERE 子句。通常，此类语句会更新或删除表中的所有行。有了 -safe-updates，你就只能通过指定标识行的键值或 LIMIT 子句或两者来修改行。这有助于防止意外发生。安全更新模式还限制会产生（或估计会产生）非常大结果集的 SELECT 语句。\n--safe-updates选项会导致mysql在连接到MySQL服务器时执行以下语句，以设置sql_safe_updates、sql_select_limit和max_join_size系统变量的会话值：\n1 SET sql_safe_updates=1, sql_select_limit=1000, max_join_size=1000000; SET语句对语句处理的影响如下：\n启用 sql_safe_updates 后，如果 UPDATE 和 DELETE 语句没有在 WHERE 子句中指定键约束，或没有提供 LIMIT 子句，或两者都没有，就会产生错误。例如：\n1 2 3 UPDATE tbl_name SET not_key_column=val WHERE key_column=val; UPDATE tbl_name SET not_key_column=val LIMIT 1; 将 sql_select_limit 设置为 1,000 会导致服务器将所有 SELECT 结果集限制为 1,000 行，除非语句包含一个 LIMIT 子句。\n将 max_join_size 设置为 1,000,000 会导致多表 SELECT 语句在服务器估计必须检查超过 1,000,000 行组合时产生错误。\n要指定不同于 1,000 和 1,000,000 的结果集限制，可以在调用 mysql 时使用 --select-limit 和 -ax-join-size 选项来覆盖默认值：\n1 mysql --safe-updates --select-limit=500 --max-join-size=10000 如果优化器决定不使用键列上的索引，那么即使在 WHERE 子句中指定了键，UPDATE 和 DELETE 语句也有可能在安全更新模式下产生错误：\n如果内存使用量超过 range_optimizer_max_mem_size 系统变量允许的范围，则无法使用索引上的范围访问。这时，优化器会退回到表扫描。请参阅 Limiting Memory Use for Range Optimization。\n如果键比较需要类型转换，则可能无法使用索引（请参阅\u0026ldquo;How MySQL Uses Indexes\u0026rdquo;）。假设使用 WHERE c1 = 2222 将索引字符串列 c1 与数值进行比较。对于此类比较，字符串值将转换为数字，操作数将以数字形式进行比较（请参阅\u0026ldquo;Type Conversion in Expression Evaluation\u0026rdquo;），从而无法使用索引。如果启用了安全更新模式，则会出现错误。\n从 MySQL 8.0.13 起，安全更新模式也包含这些行为：\n带有 UPDATE 和 DELETE 语句的 EXPLAIN 不会产生安全更新错误。这样就可以使用 EXPLAIN 加上 SHOW WARNINGS 来查看不使用索引的原因，这在某些情况下很有帮助，例如当发生 range_optimizer_max_mem_size 违规或类型转换时，即使在 WHERE 子句中指定了键列，优化器也不会使用索引。\n当发生安全更新错误时，错误消息会包含产生的第一个诊断，以提供有关失败原因的信息。例如，消息可能显示超出了 range_optimizer_max_mem_size 值或发生了类型转换，这两种情况都可能导致无法使用索引。\n对于多表删除和更新，只有当任何目标表使用表扫描时，才会在启用安全更新后产生错误。\n禁用 mysql 自动重新连接功能 如果mysql客户端在发送语句时与服务器失去连接，它会立即自动尝试重新连接服务器并再次发送语句。不过，即使mysql重新连接成功，第一次连接也已结束，所有以前的会话对象和设置都会丢失：临时表、自动提交模式、用户定义变量和会话变量。此外，任何当前事务都会回滚。这种行为可能会给您带来危险，例如在下面的示例中，服务器在您不知道的情况下在第一条和第二条语句之间被关闭并重新启动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 mysql\u0026gt; SET @a=1; Query OK, 0 rows affected (0.05 sec) mysql\u0026gt; INSERT INTO t VALUES(@a); ERROR 2006: MySQL server has gone away No connection. Trying to reconnect... Connection id: 1 Current database: test Query OK, 1 row affected (1.30 sec) mysql\u0026gt; SELECT * FROM t; +------+ | a | +------+ | NULL | +------+ 1 row in set (0.05 sec) @a 用户变量随连接丢失，重新连接后未定义。如果需要在连接丢失时让mysql以错误方式终止，可以使用--skip-reconnect选项启动mysql客户端。\n有关自动重新连接及其在发生重新连接时对状态信息影响的更多信息，请参阅 Automatic Reconnection Control。\nmysql 客户端解析器与服务器解析器对比 mysql客户端在客户端使用的解析器与mysqld服务器在服务器端使用的完整解析器并不相同。这可能会导致某些构造的处理方式不同。例如：\n如果启用了 ANSI_QUOTES SQL 模式，服务器解析器会将以\u0026quot;字符分隔的字符串视为标识符，而不是纯字符串。\nmysql 客户端解析器不考虑 ANSI_QUOTES SQL 模式。无论是否启用了 ANSI_QUOTES，它对以\u0026rdquo;、\u0026lsquo;和`字符分隔的字符串的处理方式都是一样的。\nWithin /*! \u0026hellip; */ 和 /*+ \u0026hellip; */注释中，mysql客户端解析器解释简短的mysql命令。服务器解析器不会解释它们，因为这些命令在服务器端没有任何意义。\n如果希望mysql不解释注释中的短格式命令，部分变通方法是使用 --binary-mode 选项，该选项会导致所有mysql命令被禁用，但非交互模式下的 \\C 和 \\d 除外（对于通过管道输入到mysql或使用 source 命令加载的输入）。\n","date":"2023-11-22T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/mysql-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF/","title":"MySQL 命令行客户端"},{"content":"获取当前操作系统信息（c#） System.Runtime.InteropServices.OSPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // Licensed to the .NET Foundation under one or more agreements. // The .NET Foundation licenses this file to you under the MIT license. using System.Diagnostics.CodeAnalysis; namespace System.Runtime.InteropServices { public readonly struct OSPlatform : IEquatable\u0026lt;OSPlatform\u0026gt; { public static OSPlatform FreeBSD { get; } = new OSPlatform(\u0026#34;FREEBSD\u0026#34;); public static OSPlatform Linux { get; } = new OSPlatform(\u0026#34;LINUX\u0026#34;); public static OSPlatform OSX { get; } = new OSPlatform(\u0026#34;OSX\u0026#34;); public static OSPlatform Windows { get; } = new OSPlatform(\u0026#34;WINDOWS\u0026#34;); internal string Name { get; } private OSPlatform(string osPlatform) { if (osPlatform == null) throw new ArgumentNullException(nameof(osPlatform)); if (osPlatform.Length == 0) throw new ArgumentException(SR.Argument_EmptyValue, nameof(osPlatform)); Name = osPlatform; } /// \u0026lt;summary\u0026gt; /// Creates a new OSPlatform instance. /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt;If you plan to call this method frequently, please consider caching its result.\u0026lt;/remarks\u0026gt; public static OSPlatform Create(string osPlatform) { return new OSPlatform(osPlatform); } public bool Equals(OSPlatform other) { return Equals(other.Name); } internal bool Equals(string? other) { return string.Equals(Name, other, StringComparison.OrdinalIgnoreCase); } public override bool Equals([NotNullWhen(true)] object? obj) { return obj is OSPlatform osPlatform \u0026amp;\u0026amp; Equals(osPlatform); } public override int GetHashCode() { return Name == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode(Name); } public override string ToString() { return Name ?? string.Empty; } public static bool operator ==(OSPlatform left, OSPlatform right) { return left.Equals(right); } public static bool operator !=(OSPlatform left, OSPlatform right) { return !(left == right); } } } System.Runtime.InteropServices.Architecture 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #region Assembly System.Runtime.InteropServices.RuntimeInformation, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a // C:\\Program Files\\dotnet\\packs\\Microsoft.NETCore.App.Ref\\6.0.25\\ref\\net6.0\\System.Runtime.InteropServices.RuntimeInformation.dll #endregion namespace System.Runtime.InteropServices { // // Summary: // Indicates the processor architecture. public enum Architecture { // // Summary: // An Intel-based 32-bit processor architecture. X86 = 0, // // Summary: // An Intel-based 64-bit processor architecture. X64 = 1, // // Summary: // A 32-bit ARM processor architecture. Arm = 2, // // Summary: // A 64-bit ARM processor architecture. Arm64 = 3, // // Summary: // The WebAssembly platform. Wasm = 4, // // Summary: // The S390x platform architecture. S390x = 5 } } System.Runtime.InteropServices.RuntimeInformation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // Licensed to the .NET Foundation under one or more agreements. // The .NET Foundation licenses this file to you under the MIT license. using System.Reflection; namespace System.Runtime.InteropServices { public static partial class RuntimeInformation { private const string FrameworkName = \u0026#34;.NET\u0026#34;; private static string? s_frameworkDescription; private static string? s_runtimeIdentifier; public static string FrameworkDescription { get { if (s_frameworkDescription == null) { ReadOnlySpan\u0026lt;char\u0026gt; versionString = typeof(object).Assembly.GetCustomAttribute\u0026lt;AssemblyInformationalVersionAttribute\u0026gt;()?.InformationalVersion; // Strip the git hash if there is one int plusIndex = versionString.IndexOf(\u0026#39;+\u0026#39;); if (plusIndex != -1) { versionString = versionString.Slice(0, plusIndex); } s_frameworkDescription = !versionString.Trim().IsEmpty ? $\u0026#34;{FrameworkName} {versionString}\u0026#34; : FrameworkName; } return s_frameworkDescription; } } /// \u0026lt;summary\u0026gt; /// Returns an opaque string that identifies the platform on which an app is running. /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// The property returns a string that identifies the operating system, typically including version, /// and processor architecture of the currently executing process. /// Since this string is opaque, it is not recommended to parse the string into its constituent parts. /// /// For more information, see https://docs.microsoft.com/dotnet/core/rid-catalog. /// \u0026lt;/remarks\u0026gt; public static string RuntimeIdentifier =\u0026gt; s_runtimeIdentifier ??= AppContext.GetData(\u0026#34;RUNTIME_IDENTIFIER\u0026#34;) as string ?? \u0026#34;unknown\u0026#34;; /// \u0026lt;summary\u0026gt; /// Indicates whether the current application is running on the specified platform. /// \u0026lt;/summary\u0026gt; public static bool IsOSPlatform(OSPlatform osPlatform) =\u0026gt; OperatingSystem.IsOSPlatform(osPlatform.Name); } } Demo 1 2 3 4 5 6 7 8 if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) { // Windows } else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) \u0026amp;\u0026amp; RuntimeInformation.ProcessArchitecture == Architecture.X64) { // linux64 } ","date":"2023-11-20T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AFc/","title":"获取当前操作系统信息（c#）"},{"content":"MySQL 8 远程访问 进入MySQL安装目录下的bin目录（如果配置过环境变量就直接到第二步） 在地址栏输入cmd打开命令行窗口（如果配置过环境变量直接Win+R输入cmd回车即可） 输入命令并回车 1 mysql -uroot -p 输入命令并回车，其中password是你msyql数据库的密码 1 GRANT ALL PRIVILEGES ON *.* TO \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; 输入命令并回车 1 FLUSH PRIVILEGES; 关闭窗口，完成 ","date":"2023-11-16T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/mysql-8-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"MySQL 8 远程访问"},{"content":"在Windows上安装PostgreSQL 16.1 前往官网下载PostgreSQL安装包 下载PostgreSQL安装包。\nhttps://www.enterprisedb.com/downloads/postgres-postgresql-downloads.\n打开安装包 点击Next 修改安装目录然后点击Next 保持默认选项，点击Next 设置数据目录，点击Next 设置密码，点击Next 设置数据库端口号（默认5432），点击Next 设置语言，点击Next 后面一直点Next即可 等待安装完毕 取消勾选Stack Builder，点击Finish 至此，PostgreSQL安装完毕 PostgresSQL安装携带了pgAdmin软件，可以用来管理PostgreSQL数据库，打开pgAdmin 点击左上角的Server 输入设置的密码，点击OK 如下界面即表示安装成功 也可以使用第三方数据库连接器进行连接测试，PostgreSQL的用户名为postgres ","date":"2023-11-15T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%85postgresql-16.1/","title":"在Windows上安装PostgreSQL 16.1"},{"content":"Northwind Database Categories (类别表) ColumnName Description CategoryID 类别ID CategoryName 类别名 Description 类别说明 Picture 产品样本 CustomerCustomerDemo (客户类型表1) ColumnName Description CustomerID 客户ID CustomerTypeID 客户类型ID CustomerDemographics (客户类型表2) ColumnName Description CustomerTypeID 客户类型ID CustomerDesc 客户描述 Customers (客户表) ColumnName Description CustomerID 客户ID CompanyName 公司名称 ContactName 客户姓名 ContactTitle 客户头衔 Address 联系地址 City 所在城市 Region 所在地区 PostalCode 邮编 Country 国家 Phone 电话 Fax 传真 Employees (员工表) ColumnName Description EmployeeID 员工ID LastName + FirstName 员工姓名 Title 头衔 TitleOfCourtesy 职称 BirthDate 出生日期 HireDate 雇用日期 Address 家庭地址 City 所在城市 Region 所在地区 PostalCode 邮编 Country 国家 HomePhone 家庭电话 Extension 分机 Photo 照片 notes 笔记 ReportsTo 上级 PhotoPath 照片路径 EmployeeTerritories (员工部门表) ColumnName Description EmployeeID 员工编号 TerritoryID 部门代号 Order Details (订单明细表) ColumnName Description OrderID 订单编号 ProductID 产品编号 UnitPrice 单价 Quantity 订购数量 Discount 折扣 Orders (订单表) ColumnName Description OrderID 订单编号 CustomerID 客户编号 EmployeeID 员工编号 OrderDate 订购日期 RequiredDate 预计到达日期 ShippedDate 发货日期 ShipVia 运货商 Freight 运费 ShipName 货主姓名 ShipAddress 货主地址 ShipCity 货主所在城市 ShipRegion 货主所在地区 ShipPostalCode 货主邮编 ShipCountry 货主所在国家 Products (产品表) ColumnName Description ProductID 产品ID ProductName 产品名称 SupplierID 供应商ID CategoryID 类型ID QuantityPerUnit 数量 UnitPrice 单价 UnitsInStock 库存数量 UnitsOnOrder 订购量 ReorderLevel 再次订购量 Discontinued 中止 Region (地区表) ColumnName Description RegionID 地区ID RegionDescription 地区描述 Shippers (运货商表) ColumnName Description ShipperID 运货商ID CompanyName 公司名称 Phone 联系电话 Suppliers (供应商表) ColumnName Description ShipperID 供应商ID CompanyName 供应商姓名 Phone 联系电话 Territories (地域表) ColumnName Description TerritoryID 地域编号 TerritoryDescription 地域描述 RegionID 地区编号 ","date":"2023-07-06T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/northwind-database/","title":"Northwind Database"},{"content":"使用WSL2技术在Windows子系统上安装Ubuntu 安装WSL2 参考资料：Manual installation steps for older versions of WSL\n为 Linux 启用 Windows 子系统 以管理员身份打开 PowerShell （开始菜单 \u0026gt; PowerShell \u0026gt; 右键单击 \u0026gt; 以管理员身份运行）并输入以下命令：\n1 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 启动虚拟机功能 以管理员身份打开 PowerShell 并运行：\n1 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启计算机 下载 Linux 内核更新包并安装 下载地址1（Microsoft官网下载）：Linux 内核更新包\n下载地址2（csdn下载）：Linux 内核更新包\n运行下载的更新包。（双击运行 - 系统将提示您提升权限，选择“是”以批准此安装。）\n将 WSL2 设置为默认版本 打开 PowerShell 并运行以下命令，将 WSL 2 设置为安装新 Linux 发行版时的默认版本：\n1 wsl --set-default-version 2 安装Ubuntu并安装docker及docker-compose 安装Ubuntu参考资料：https://docs.microsoft.com/en-us/windows/wsl/install-manual\n安装docker参考资料：https://www.runoob.com/docker/ubuntu-docker-install.html\n安装docker-compose参考资料：https://linuxhostsupport.com/blog/how-to-install-and-configure-docker-compose-on-ubuntu-20-04/\n打开Microsoft Store并选择Ubuntu版本进行下载 等待自动安装成功 启动Ubuntu，等待自动安装 设置用户名及密码后进入Ubuntu系统中 Ubuntu Docker安装 使用国内 daocloud 一键安装命令：\n安装命令如下：\n1 sudo curl -sSL https://get.daocloud.io/docker | sh 等待安装成功\n启动docker服务命令\n1 sudo service docker start 查看是否安装成功命令\n1 sudo docker ps -a 显示如下即安装Ubuntu Docker成功\n安装docker-compose 更新apt-get命令：\n1 sudo apt-get update -y 安装docker-compose命令：\n1 sudo apt-get install docker-compose 中途输入y回车即可\n安装完成！\n","date":"2022-09-16T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E4%BD%BF%E7%94%A8wsl2%E6%8A%80%E6%9C%AF%E5%9C%A8windows%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu/","title":"使用WSL2技术在Windows子系统上安装Ubuntu"},{"content":"REST API Design Rulebook URI Format(RFC 3986) 1 URL = scheme \u0026#34;://\u0026#34; authority \u0026#34;/\u0026#34; path [ \u0026#34;?\u0026#34; query ] [ \u0026#34;#\u0026#34; fragment ] URI Rules 必须使用正斜杠分隔符（/）来表示层次结构关系\n1 http://api.canvas.restapi.org/shapes/polygons/quadrilaterals/squares URI最后不应该有斜杠（/）\n1 2 Incorrect:\thttp://api.canvas.restapi.org/shapes/ Correct:\thttp://api.canvas.restapi.org/shapes 应该使用连字符（-）来提高URI可读性\n1 http://api.example.restapi.org/blogs/mark-masse/entries/this-is-my-first-post URI中不应该使用下划线（_）\n在URI路径中，应该首选小写字母\n1 2 3 1: http://api.example.restapi.org/my-folder/my-doc\tCorrect 2: HTTP://API.EXAMPLE.RESTAPI.ORG/my-fplder/my-doc\tCorrect 3: httpL//api.example.restapi.org/My-Folder/my-doc\tIncorrect 文件扩展名不应该包含在URI中\n1 2 Incorrect:\thttp://api.college.restapi.org/students/3248234/transcripts/2005/fall.json Correct:\thttp://api.college.restapi.org/students/3248234/transcripts/2005/fall 对于API，应该使用一致的子域名，API的完整域名应该添加一个名为api的子域\n1 2 Incorrect:\thttp://soccer.restapi.org Correct:\thttp://api.soccer.restapi.org 对于客户端开发人员，应该使用一致的子域名\n1 httpL//developer.soccer.restapi.org 表示文档资源的URI应该用单数名词\n1 http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players/claudio 标识一个集合的URI应该用一个复数名词\n1 http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players 标识资源存储的URI应该用复数名词\n1 http://api.music.restapi.org/artists/mikemassedotcom/playlists 动词或动词短语应用于控制器名称\n1 2 3 4 http://api.college.restapi.org/students/morgan/register http://api.example.restapi.org/lists/4324/dedupe http://api.ognom.restapi.org/dbs/reindex http://api.build.restapi.org/qa/nightly/runTestSuite 变量路径段可以用于基于标识的值进行替换\n1 2 http://api.soccer.restapi.org/leagues/{leagueId}/teams/{teamsId}/players/{playerId} http://api.soccer.restapi.org/leagues/seattle/teams/trebuchet/players/21 CRUD函数名称不应该使用在URI中\n1 2 3 4 5 6 7 Incorrect: GET /deleteUser?id=1234 GET /deleteUsers/1234 DELETE /deleteUser/1234 POST /users/1234/delete Correct: DELETE /users/1234 一个URI的查询组件可以用于过滤集合或存储\n1 2 GET /users GET /users?role=admin URI的查询组件应该用于分页收集或存储结果\n1 GET /users?pageSize=25\u0026amp;\u0026amp;pageStartIndex=50 Request Methods(RFC2616) 1 Request-Line = Method SP Request-URI SP HTTP-Version CRLF GET is to retrieve a representation of a resource\u0026rsquo;s state.\nHEAD is used to retrieve the metadata associated with the resource\u0026rsquo;s state.\nPUT should be used to add a new resource to a store or update a resource.\nDELETE removes a resource from its parent.\nPOST should be used to create a new resource within a collection and execute controllers.\nRequest Method Rules GET和POST不能用于其他请求方法\n必须使用GET来检索资源的表达形式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ curl -v http://api.example.restapi.org/greeting \u0026gt; GET /greeting HTTP/1.1 \u0026gt; User-Agent: curl/7.20.1 \u0026gt; Host: api.example.restapi.org \u0026gt; Accept: *.* \u0026lt; HTTP/1.1 200 OK \u0026lt; Date: Sat, 20 Aug 2011 16:02:40 GMT \u0026lt; Server: Apache \u0026lt; Expires: Sat, 20 Aug 2011 16:06:40 GMT \u0026lt; Cache-Control: max-age=60, must-revalidate \u0026lt; ETag: text/html:hello world \u0026lt; Last-Modified: Sat, 20 Aug 2011 16:02:17 GMT \u0026lt; Vary: Accept-Encoding \u0026lt; Content-Type: text/html \u0026lt;!doctype html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;title\u0026gt;Greeting\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;div id=\u0026#34;greeting\u0026#34;\u0026gt;Hello World!\u0026lt;/div\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; HEAD应用于检索响应报头\n1 2 3 4 5 6 7 8 9 10 11 $curl --head http://api.example.restapi.org/greeting HTTP/1.1 200 OK Date: Sat, 20 Aug 2011 16:02:40 GMT Server: Apache Expires: Sat, 20 Aug 2011 16:03:40 GMT Cache-Control: max-age=60, must-revalidate ETag: text/html:hello world Last-Modified: Sat, 20 Aug 2011 16:02:17 GMT Vary: Accept-Encoding Context-Type: text/html 必须使用PUT来插入和更新所存储的资源\n1 PUT /accounts/4ef2d5d0-cb7e-11e0-9572-0800200c9a66/buckets/objects/4321 必须使用PUT来更新可变的资源\n必须使用POST在一个集合中创建一个新的资源\n1 2 3 POST /leagues/seattle/teams/trebuchet/players # Note the request message may contain a representation that suggests the initial state of the player to be created. 必须使用POST来执行控制器\n1 POST /alerts/245743/resend 必须使用DELETE来删除资源\n1 DELETE /accounts/4ef2d5d0-cb7e-11e0-9572-080020c9a66/buckets/objects/4321 OPTIONS应该使用来检索描述资源可用交互的元数据\nResponse Status Codes Category Description 1xx: Informational Communicates transfer protocol-level information. 2xx: Success Indicates that the client\u0026rsquo;s request was accepted successfully. 3xx: Redirection Indicates that the client must take some additional action in order to complete their request. 4xx: Client Error This category of error status codes points the finger at clients. 5xx: Server Error The server takes responsibility for these error status codes Response Status Code Rules 200 OK 表示非特定成功 200 OK 不能用于通信相应主体中的错误 201 Created 表示资源创建成功 202 Accepted 必须用于指示已成功启动异步操作 204 No Content 相应主体故意空时，使用204 301 Moved Permanently 用来重新定位资源 302 Found 不应该使用该规则 303 See Other 应用于将客户端引用到不同的URI 304 Not Modified 应用来保留带宽 307 Temporary Redirect 告诉客户将请求重新提交到另一个URI 400 Bad Request 表示非特定失败 401 Unauthorized 当客户端的凭据出现问题，必须使用401 403 Forbidden 用户访问资源超出权限，禁止访问 404 Not Found 当URI无法映射到资源时，必须使用404 405 Method Not Allowed 当HTTP方法不受支持时，必须使用405 406 Not Acceptable 当无法提供请求的文件类型时，必须使用406 409 Conflict 试图将资源置于不可能或不一致的状态时 412 Precondition Failed 请求头中的先决条件不满足，返回412，并未执行请求 415 Unsupported Media Type 当无法处理客户端请求的文件类型时，必须使用415 500 Internal Server Error 用来指示API故障 HTTP Headers Rules Content-Type 必须使用 Content-Length 应该使用 Last-Modified 应该在响应中使用 ETag 应该在响应中使用 存储必须支持有条件的PUT请求 必须使用Location来指定新创建的资源的URI 应该使用Cache-Control、Expires和Date请求头来鼓励缓存 Cache-Control、Expires和Pragma响应头可以用来阻止缓存 Caching should be encouraged Expiration caching缓存头应该与200（OK）响应一起使用 Expiration caching缓存头可以选择与3xx和4xx响应一起使用 不能使用自定义HTTP标头来更改HTTP方法的行为 Media Types 1 type \u0026#34;/\u0026#34; subtype *( \u0026#34;;\u0026#34; parameter ) Registered Media Types Registered Media Types Description text/plain A plain text format with no specific content structure or markup. text/html Content that is formatted using the HyperText Markup Language (HTML). image/jpeg An image compression method that was standardized by the Joint Photographic Experts Group (JEPG). application/xml Content that is structured using the Extensible Markup Language (XML). application/atom+xml Content that uses the Atom Syndication Format (Atom), which is an XML-based format that structures data into lists known as feeds. application/javascript Source code written in the JavaScript programming language. application/json The JavaScript Object Notation (JSON) text-based format that is often used by programs to exchange structured data. Media Types Rules Application-specific media types should be used Media type negotiation should be supported when multiple representations are available Media type selection using a query parameter may be supported Message Body Rules 资源表示应该支持JSON JSON必须是格式良好的 XML和其他格式可以选择用于资源表示 Additional envelopes must not be created Hypermedia Representation Rules A consistent form should be used to represent links A consistent form should be used to represent link relations A consistent form should be used to advertise links A self link should be included in response message body representations Minimize the number of advertised “entry point” API URIs Links should be used to advertise a resource’s available actions in a state-sensitive manner Media Type Representation Rules A consistent form should be used to represent media type formats A consistent form should be used to represent media type schemas Error Representation Rules A consistent form should be used to represent errors A consistent form should be used to represent error responses Consistent error types should be used for common error conditions Client Concerns Rules New URIs should be used to introduce new concepts Schemas should be used to manage representational form versions Entity tags should be used to manage representational state versions OAuth may be used to protect resources API management solutions may be used to protect resources The query component of a URI should be used to support partial responses The query component of a URI should be used to embed linked resources JSONP should be supported to provide multi-origin read access from JavaScript Final Thoughts Principles REST API designs differ more than necessary A REST API should be designed, not coded Programmers and their organizations benefit from consistency A REST API should be created using a GUI tool ","date":"2022-06-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/rest-api-design-rulebook/","title":"REST API Design Rulebook"},{"content":"Windows批处理脚本（.bat） 常用文件操作DOS命令 dir\t列文件名 cd\t改变当前目录 ren\t改变文件名 copy\t拷贝文件 del\t删除文件 md\t建立子目录 rd\t删除目录 deltree\t删除目录树 format\t格式化磁盘 edit\t文本编辑 type\t显示文件内容 mem\t查看内存状况 help\t显示帮助提示 cls\t清屏 move\t移动文件，改目录名 more\t分屏显示 xcopy\t拷贝目录和文件 echo\t显示输入内容 echo on\t打开命令回显 echo off\t关闭命令回显 @\t加上@的命令不会显示 pause\t将程序挂起，按下任意键继续 \u0026gt;\t将显示的内容输出到某处 \u0026gt;\u0026gt;\t将显示内容追加到某处 \u0026gt;nul\t命令后加上\u0026gt;nul表示输出到空设备 mode\t设置窗口尺寸：mode con cols=32 lines=8 color\t设置背景颜色：color 3a（背景(暗靛色)和文字(亮绿色)） title\t改变当前命令提示符的标题名称 rem\t注释（属于命令会显示出来） ::\t注释（不会显示出来） prompt\t修改当前路径为根路径并重命名 goto\t命令跟上标签可以跳转 :\t命令后面写标签名（不区分大小写），特殊标签:EOF或:eof不需要定义 call\t调用批处理或者标签 start\t启动应用程序 变量 命令 解释 set var=1 定义变量var并将1复制给a set var 查看变量var的值 set v 查看所有v开头的变量值 set 查看所有变量的值 %var% var变量的值（内容） set /a var=48 将数字48赋给变量var，32位的整数型数值，占用4个字节 set /p var 用户手动输入值给var set /p var=请输入一些文字 用户手动输入值给var，并显示提示文字：“请输入一些文字” set var=Hello world! echo %var:o=z% 输出Hello world!不改变var值 set var2=%var:ld=ms and bugs% 将Hello worms and bugs!赋值给var2不改变var值 %var:~m% 数字m为正数表示取变量var中从左侧第m个字符以后的内容 数字m为负数表示取变量var中从右侧数第-m个字符以及其右侧所有字符 %var:~m,n% 从m开始，n为正数取n个字符，n为负数取到剩-n个字符为止 set /a num=48 将数值48赋值给变量num set /a result=%num%+12 变量num与12相加的结果赋给变量result echo %result% 显示变量result的值 setlocal EnableDelayedExpansion 延迟变量扩充使!var!有意义 传递参数 使用%接收参数 在call或者start或者在cmd中运行批处理文件时后面直接加上参数来传递参数\n1 2 3 4 5 6 7 8 接收参数： echo 您输入的第1条参数为 %1 echo 您输入的第2条参数为 %2 传递参数： call 被调用.bat hello world! start 被调用.bat hello world! ./被调用.bat hello world! 条件IF 符号 意义 EQU 相等 NEQ 不相等 LSS 小于 LEQ 小于等于 GTR 大于 GEQ 大于等于 NOT 非 if exist\t判断文件是否存在 if defined\t判断环境变量是否被定义 循环FOR for循环的一般使用格式：for %i in (*.*) do @echo %i\n1 2 3 4 5 6 7 8 9 :::::::批量修改文件名.bat::::::: @echo off setlocal EnableDelayedExpansion set /a num=1 for %%i in (D:\\test\\*.txt) do ( ren \u0026#34;%%i\u0026#34; !num!.txt set /a num+=1 ) :::::::::::::::::::::::::::::::: for循环使用数字循环的一般格式：for /l %i in (5,3,16) do echo %i\n数值型变量i依次成为：5、8、11、14。从5开始，每次增加3到16为止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ::::::::::圆圈方阵.bat:::::::::: @echo off setlocal EnableDelayedExpansion set var=○ for /l %%i in (1,1,7) do set var=%var%!var! :: 此时变量 var 已经变成一行连续的8个圆圈了 for /l %%i in (1,1,8) do ( echo 这是第 %%i 份\u0026gt;输出结果%%i.txt for /l %%j in (1,1,8) do echo %var%\u0026gt;\u0026gt;输出结果%%i.txt ) echo 8 X 8 的 ○ 矩阵已经画好，并保存到8份文本文件里了 pause :::::::::::::::::::::::::::::::: 组合命令 \u0026amp;\n1 echo Checking what executable files we have in WINDOWS... \u0026amp; dir C:\\WINDOWS\\*.exe \u0026amp; echo And we got lots of stuff here. \u0026amp;在多个命令之间起连接作用。\n不论三者中每一条命令的结果如何，后面的一条命令总能被得到执行。\n\u0026amp;\u0026amp;\n和\u0026amp;类似，并列多条命令并将其按顺序执行。\n如果多命令中的某一条命令执行出错，后面的命令将不会再被执行；如果一直没有出错，就会一直执行完所有并列命令。\n||\n||的用途和\u0026amp;\u0026amp;恰好相反。\n当遇到执行正确的命令后将不再执行后面的命令。\n如果没有出现正确的命令则一直执行完所有命令。\n管道命令 \u0026gt;和\u0026gt;\u0026gt;\n输入重定向命令。将一条命令或某个程序输出结果的重定向到特定文件中。\n\u0026gt;会清除掉原文件中的内容后写入指定文件，而\u0026gt;\u0026gt;只会追加内容到指定文件中。\n|\n它可以将它左边命令的输出结果放到它右边的命令里作为参数。\n管道命令还有\u0026lt;、\u0026lt;\u0026amp;和\u0026gt;\u0026amp;，它们并不常见，暂不讨论。\n学习地址 Windows 批处理脚本学习教程\n","date":"2022-05-17T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/windows%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC.bat/","title":"Windows批处理脚本（.bat）"},{"content":"Windows 11 允许远程桌面/远程访问 Windows 11 允许远程桌面 打开设置 搜索Remote Desktop 打开Remote Desktop Windows 11 允许远程访问 搜索打开Windows Defender Firewall 点击Turn Windows Defender Firewall on or off 将Public network settings 选择 Turn off Windows Defender Firewall (not recommended) 点击下方OK保存 显示如图即可 ","date":"2022-05-12T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/windows-11-%E5%85%81%E8%AE%B8%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"Windows 11 允许远程桌面/远程访问"},{"content":"MonetDB远程访问 首先我们应该知道正常启动MonetDB是直接运行安装目录下的M5server.bat文件 启动后如下图，这时候直接使用另一台电脑的DBeaver连接会提示连接被拒绝 编辑安装目录下的M5server.bat文件，给下面start the real server命令后面加上\u0026ndash;set \u0026ldquo;mapi_listenaddr=all\u0026quot;参数 1 --set \u0026#34;mapi_listenaddr=all\u0026#34; 保存文件重新运行M5server.bat 完成 参考资料 https://www.monetdb.org/documentation-Jan2022/admin-guide/manpages/mserver5/\n","date":"2022-05-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/monetdb%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"MonetDB远程访问"},{"content":"MySQL 5.7 远程访问 进入MySQL安装目录下的bin目录（如果配置过环境变量就直接到第二步） 在地址栏输入cmd打开命令行窗口（如果配置过环境变量直接Win+R输入cmd回车即可） 输入命令并回车 1 mysql -uroot -p 输入命令并回车，其中password是你msyql数据库的密码 1 grant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;password\u0026#39;; 输入命令并回车 1 flush privileges; 关闭窗口，完成 ","date":"2022-05-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/mysql-5.7-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"MySQL 5.7 远程访问"},{"content":"PostgreSQL远程访问 打开PostgreSQL安装目录下data\\pg_hba.conf文件 添加如下行 1 host\tall\tall\t0.0.0.0/0\tscram-sha-256 保存退出，完成 ","date":"2022-05-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/postgresql%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/","title":"PostgreSQL远程访问"},{"content":"葡萄城（GrapeCity）笔试题 题目出处 题目网址：https://www.grapecity.com.cn/career/challenge\n题目描述 题目：数据可视化\n编程语言：不限\n题目描述：有句话是这么说的：“文不如表，表不如图”。形象地描述了图表在传达信息时，给接收者带来的截然不同的效率和体验。因此，在计算机计算能力、数据规模和决策需求都不断提升的当下，数据可视化的应用也越来越普遍。\n数据可视化的范围很广，涉及到数据的获取、加工、建模、图形学，人机交互等很多概念和领域，想更快上手，获得更好的体验，使用DragonFly BI这样的专业工具和服务是更明智的选择。\n今天，我们通过一个简化的命题，来亲手实现简单的数据可视化。编写一个程序，对于给定的一组数据和要求，输出一个以字符组成的柱状图。\n输入\n第一行，一个整数 N（1\u0026lt;=n\u0026lt;=20），表示这组数据的条目数。 第二行，两个字符串，用于表示数据展示在柱状图上的排序方式。第一个字符串是“Name” 或者 “Value”，表示排序的依据是数据条目的名称亦或数值；第二个字符串是 “ASC” 或者 “DESC”，表示升序或降序。 随后的 N 行，每行包含一个字符串 S 和一个数字 V，以空格分隔，表示一条数据。S 即数据条目的名称，仅包含小写字母，V 即对应的数值，是一个整数，(0\u0026lt;=V\u0026lt;=1,000,000) 输出\n图表外框转角符号：\n“┌”（\\u250c） “┐”（\\u2510） “└”（\\u2514） “┘”（\\u2518） 图表中的横、竖线：\n“─”（\\u2500） “│”（\\u2502） 图表中的各种交叉线：\n“├”（\\u251c） “┤”（\\u2524） “┬”（\\u252c） “┴”（\\u2534） “┼”（\\u253c） 用来拼柱子的字符：\n“█”（\\u2588） 图表中的空格：\n“ ”（\\u0020） 图表中名称区域的宽度，由这组数据中名称的最大长度决定，所有名称向右对齐， 图表中柱的最大长度为 20，每个柱的长度由该柱对应数据和这组数据中最大值（此值一定大于 0）的比值与 20 相乘获得，不足一格的部分舍去。\n输入示例\n1 2 3 4 5 3 Value DESC apple 5 pen 3 pineapple 10 输出示例\n题解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 import java.util.Arrays; import java.util.HashMap; import java.util.Scanner; public class test { public static void main(String []args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); String way = sc.next(); String seq = sc.next(); String name; int value; int maxLength = 0; int maxNum = 0; Object[] arr = new Object[num]; HashMap\u0026lt;Object, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i=0; i\u0026lt;num; i++) { name = sc.next(); value = sc.nextInt(); if (name.length() \u0026gt; maxLength) maxLength = name.length(); if (value \u0026gt; maxNum) maxNum = value; if (way.equals(\u0026#34;Name\u0026#34;)) { map.put(name, value); arr[i] = name; } else { map.put(value, name); arr[i] = value; } } //排序 Arrays.sort(arr); if (seq.equals(\u0026#34;DESC\u0026#34;)) { int l = arr.length; Object temp=0; for (int i=0; i\u0026lt;l/2; i++) { temp = arr[i]; arr[i] = arr[l-i-1]; arr[l-i-1] = temp; } } //输出首行 System.out.print(\u0026#39;\\u250c\u0026#39;); for (int i=0; i\u0026lt;maxLength; i++) System.out.print(\u0026#39;\\u2500\u0026#39;); System.out.print(\u0026#39;\\u252c\u0026#39;); for (int i=0; i\u0026lt;20; i++) System.out.print(\u0026#39;\\u2500\u0026#39;); System.out.println(\u0026#39;\\u2510\u0026#39;); //输出后面行，每两行一组 for (int k=0; k\u0026lt;num; k++) { //获取该行数据 if (way.equals(\u0026#34;Name\u0026#34;)) { name = (String)arr[k]; value = (int)map.get(arr[k]); } else { value = (int)arr[k]; name = (String)map.get(arr[k]); } //计算柱长度 int q = (int)((double)value/maxNum*20); //含有数据行输出 System.out.print(\u0026#39;\\u2502\u0026#39;); for (int i=1; i\u0026lt;=maxLength-name.length(); i++) { System.out.print(\u0026#39;\\u0020\u0026#39;); } System.out.print(name); System.out.print(\u0026#39;\\u2502\u0026#39;); for (int i=1; i\u0026lt;=q; i++) { System.out.print(\u0026#39;\\u2588\u0026#39;); } for (int i=q; i\u0026lt;20; i++) { System.out.print(\u0026#39;\\u0020\u0026#39;); } System.out.println(\u0026#39;\\u2502\u0026#39;); //输出边框行 if (k == num-1) { System.out.print(\u0026#39;\\u2514\u0026#39;); for (int i=0; i\u0026lt;maxLength; i++) { System.out.print(\u0026#39;\\u2500\u0026#39;); } System.out.print(\u0026#39;\\u2534\u0026#39;); for (int i=0; i\u0026lt;20; i++) { System.out.print(\u0026#39;\\u2500\u0026#39;); } System.out.println(\u0026#39;\\u2518\u0026#39;); } else { System.out.print(\u0026#39;\\u251c\u0026#39;); for (int i=0; i\u0026lt;maxLength; i++) { System.out.print(\u0026#39;\\u2500\u0026#39;); } System.out.print(\u0026#39;\\u253c\u0026#39;); for (int i=0; i\u0026lt;20; i++) { System.out.print(\u0026#39;\\u2500\u0026#39;); } System.out.println(\u0026#39;\\u2524\u0026#39;); } } } } 运行截图 ","date":"2021-09-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%91%A1%E8%90%84%E5%9F%8Egrapecity%E7%AC%94%E8%AF%95%E9%A2%98/","title":"葡萄城（GrapeCity）笔试题"},{"content":"在VMware上安装CentOS7 安装前准备 电脑上安装VMware Workstation 15.5 Pro\n下载CentOS-7-x86_64-DVD-1611.iso镜像文件\n安装CentOS 7 打开VMware软件，点击创建新的虚拟机，打开新建虚拟机向导 选择自定义（高级），点击下一步 选择Workstation 15.x，点击下一步 选择稍后安装操作系统，点击下一步 客户机操作系统选择Linux，版本选择CentOS 7 64位，点击下一步 修改虚拟机名称，和虚拟机存储路径后点击下一步 虚拟机处理器数量和内核数量都选择2，点击下一步 选择虚拟机内存为1GB，点击下一步 选择使用网络地址转换（NAT）后点击下一步 选择LSI Logic，点击下一步 硬盘类型选择SCSI，点击下一步 选择创建新虚拟硬盘，点击下一步 最大磁盘大侠设置为20G，选择将虚拟磁盘拆分成多个文件，点击下一步 设置磁盘文件名后点击下一步 点击完成 点击编辑虚拟机设置 左侧选择CD/DVD，选择使用ISO映像文件，点击浏览，选择CentOS-7-x86_64-DVD-1611.iso镜像文件，点击确定 点击开启此虚拟机，等待虚拟机启动 使用键盘上下选择Install CentOS Linux 7回车 等待系统自检 选择中文，点击继续 点击软件选择 勾选需要的功能（这里我只需要最小安装即可），点击完成 点击安装位置 点击完成 点击开始安装 点击ROOT密码 设置密码后，点击完成 由于密码过于简单，需二次确认密码，再次点击完成 等待系统安装完毕后点击重启即可使用 ","date":"2021-08-16T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%9C%A8vmware%E4%B8%8A%E5%AE%89%E8%A3%85centos7/","title":"在VMware上安装CentOS7"},{"content":"在CentOS7上安装MySQL-5.7 当时安装mysql5.7遇到很多问题，网上解决办法都不对，记录下来自己安装成功的安装步骤及注意事项\n安装mysql5.7 更新yum本地缓存 1 2 yum clean cache yum makecache 查看系统中是否已安装mysql 1 yum list installed | grep mysql 卸载系统自带的mysql及其依赖（防止冲突） 1 yum -y remove mysql-libs.x86_64 安装wget 1 yum install wget -y 给centos添加rpm源，并且选择比较新的源 1 wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm 安装下载好的rpm文件 进入目录/etc/yum.repos.d/会多出这两个文件 修改mysql-community.repo文件 1 vi mysql-community.repo 使用yum安装mysql 1 yum install mysql-community-server -y 查看下mysql的版本，确定是否安装成功 1 mysql -V 启动mysql服务 1 service mysqld start 设置mysql开机启动 1 chkconfig mysqld on 从mysqld.log文件中，查看mysql临时密码 1 grep \u0026#34;password\u0026#34; /var/log/mysqld.log 复制上面的临时密码，登录mysql 1 mysql -uroot -p临时密码 如果临时密码中有特殊字符，需要加上 \\\\ 转义，不然会提示字符异常 -u 和-p后面不要有空格，不然会提示密码错误 修改密码验证策略(不更改，可能修改的密码通不过)，然后更改root用户密码 1 2 3 set global validate_password_policy=0; set global validate_password_length=4; alter user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; 修改密码成功后，输入quit退出，然后使用新密码重新登录。 设置数据库用户在所有ip下都可以访问，以下用root用户示例（mysql中输入该命令） 1 grant all privileges on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;123456\u0026#39; with grant option; 其中root为用户，%表示所有权限，密码为123456 刷新mysql的系统权限相关表（mysql中输入该命令） 1 flush privileges; 使用quit或exit退出mysql，重启mysql服务 1 service mysqld restart 开启防火墙 linux防火墙默认是没有开通3306端口的，需要手动开通，这样本地客户端才能连接上linux上的mysql服务。\n查询3306端口是否开启 1 firewall-cmd --query-port=3306/tcp yes，表示开启；no表示未开启 在防火墙上，添加需要开放的3306端口 1 firewall-cmd --add-port=3306/tcp --permanent 重载入添加的端口 1 firewall-cmd --reload 再次查询3306端口是否开启，确认已开启 1 firewall-cmd --query-port=3306/tcp 卸载linux上的mysql 如果安装失败，想重新安装，则需要将mysql相关的全部删除掉。\n检查安装的mysql组件 1 rpm -qa | grep -i mysql 将查询出来的文件逐个删除 1 2 3 yum remove mysql-community-libs-compat-5.7.35-1.el7.x86_64 yum remove mysql-community-release-el6-5.noarch yum remove mysql-community-common-5.7.35-1.el7.x86_64 删除mysql相关文件 1 2 3 4 5 6 yum remove mysql mysql-server mysql-libs mysql-server rm -rf /var/lib/mysq rm /etc/my.cnf rm –rf /usr/lib64/mysql rm -rf /etc/yum.repos.d/mysql* rm -rf mysql-community-release-el6-5.noarch.rpm 查找残留目录，然后使用rm命令逐一删除 1 whereis mysql ","date":"2021-08-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%9C%A8centos7%E4%B8%8A%E5%AE%89%E8%A3%85mysql-5.7/","title":"在CentOS7上安装MySQL-5.7"},{"content":"在Windows上安装Tomcat8 下载安装包 访问Tomcat官网 https://tomcat.apache.org/\n在左侧Download栏选择下载版本，这里选择的是Tomcat8版本，点击进入\n根据自己系统版本选择对应版本下载，这里选择的是Windows64位操作系统版本，如图点击下载\n安装Tomcat8（下载的zip包为免安装版，解压后可直接使用） 将下载下来的文件解压\n将解压的文件放在D盘\n配置环境变量 在此电脑上右键点击属性，打开设置\n点击高级系统设置，打开系统属性\n点击环境变量，打开环境变量\n选中path，点击编辑，进入编辑path变量页面\n点击新建，输入Tomcat8的安装目录下bin文件夹的目录，点击确定，确定，确定\n运行命令 进入Tomcat8安装目录下bin文件夹中\n点击地址栏，输入cmd，回车，打开命令行窗口\n在命令行窗口中输入service.bat install后回车\n显示如图即为安装成功\n测试是否成功 双击运行bin文件夹下的Tomcat8w.exe文件，打开启动窗口\n点击Start启动Tomcat8\n打开浏览器，输入127.0.0.1:8080访问出现如下画面即为安装成功\n","date":"2021-07-26T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%85tomcat8/","title":"在Windows上安装Tomcat8"},{"content":"在Windows上安装MySQL-5.7.17 下载mysql安装包 下载mysql安装包。mysql-5.7.17.msi.\n或前往官网下载安装包。\n打开安装包 勾选I accept the license terms然后点击Next 勾选Custom（自定义）然后点击Next 选择安装版本64位系统选择x64，32位系统选择x86 然后点击右边选择的下方Advanced Options，进行自定义路径，我装在了D盘根目录下，然后OK，然后Next 继续点Execute，等待安装 安装好了后点击Next，继续Next 选择服务器专用 设置端口号，一般不建议修改，默认3306即可，然后Next 输入mysql密码，然后Next 设置服务器名称，一般也不需要修改，然后Next 不需要修改直接Next 点击Execute，开始安装 点击Finish 点击Next 点击Finish 打开安装目录下的my.ini文件 修改其中的这两行为innodb_flush_log_at_trx_commit=0和innodb_buffer_pool_size=2G 修改完成后保存，进入到安装目录中的bin文件夹下 点击上方地址栏输入cmd，然后回车，在该目录打开命令行 输入命令：\u0026ldquo;mysql -uroot -p\u0026rdquo;，然后输入密码，进入mysql数据库 输入\u0026quot;status\u0026quot;，显示如下图即安装完毕 ","date":"2021-05-29T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%9C%A8windows%E4%B8%8A%E5%AE%89%E8%A3%85mysql-5.7.17/","title":"在Windows上安装MySQL-5.7.17"},{"content":"谷歌Chrome浏览器导出密码和导入密码 有时候大家遇到换了新电脑，或者公司需要调整电脑，或者说需要导入别人电脑上谷歌浏览器存的账号密码，发现可以导出密码，但是没有导入密码的选项，就很烦，这里教大家如何导出导入chrome谷歌浏览器的账号密码。\n导出账号密码 点击右上角的设置 选择密码 点击右边的更多操作 点击导出密码即可 导出的密码是csv格式，可以用excel查看，但仍不方便，那么如何导入呢？ 导入账号密码 打开谷歌浏览器，在地址栏输入chrome://flags/#password-import-export 然后在上面的搜索栏搜索：password import 然后选择右边的Default为Enabled，并点击下方Relaunch刷新浏览器 最后重新进入导出密码的地方，就可以看到导入的选项啦 导入自己从别的电脑导出的密码，就会发现两台电脑的谷歌浏览器所拥有的密码一样啦 ","date":"2021-05-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%B0%B7%E6%AD%8Cchrome%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81%E5%92%8C%E5%AF%BC%E5%85%A5%E5%AF%86%E7%A0%81/","title":"谷歌Chrome浏览器导出密码和导入密码"},{"content":"贪吃蛇游戏（Java GUI） GUI简述 GUI概述 早期，电脑向用户提供的是单调、枯燥、纯字符状态的“命令行界面（CLI）”。就是到现在，我们还可以依稀看到它们的身影：在Windows中开个DOS窗口，就可看到历史的足迹。后来，Apple公司率先在电脑的操作系统中实现了图形化的用户界面（Graphical User Interface，简称GUI），但由于Apple公司封闭的市场策略，自己完成电脑硬件、操作系统、应用软件一条龙的产品，与其它PC不兼容。这使得Apple公司错过了一次一统全球PC的好机会。\n后来，Microsoft公司推出了风靡全球的Windows操作系统，它凭借着优秀的图形化用户界面，一举奠定了操作系统标准的地位。这也造就了世界首富\u0026mdash;比尔.盖茨和IT业的泰山北斗微软公司。\n在这图形用户界面风行于世的今天，一个应用软件没有良好的GUI是无法让用户接受的。而Java语言也深知这一点的重要性，它提供了一套可以轻松构建GUI的工具。在本章和下一章中，我们将向你充分证明这一点。\n图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。\n图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。图形用户界面由窗口、下拉菜单、对话框及其相应的控制机制构成，在各种新式应用程序中都是标准化的，即相同的操作总是以同样的方式来完成，在图形用户界面，用户看到和操作的都是图形对象，应用的是计算机图形学的技术。\nJava中用来开发GUI的包 java.awt 包 – 主要提供字体/布局管理器\njavax.swing 包[商业开发常用] – 主要提供各种组件(窗口/按钮/文本框)\njava.awt.event 包 – 事件处理，后台功能的实现。\n游戏截图 代码展示 游戏的主启动类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.study.snake; import javax.swing.*; //游戏的主启动类 public class StartGame { public static void main(String[] args) { JFrame frame = new JFrame(\u0026#34;贪吃蛇\u0026#34;); frame.setBounds(10,10,915,720); frame.setResizable(false);//窗口大小不可变 frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //正常游戏界面都应该在面板上！ frame.add(new GamePanel()); frame.setVisible(true); } } 游戏的面板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 package com.study.snake; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.util.Random; //游戏的面板 public class GamePanel extends JPanel implements KeyListener, ActionListener { //定义蛇的数据结构 int length; //蛇的长度 int[] snakeX = new int[600]; //蛇的x坐标 25*25 int[] snakeY = new int[500]; //蛇的坐标 25*25 String fx;//初始方向 //食物的坐标 int foodX; int foodY; Random random = new Random(); int score;//成绩 //游戏当前的状态： 开始 or 停止 boolean isStart = false; //默认是停止 boolean isFail = false; //游戏失败 //定时器 以ms为单位 1000ms = 1s Timer timer = new Timer(100,this); //100毫秒执行一次！ //构造器 public GamePanel() { init(); //获得焦点和键盘事件 this.setFocusable(true); //获得焦点事件 this.addKeyListener(this); //获得键盘监听事件 timer.start(); //游戏一开始定时器就启动 } //初始化方法 public void init(){ length = 3; snakeX[0] = 100; snakeY[0] = 100; //脑袋的坐标 snakeX[1] = 75 ; snakeY[1] = 100; //第一个身体的坐标 snakeX[2] = 50 ; snakeY[2] = 100; //第二个身体的坐标 fx = \u0026#34;R\u0026#34;; //初始方向向右 foodX = 25 + 25*random.nextInt(34); foodY = 75 + 25*random.nextInt(24); score = 0;//初始0分 } //绘制面板，游戏中的所有东西，都使用这个画笔来画 @Override protected void paintComponent(Graphics g) { super.paintComponent(g);//清屏 //绘制静态的面板 this.setBackground(Color.WHITE); Data.header.paintIcon(this,g,25,11);//头部广告栏画上去 g.fillRect(25,75,850,600);//默认的游戏界面 //画积分 g.setColor(Color.WHITE); g.setFont(new Font(\u0026#34;微软雅黑\u0026#34;,Font.BOLD,18)); g.drawString(\u0026#34;长度\u0026#34;+length,750,40); g.drawString(\u0026#34;分数\u0026#34;+score,750,60); //画食物 Data.food.paintIcon(this,g,foodX,foodY); //把小蛇画上去 if (fx.equals(\u0026#34;R\u0026#34;)){ Data.right.paintIcon(this,g,snakeX[0],snakeY[0]); }else if (fx.equals(\u0026#34;L\u0026#34;)){ Data.left.paintIcon(this,g,snakeX[0],snakeY[0]); }else if (fx.equals(\u0026#34;U\u0026#34;)){ Data.up.paintIcon(this,g,snakeX[0],snakeY[0]); }else if (fx.equals(\u0026#34;D\u0026#34;)){ Data.down.paintIcon(this,g,snakeX[0],snakeY[0]); } // Data.right.paintIcon(this,g,snakeX[0],snakeY[0]);//蛇头初始化向右 for (int i = 1; i \u0026lt; length ; i++){ Data.body.paintIcon(this,g,snakeX[i],snakeY[i]);//身体坐标 } // Data.body.paintIcon(this,g,snakeX[1],snakeY[1]);//第一个身体坐标 // Data.body.paintIcon(this,g,snakeX[2],snakeY[2]);//第二个身体坐标 //游戏状态 if (isStart == false){ g.setColor(Color.WHITE); //设置字体 g.setFont(new Font(\u0026#34;微软雅黑\u0026#34;,Font.BOLD,40)); g.drawString(\u0026#34;按下空格开始游戏！\u0026#34;,300,300); } if (isFail){ g.setColor(Color.RED); //设置字体 g.setFont(new Font(\u0026#34;微软雅黑\u0026#34;,Font.BOLD,40)); g.drawString(\u0026#34;失败，按下空格重新开始！\u0026#34;,300,300); } } //键盘监听事件 @Override public void keyPressed(KeyEvent e) { int keyCode = e.getKeyCode(); //获得键盘按键是哪一个 if (keyCode == KeyEvent.VK_SPACE){ //如果按下的是空格键 if (isFail){ isFail = false; //重新开始 init(); }else{ isStart = !isStart; //取反 } repaint(); } //小蛇移动 if (keyCode == KeyEvent.VK_UP){ fx = \u0026#34;U\u0026#34;; }else if (keyCode == KeyEvent.VK_DOWN){ fx = \u0026#34;D\u0026#34;; }else if (keyCode == KeyEvent.VK_LEFT){ fx = \u0026#34;L\u0026#34;; }else if (keyCode == KeyEvent.VK_RIGHT){ fx = \u0026#34;R\u0026#34;; } } //事件监听--需要通过固定时间来刷新，1s=10次 @Override public void actionPerformed(ActionEvent e) { if (isStart \u0026amp;\u0026amp; isFail == false){ //如果游戏是开始状态并且没有失败，就让小蛇动起来 //吃食物 if (snakeX[0] == foodX \u0026amp;\u0026amp; snakeY[0] == foodY){ length++; //长度 + 1 //分数加10 score += 10; //再次随机食物 foodX = 25 + 25*random.nextInt(34); foodY = 75 + 25*random.nextInt(24); } //移动 for (int i = length-1; i \u0026gt; 0; i--){ //后一节移动到前一节的位置snakeX[1] = snakeX[0]; snakeX[i] = snakeX[i-1]; snakeY[i] = snakeY[i-1]; } //走向 if (fx.equals(\u0026#34;R\u0026#34;)){ snakeX[0] = snakeX[0]+25; if (snakeX[0] \u0026gt; 850){ snakeX[0] = 25; } //边界判断 }else if (fx.equals(\u0026#34;L\u0026#34;)){ snakeX[0] = snakeX[0]-25; if (snakeX[0] \u0026lt; 25){ snakeX[0] = 850; } //边界判断 }else if (fx.equals(\u0026#34;U\u0026#34;)){ snakeY[0] = snakeY[0]-25; if (snakeY[0] \u0026lt; 75){ snakeY[0] = 650; } //边界判断 }else if (fx.equals(\u0026#34;D\u0026#34;)){ snakeY[0] = snakeY[0]+25; if (snakeY[0] \u0026gt; 650){ snakeY[0] = 75; } //边界判断 } //失败判断，撞到自己就算失败 for (int i = 1; i \u0026lt; length; i++) { if (snakeX[0] == snakeX[i] \u0026amp;\u0026amp; snakeY[0] == snakeY[i]){ isFail = true; } } repaint(); //重画页面 } timer.start(); //定时器开启！ } @Override public void keyTyped(KeyEvent e) { } @Override public void keyReleased(KeyEvent e) { } } 游戏的数据中心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.study.snake; import javax.swing.*; import java.net.URL; //数据中心 public class Data { //相对路径 相对于当前类的路径 //绝对路径 相对于当前项目的根目录 public static URL headerURL = Data.class.getResource(\u0026#34;statics/header.png\u0026#34;); public static ImageIcon header = new ImageIcon(headerURL); public static URL upURL = Data.class.getResource(\u0026#34;statics/up.png\u0026#34;); public static ImageIcon up = new ImageIcon(upURL); public static URL downURL = Data.class.getResource(\u0026#34;statics/down.png\u0026#34;); public static ImageIcon down = new ImageIcon(downURL); public static URL leftURL = Data.class.getResource(\u0026#34;statics/left.png\u0026#34;); public static ImageIcon left = new ImageIcon(leftURL); public static URL rightURL = Data.class.getResource(\u0026#34;statics/right.png\u0026#34;); public static ImageIcon right = new ImageIcon(rightURL); public static URL foodURL = Data.class.getResource(\u0026#34;statics/food.png\u0026#34;); public static ImageIcon food = new ImageIcon(foodURL); public static URL bodyURL = Data.class.getResource(\u0026#34;statics/body.png\u0026#34;); public static ImageIcon body = new ImageIcon(bodyURL); } 代码下载 源代码下载链接：贪吃蛇小游戏\n","date":"2020-12-24T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%B4%AA%E5%90%83%E8%9B%87%E6%B8%B8%E6%88%8Fjava-gui/","title":"贪吃蛇游戏（Java GUI）"},{"content":"机器学习 - 模型评估与选择 \u0026amp; K-means聚类算法实验 Note: 代码仅供参考，根据实际情况做相应的修改，不能完全照搬，否则运行不通！\n1.导入类库 1 2 from pandas import read_csv #使用pandas来导入数据和对数据进行描述性统计分析 from matplotlib import pyplot #使用matplotlib进行绘图，数据可视化 2.导入数据集 1 2 3 4 5 #使用sklearn自带的示例数据集 from sklearn import datasets iris=datasets.load_iris() #数据集有两个文件，分别为iris.data，存放特征数据；iris.target，存放类别数据。 #自行对两个数据集进行查看、可视化显示。使用describe(),info(),hist(),scatter()等函数。 3.分离数据集 1 2 3 4 5 from sklearn.model_selection import train_test_split # train_test_split函数用于将矩阵随机划分为训练子集和测试子集，并返回划分好的训练集测试集样本和训练集测试集标签。 validation_size = 0.2 #分离数据，80%训练数据集，20%评估数据集 seed = 7 X_train, X_validation, Y_train, Y_validation = train_test_split(iris.data,iris.target, test_size=validation_size, random_state=seed) 4.使用逻辑回归和贝叶斯分类器两种算法进行算法性能评估，并在测试集上进行验证。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from sklearn.linear_model import LogisticRegression #逻辑回归 from sklearn.metrics import accuracy_score from sklearn.metrics import classification_report from sklearn.metrics import confusion_matrix from sklearn.naive_bayes import GaussianNB #朴素贝叶斯 from sklearn.model_selection import KFold from sklearn.model_selection import cross_val_score # 算法审查（注意，使用某个算法前，要自己先从skleran类库中导入） models = {} models[\u0026#39;LR\u0026#39;] = LogisticRegression() models[\u0026#39;LDA\u0026#39;] = LinearDiscriminantAnalysis() models[\u0026#39;KNN\u0026#39;] = KNeighborsClassifier() models[\u0026#39;CART\u0026#39;] = DecisionTreeClassifier() models[\u0026#39;NB\u0026#39;] = GaussianNB() models[\u0026#39;SVM\u0026#39;] = SVC() # 评估算法，使用十折交叉验证法 results = [] for key in models: kfold = KFold(n_splits=10, random_state=seed) cv_results = cross_val_score(models[key], X_train, Y_train, cv=kfold, scoring=\u0026#39;accuracy\u0026#39;)\tresults.append(cv_results) print(\u0026#39;%s: %f (%f)\u0026#39; %(key, cv_results.mean(), cv_results.std())) #测试集上验证、比较两种算法分类效果 lr=LogisticRegression() lr.fit(X=X_train, y=Y_train) predictions = lr.predict(X_validation) print(accuracy_score(Y_validation, predictions)) #预测准确率 print(confusion_matrix(Y_validation, predictions)) #冲突矩阵 print(classification_report(Y_validation, predictions)) #数据报告 nb = GaussianNB() nb.fit(X=X_train, y=Y_train) predictions = nb.predict(X_validation) print(accuracy_score(Y_validation, predictions)) print(confusion_matrix(Y_validation, predictions)) print(classification_report(Y_validation, predictions)) 出现消除警告信息怎么办？怎么消除？\n1 2 3 4 方法1：指定LogisticsRegression函数的两个默认参数 lr=LogisticRegression(solver=\u0026#39;liblinear\u0026#39;,multi_class=\u0026#39;auto\u0026#39;) 方法2：import warnings warnings.filterwarnings(\u0026#34;ignore\u0026#34;) K-means聚类的sklearn实现： ","date":"2020-11-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9-k-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","title":"机器学习 - 模型评估与选择 \u0026 K-means聚类算法实验"},{"content":"机器学习 - 逻辑回归实验 用scikit-learn和pandas学习Logistic回归 1. 获取数据，定义问题 泰坦尼克号的沉没是历史上最臭名昭著的沉船事件之一。1912年4月15日，在首次航行期间，泰坦尼克号撞上冰山后沉没，2224名乘客和机组人员中有1502人遇难。导致生命损失的原因之一是没有足够的救生艇给乘客和机组人员。虽然幸存下来的运气有一些因素，但一些人比其他人更有可能生存，比如妇女，儿童和上层阶级。\nTitanic数据集分为两部分：\n训练数据集-包含特征信息和存活与否的标签，train.csv\n测试数据集-只包含特征信息，test.csv\n数据集可以从kaggle上下载，格式为csv。\n也可以在我的csdn资源里面下载：点击下载\n我们要运用机器学习的工具来预测哪些乘客更可能幸免于难。\n在这本次课的挑战中，我们要用逻辑回归算法，完成对哪些人更有可能生存的分析。\n在scikit-learn中，Logistics回归通过linear_model.LogisticRegression类进行实现。\n1 2 3 4 5 6 LogisticRegression(penalty=\u0026#39;l2\u0026#39;, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver=\u0026#39;warn\u0026#39;, max_iter=100, multi_class=\u0026#39;warn\u0026#39;, verbose=0, warm_start=False, n_jobs=None) 参考https://www.cnblogs.com/wjq-Law/p/9779657.html\n1 2 3 4 5 属性：coef_, intercept_, n_iter 方法：fit(X_train,y_train) score(X_test,y_test) predict(X) predict_proba(X) 2. 查看数据 Data columns (total 12 columns):\nPassengerId 891 non-null int64 Pclass 891 non-null int64 Name 891 non-null object Sex 891 non-null object Age 714 non-null float64 SibSp 891 non-null int64 Parch 891 non-null int64 Ticket 891 non-null object Fare 891 non-null float64 Cabin 204 non-null object Embarked 889 non-null object 可以看到，训练集一共包含891个样本，每个样本有12个特征，其中Age、Cabin和Embarked有缺失值。特别是Carbin特征，只有204个样本有值。\n同理：观察测试集中的缺失值。\n查看数据的其他函数：\n1 2 3 4 5 data_trian.describe() #描述数据 data_trian.head() #查看数据的前5行 data_trian.tail() #查看数据的维度 data_trian.shape data_trian.hist() #数据可视化，直方图显示。注意要先import matplotlib类库。 3. 缺失值的处理 Age特征非常重要（逃命时通常女士和小孩优先），因此我们需要对其填充。\n缺失值的填充方法有:固定值填充、均值/中位数填充、相邻值填充、模型预测填充。\n此处我们使用均值填充。fillna()函数。\nCabin缺失值较多，我们直接将其舍弃，以免引入较大的噪声。（删某一特征，列） 用drop()函数。\nEmbarked特征在训练集中只有2个样本有缺失值，因此可以直接将有缺失的样本删除。（删某一样本，行）\n同理，对测试集的缺失值进行处理。\n4. 特征处理 现在的数据还存在一些问题，如Name特征是文本型，不利于后续处理，我们训练模型时暂时将其舍弃。Ticket特征比较乱，也将其暂时忽略。\nPclass特征、Sex特征、Embarked特征都是类别型，一般需要将其进行one-hot编码。\nAge特征、SibSp特征、Parch特征和Fare特征为数值型，取值变化范围较大，一般先将其标准化或归一化。\n标准化使用preprocessing.StandardScaler类库中的fit()函数和fit_transform()函数。\nfit()用于计算训练数据的均值和方差， 后面就会用均值和方差来转换训练数据。\nfit_transform()不仅计算训练数据的均值和方差，还会基于计算出来的均值和方差来转换训练数据，从而把数据转换成标准的正太分布。\n5. 模型训练 （1）导入需要的分类算法类库。\n1 from sklearn import linear_model.LogisticRegression() 逻辑回归函数的参数如下：\n1 2 3 4 LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class=\u0026#39;warn\u0026#39;, n_jobs=None, penalty=\u0026#39;l2\u0026#39;, random_state=None, solver=\u0026#39;lbfgs\u0026#39;, tol=1e-06, verbose=0, warm_start=False) （2）将训练集中的特征值和标签分开提取。\n（3）划分训练集和验证集。\ntrain_test_split()函数\n（4）训练模型。\nfit()函数。\n（5）在验证集上验证，评估性能。\n模型已经训练好，并且性能还不错，可以拿来进行预测了。\n6. 完整python代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import pandas as pd import matplotlib data_train = pd.read_csv(\u0026#34;D:/titanic/train.csv\u0026#34;) data_train.info() data_train.describe() data_train.head() data_train.tail() data_train.shape data_train.hist() data_train[\u0026#39;Age\u0026#39;].fillna(data_train[\u0026#39;Age\u0026#39;].mean(),inplace = True) data_train.info() data_train = data_train.drop([\u0026#39;Cabin\u0026#39;],axis=1) data_train.info() data_train = data_train.dropna(axis=0) data_train.info() data_train.head() data_train = data_train.drop([\u0026#39;Name\u0026#39;,\u0026#39;Ticket\u0026#39;],axis=1) data_train.head() cate_df = data_train[[\u0026#39;Pclass\u0026#39;,\u0026#39;Sex\u0026#39;,\u0026#39;Embarked\u0026#39;]] cate_onehot_df = pd.get_dummies(cate_df) cate_onehot_df.head() cont_df = data_train[[\u0026#39;Age\u0026#39;,\u0026#39;Fare\u0026#39;,\u0026#39;SibSp\u0026#39;,\u0026#39;Parch\u0026#39;]] cont_df.head() import sklearn.preprocessing as pr scaler = pr.StandardScaler() age_scale = scaler.fit(cont_df[\u0026#39;Age\u0026#39;].values.reshape(-1,1)) print(age_scale) cont_df[\u0026#39;Age_scaled\u0026#39;]=scaler.fit_transform(cont_df[\u0026#39;Age\u0026#39;].values. reshape(-1,1),age_scale) fare_scale = scaler.fit(cont_df[\u0026#39;Fare\u0026#39;].values.reshape(-1,1)) cont_df[\u0026#39;Fare_scaled\u0026#39;]=scaler.fit_transform(cont_df[\u0026#39;Fare\u0026#39;].values.reshape(-1,1),fare_scale) sibsp_scale=scaler.fit(cont_df[\u0026#39;SibSp\u0026#39;].values.reshape(-1,1)) cont_df[\u0026#39;SibSp_scaled\u0026#39;]=scaler.fit_transform(cont_df[\u0026#39;SibSp\u0026#39;].values.reshape(-1,1),sibsp_scale) parch_scale=scaler.fit(cont_df[\u0026#39;Parch\u0026#39;].values.reshape(-1,1)) cont_df[\u0026#39;Parch_scaled\u0026#39;]=scaler.fit_transform(cont_df[\u0026#39;Parch\u0026#39;].values.reshape(-1,1),parch_scale) cont_df.drop([\u0026#39;Age\u0026#39;,\u0026#39;Fare\u0026#39;,\u0026#39;SibSp\u0026#39;,\u0026#39;Parch\u0026#39;],axis=1,inplace=True) cont_df.head(3) cont_df.hist df_train=pd.concat([data_train[\u0026#39;Survived\u0026#39;],cate_onehot_df,cont_df],axis=1) df_train.head(3)from sklearn import linear_model y=df_train[\u0026#39;Survived\u0026#39;] X=df_train.drop([\u0026#39;Survived\u0026#39;],axis=1) from sklearn.model_selection import train_test_split X_train,X_validation,Y_train,Y_validation = \\ train_test_split(X,y,test_size=0.3,random_state=1) LR=linear_model.LogisticRegression(C=1.0,penalty=\u0026#39;l2\u0026#39;,tol=1e-6,solver=\u0026#39;lbfgs\u0026#39;) LR.fit(X_train,Y_train) y_predict=LR.predict(X_validation) y_predict_prob=LR.predict_proba(X_validation)[:,1] from sklearn.metrics import classification_report print(\u0026#39;查准率、查全率、F1值：\u0026#39;) print(classification_report(Y_validation,y_predict,target_names=None)) from sklearn.metrics import accuracy_score print(\u0026#39;预测准确率：\u0026#39;) print(accuracy_score(Y_validation,y_predict)) print(\u0026#39;精确到小数点后4位：{:.4f}\u0026#39;.format(accuracy_score(Y_validation,y_predict))) from sklearn.metrics import roc_auc_score print(\u0026#39;AUC值：\u0026#39;) print((roc_auc_score(Y_validation,y_predict_prob))) print(\u0026#39;精确到小数点后6位：{:.6f}\u0026#39;.format(roc_auc_score(Y_validation,y_predict_prob))) from sklearn.metrics import confusion_matrix print(\u0026#39;混淆矩阵\u0026#39;) print(confusion_matrix(Y_validation,y_predict,labels=None)) feature=list(df_train.columns[1:]) weight=LR.coef_[0] df=pd.DataFrame({\u0026#39;feature\u0026#39;:feature,\u0026#39;weight\u0026#39;:weight}) print(df) ","date":"2020-10-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%AE%9E%E9%AA%8C/","title":"机器学习 - 逻辑回归实验"},{"content":"简单工厂模式 和 工厂方法模式 简单工厂模式 简单工厂模式概念 简单工厂模式并不属于GoF的23种经典设计模式，但通常将它作为学习其他工厂模式的基础。\n简单工厂模式（Simple Factory Pattern）： 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。\n简单工厂模式结构 简单工厂模式结构： 简单工厂模式的结构比较简单，其核心是工厂类的设计。\n（1）Factory（工厂角色）： 工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n（2）Product（抽象产品角色）： 它是工厂类创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n（3）ConcreteProduct（具体产品角色）： 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n简单工厂模式实现 典型的抽象产品类代码如下：\n1 2 3 4 5 6 7 8 9 public abstract class Product { //所有产品类的公共业务方法 public void methhodSame() { //公共方法的实现 } //声明抽象业务方法 public abstract void methodDiff(); } 典型的具体产品类的代码如下：\n1 2 3 4 5 6 public class ConcreteProduct extends Product { //实现业务方法 public void methodDiff() { //业务方法实现 } } 典型的工厂类的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Factory { //静态工厂方法 public static Product getProduct(String arg) { Product product = null; if (arg.equalsIgnoreCase(\u0026#34;A\u0026#34;)) { product = new ConcreteProductA(); //初始化设置product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)) { product = new ConcreteProductB(); //初始化设置product } return product; } } 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：\n1 2 3 4 5 6 7 8 public class Client { public static void main(String[] args) { Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;);//通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 简单工厂模式优缺点和适用环境 简单工厂模式优点\n（1）工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。\n（2）客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度上减少使用者的记忆量。\n（3）通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。\n简单工厂模式缺点\n（1）由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。\n（2）使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的负责度和理解程度。\n（3）系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n（4）简单工厂模式由于使用静态工厂方法，造成工厂角色无法形成基于继承的等级结构。\n简单工厂模式适用环境\n（1）工厂类负责创建的对象比较少，由于创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑过于复杂。\n（2）客户端只知道传入工厂类的参数，对于如何创建对象并不关心。\n工厂方法模式 工厂方法模式概念 在工厂方法模式中不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个与产品等级结构对应的工厂等级结构。\n工厂方法模式： 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。\n工厂方法模式结构 工厂方法模式结构： 工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。\n（1）Product（抽象产品）： 它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。\n（2）ConcreteProduct（具体产品）： 它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n（3）Factory（抽象工厂）： 在抽象工厂类中声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n（4）ConcreteFactory（具体工厂）： 它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n工厂方法模式实现 与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：\n1 2 3 public interface Factory { public Product factoryMethod(); } 在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时再指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：\n1 2 3 4 5 public class ConcreteFactory implements Factory { public Product factoryMethod() { return new ConcreteProduct(); } } 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。\n在客户端代码中，开发人员只需关心工厂类即可，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：\n1 2 3 4 5 6 ··· Factory factory; factory = new ConcreteFactory(); Product product; product = factory.factoryMethod(); ··· 可以通过配置文件来存储具体工厂类ConcreteFactory的类名，再通过反射机制创建具体工厂对象，在更换新的具体工厂时无须修改源代码，系统扩展更为方便。\n工厂方法模式优缺点和适用环境 工厂方法模式优点\n（1）在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。\n（2）基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类。\n（3）使用工厂方法模式的另一个优先是在系统中加入新产品时无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样系统的可扩展性也就变的非常好，完全符合开闭原则。\n工厂方法模式缺点\n（1）在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。\n（2）由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。\n工厂方法模式适用环境\n（1）客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中。\n（2）抽象工厂类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时子类对象将覆盖父类对象，从而使得系统更容易扩展。\n“简单工厂模式”和“工厂方法模式”区别 （1）简单工厂模式在需要增加新的产品类时困难，需要改变原有的代码，不符合开闭原则；而工厂方法模式在增加新的产品类时不需要改变原有代码，完全符合开闭原则。\n（2）工厂方法模式比简单工厂模式更复杂，更抽象，更耗费系统资源，更难以理解。\n（3）简单工厂模式中工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统都会受到影响；而工厂方法模式将职责分化到每个工厂类，降低了每个类的职责。\n","date":"2020-09-10T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E5%92%8C-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","title":"简单工厂模式 和 工厂方法模式"},{"content":"切换eclipse后出现菜单栏乱码问题 问题 今天切换了eclipse的工作目录\n打开后发现出现了菜单栏乱码问题\neclipse打开是这样的：\n发现菜单栏都变成乱码了\n解决办法 解决办法：打开Window - Preferences - General - Appearance\n修改右边的Theme为Windows Classic\n然后点Apply或者Apply and Close就好了。\n","date":"2020-09-07T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%88%87%E6%8D%A2eclipse%E5%90%8E%E5%87%BA%E7%8E%B0%E8%8F%9C%E5%8D%95%E6%A0%8F%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","title":"切换eclipse后出现菜单栏乱码问题"},{"content":"eclipse中安装和使用AmaterasUML插件绘制类图 安装GEF插件 打开eclipse官网 https://www.eclipse.org/ 点击Projects，搜索GEF 点击右边的Download 在弹出的窗口中，复制下载地址 现在的地址是：http://download.eclipse.org/tools/gef/updates/releases\n打开eclipse，点击上方Help，选择install new software，粘贴复制的地址，点击Add，插件名字可以为空 选择Select All（不知道需要那个，全部安装也不大），然后一直Next和accept就好了 安装AmaterasUML插件 下载AmaterasUML_1.3.4 下载地址：AmaterasUML_1.3.4\n也可以去官网下载最新版本的AmaterasUML\n下载好了之后解压，解压出来有3个jar包，复制到eclipse安装目录的plugins目录下，重启eclipse 通过Window-Preference可以看到AmaterasUML AmaterasUML的简单使用 右键单击一个工程，New-Other，选择Class Diagram，然后点击Next 给类图取一个名字，然后点击Finish 然后拖动类或接口到界面中，类就华丽的出现了 ","date":"2020-09-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/eclipse%E4%B8%AD%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8amaterasuml%E6%8F%92%E4%BB%B6%E7%BB%98%E5%88%B6%E7%B1%BB%E5%9B%BE/","title":"eclipse中安装和使用AmaterasUML插件绘制类图"},{"content":"题目 1072: 汽水瓶 时间限制: 1Sec 内存限制: 128MB\n题目描述 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？\n输入 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1\u0026lt;=n\u0026lt;=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。\n输出 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。\n样例输入 1 2 3 4 3 10 81 0 样例输出 1 2 3 1 5 40 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; int drink(int k) { int s = 0, d = 0; while(s != 2 \u0026amp;\u0026amp; s != 1){ s = k%3 + k/3; d += k/3; k = s; } if(s == 2) return ++d; else return d; } int main(void) { int n, i=0; int a[100]; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)){ if( n == 0) break; a[i] = drink(n); i++; } for(int j=0;j\u0026lt;i;j++) printf(\u0026#34;%d\\n\u0026#34;,a[j]); return 0; } 通过C语言网编译运行 ","date":"2020-07-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1072-%E6%B1%BD%E6%B0%B4%E7%93%B6-c%E8%AF%AD%E8%A8%80/","title":"题目 1072 汽水瓶 (C语言)"},{"content":"题目 1157: 亲和数 时间限制: 1Sec 内存限制: 128MB\n题目描述 古希腊数学家毕达哥拉斯在自然数研究中发现，220的所有真约数(即不是自身的约数)之和为：\n1+2+4+5+10+11+20+22+44+55+110＝284。\n而284的所有真约数为1、2、4、71、 142，加起来恰好为220。人们对这样的数感到很惊奇，并称之为亲和数。一般地讲，如果两个数中任何一个数都是另一个数的真约数之和，则这两个数就是亲和数。 你的任务就编写一个程序，判断给定的两个数是否是亲和数\n输入 输入数据第一行包含一个数M，接下有M行，每行一个实例,包含两个整数A,B； 其中 0 ＜＝A,B ＜＝600000 ;\n输出 对于每个测试实例，如果A和B是亲和数的话输出YES，否则输出NO。\n样例输入 1 2 3 2 220 284 100 200 样例输出 1 2 YES NO C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;stdio.h\u0026gt; int main() { int M,m,a[10000],b[10000],c[10000],sum_a,sum_b,j; scanf(\u0026#34;%d\u0026#34;,\u0026amp;M); m = M; while(m) { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a[m],\u0026amp;b[m]); m--; } for(m=1;m\u0026lt;=M;m++) { sum_a = 0; sum_b = 0; for(j=1;j\u0026lt;a[m];j++) { if(a[m]%j == 0) sum_a+=j; } for(j=1;j\u0026lt;b[m];j++) { if(b[m]%j == 0) sum_b+=j; } //\tprintf(\u0026#34;a=%d\\tb=%d\\n\u0026#34;,a[m],b[m]); //\tprintf(\u0026#34;suma=%d\\tsumb=%d\u0026#34;,sum_a,sum_b); if((sum_a==b[m])\u0026amp;\u0026amp;(sum_b==a[m])) c[m]=1; else c[m]=0; //\tprintf(\u0026#34;\\n%d\u0026#34;,c[m]); } for(j=M;j\u0026gt;=1;j--) { if(c[j]==1) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } 通过C语言网编译运行 ","date":"2020-07-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1157-%E4%BA%B2%E5%92%8C%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1157 亲和数 (C语言)"},{"content":"题目 1393: 钟神赛车 时间限制: 1Sec 内存限制: 128MB\n题目描述 钟神近来编码劳累，想骑车风光一番，于是找某君骑自行车比赛。已知某君和钟神的每辆自行车的速度，钟神赢一场得50银两银子，输一场赔50银两，平局不挣也不赔。钟神可以随意安排高中低档自行车的出场数序，假设钟神体力无限无损耗求钟神最多能挣多少钱\n输入 多行测试数据，每行包含一个整数n和2n个32位正整数，第一个n表示自行车的数量，之后的n个32位整数表示某君自行车的速度，最后的n个32位整数表示钟神的自行车的速度\n输出 钟神可以随意安排自行车的出场数序。输出钟神最多能挣多少钱，结果一定在32位整数的范围内\n样例输入 1 2 3 2 1 3 2 2 3 3 2 1 3 1 1 3 样例输出 1 2 50 0 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;stdio.h\u0026gt; void pai(int *a,int n) { int i,j,x; for(i=1;i\u0026lt;=n;i++) { for(j=0;j\u0026lt;n-1;j++) { if(a[j]\u0026lt;a[j+1]) { x=a[j];a[j]=a[j+1];a[j+1]=x; } } } } int main() { int t[1000+22],q[1000+22]; int n,i,j,k,s,win,lose; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { k=0;win=0,lose=0; for(i=0;i\u0026lt;n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;q[i]); for(i=0;i\u0026lt;n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;t[i]); pai(q,n);pai(t,n); while(k\u0026lt;n) { for(i=0;i\u0026lt;n-k;i++) { if(t[0]\u0026gt;q[i]) { for(s=0;s\u0026lt;n-k-1;s++) t[s]=t[s+1]; for(s=i;s\u0026lt;n-k-1;s++) q[s]=q[s+1]; k++; win++; break; } else if((i==n-k-1)\u0026amp;\u0026amp;t[0]==q[i]) { for(s=0;s\u0026lt;n-k-1;s++) t[s]=t[s+1]; k++; break; } else if((i==n-k-1)\u0026amp;\u0026amp;t[0]\u0026lt;q[i]) { lose=i+1; k=n; break; } } } printf(\u0026#34;%d\\n\u0026#34;,50*(win-lose)); } } 通过C语言网编译运行 ","date":"2020-07-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1393-%E9%92%9F%E7%A5%9E%E8%B5%9B%E8%BD%A6-c%E8%AF%AD%E8%A8%80/","title":"题目 1393 钟神赛车 (C语言)"},{"content":"题目 1537: [算法提高VIP]栅格打印问题 时间限制: 1Sec 内存限制: 128MB\n题目描述 编写一个程序，输入两个整数，作为栅格的高度和宽度，然后用“+”、“-”和“|”这三个字符来打印一个栅格。\n输入 输入只有一行，包括两个整数，分别为栅格的高度和宽度。\n输出 输出相应的栅格。\n样例输入 1 3 2 样例输出 1 2 3 4 5 6 7 +-+-+ | | | +-+-+ | | | +-+-+ | | | +-+-+ C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;stdio.h\u0026gt; int main() { int L,H; int i,j; while(scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;H,\u0026amp;L)!=EOF) { if(H\u0026lt;=0||L\u0026lt;=0) break;//小提示：有道友没过就是没加类似判断（本人第一次没加也没过） for(i=0;i\u0026lt;H;i++) { for(j=0;j\u0026lt;=L;j++) { if(j!=L) printf(\u0026#34;+-\u0026#34;); else putchar(\u0026#39;+\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); for(j=0;j\u0026lt;=L;j++) { if(j!=L) printf(\u0026#34;| \u0026#34;); else putchar(\u0026#39;|\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); } for(j=0;j\u0026lt;=L;j++)//封底 { if(j!=L) printf(\u0026#34;+-\u0026#34;); else putchar(\u0026#39;+\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); } return 0; } 通过C语言网编译运行 ","date":"2020-07-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1537-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98vip%E6%A0%85%E6%A0%BC%E6%89%93%E5%8D%B0%E9%97%AE%E9%A2%98-c%E8%AF%AD%E8%A8%80/","title":"题目 1537 [算法提高VIP]栅格打印问题 (C语言)"},{"content":"Web前端开发技术课程大作业 作业要求 网站前端程序不仅要能够把用户要求的内容呈现出来，还要满足布局良好、界面美观、配色优雅、表现形式多样等要求。 为此，本次作业的要求主要有：\n（1）登录功能。登陆是对用户的验证，防止非法用户登陆和使用。\n（2）注册功能。注册是对新用户的加入设定的，可以增加游戏用户。\n（3）导航功能。提供完整的系统导航功能，帮助用户快速定位到需要浏览的区域。\n（4）广告轮播。广告轮播实现了重要客户的主要产品核心位置展示功能。\n（5）搜索入口。搜索功能提供客户搜索定位功能，可以帮助客户快速找到需要的产品。\n最终界面 代码 index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;英雄联盟\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;LOL,腾讯游戏,英雄联盟\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;LOL,腾讯游戏,英雄联盟\u0026#34; /\u0026gt; \u0026lt;link href=\u0026#34;css/index.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/qiehuan.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/switchpic.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;init();\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;topNavBar\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;搜索\u0026#34; id=\u0026#34;where\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;logon.html\u0026#34; class=\u0026#34;nav_on\u0026#34;\u0026gt;注册\u0026lt;/a\u0026gt; \u0026amp;nbsp; \u0026lt;a href=\u0026#34;login.html\u0026#34; class=\u0026#34;nav_on\u0026#34;\u0026gt;登录\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;header\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;img/lol_logo.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;menu_out\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;menu_in\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;nav\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a class=\u0026#34;nav_on\u0026#34; id=\u0026#34;mynav0\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(0)\u0026#34; href=\u0026#34;#\u0026#34; target=\u0026#34;framebody\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏资料\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(1)\u0026#34; id=\u0026#34;mynav1\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏商城\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(2)\u0026#34; id=\u0026#34;mynav2\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏合作\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(3)\u0026#34; id=\u0026#34;mynav3\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;社区互动\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(4)\u0026#34; id=\u0026#34;mynav4\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;赛事官网\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(5)\u0026#34; id=\u0026#34;mynav5\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;自助系统\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(6)\u0026#34; id=\u0026#34;mynav6\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(7)\u0026#34; id=\u0026#34;mynav7\u0026#34; class=\u0026#34;nav_off\u0026#34;\u0026gt;\u0026lt;span\u0026gt;填写问卷\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a class=\u0026#34;nav_off\u0026#34; id=\u0026#34;mynav8\u0026#34; onmouseover=\u0026#34;javascript:qiehuan(8)\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;关于网站\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;div id=\u0026#34;menu_con\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;qh_con0\u0026#34; style=\u0026#34;display: block\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏下载\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;游戏指引\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;./web_first.html\u0026#34; target=\u0026#34;block\u0026#34;\u0026gt;\u0026lt;span\u0026gt;资料库\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;云顶之弈\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;攻略中心\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con1\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;点卷充值\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;道具城\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;周边商城\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con2\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;LOL桌游\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;LOL信用卡\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;网吧特权\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;电竞小说\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con3\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;官方社区\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;视频中心\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;官方论坛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;官方微信\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;官方微博\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con4\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;LPL职业联赛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;LDL发展联赛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;全球总决赛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;全明星赛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;季中杯\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;德玛西亚杯\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;全国高校联赛\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con5\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;转区系统\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;封号查询\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;账号注销\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;信誉分系统\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con6\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;推荐视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;官方视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;娱乐视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;赛事视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;云顶之弈视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;教学视频\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con7\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;web_question.html\u0026#34; target=\u0026#34;block\u0026#34;\u0026gt;\u0026lt;span\u0026gt;填写问卷\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;qh_con8\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;联系客服\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;menu_line2\u0026#34;\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;span\u0026gt;网站作者\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;top\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;\u0026lt;img id=\u0026#34;pic\u0026#34; src=\u0026#34;img/example1.jpg\u0026#34; border=\u0026#34;0\u0026#34; alt=\u0026#34;\u0026#34; onmouseover=\u0026#34;pause();\u0026#34; onmouseout=\u0026#34;reStart();\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;down\u0026#34; class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;iframe name=\u0026#34;framebody\u0026#34; src=\u0026#34;web_first.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;strong\u0026gt;友情链接：\u0026lt;/strong\u0026gt; \u0026lt;select size=\u0026#34;1\u0026#34; name=\u0026#34;d1\u0026#34; onchange=\u0026#34;window.open(this.options[this.selectedindex].value)\u0026#34;\u0026gt; \u0026lt;option\u0026gt; 知名游戏厂家\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://game.qq.com/portal2010/about.htm\u0026#34;\u0026gt;腾讯游戏\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://www.activisionblizzard.com/\u0026#34;\u0026gt;动视暴雪\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://www.microsoft.com/zh-cn/\u0026#34;\u0026gt;微软游戏工作室\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://www.apple.com.cn/\u0026#34;\u0026gt;苹果\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://www.sony.com.cn/\u0026#34;\u0026gt;索尼\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;select size=\u0026#34;1\u0026#34; name=\u0026#34;d1\u0026#34; onchange=\u0026#34;window.open(this.options[this.selectedindex].value)\u0026#34;\u0026gt; \u0026lt;option\u0026gt; 优秀游戏连接\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://pubg.qq.com/\u0026#34;\u0026gt;绝地求生\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://dnf.qq.com/\u0026#34;\u0026gt;地下城与勇士\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;http://www.m3guo.com/v2/\u0026#34;\u0026gt;梦三国\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://wow.blizzard.cn/landing\u0026#34;\u0026gt;魔兽世界\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://xyq.163.com/\u0026#34;\u0026gt;梦幻西游\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;https://wuxia.qq.com/\u0026#34;\u0026gt;天涯明月刀\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; 腾讯游戏\u0026amp;nbsp;·\u0026amp;nbsp;英雄联盟\u0026amp;nbsp;\u0026amp;nbsp;LOL 1998-2020\u0026amp;copy;保留所有权利，未经允许不得复制、镜像\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; login.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登陆界面\u0026lt;/title\u0026gt; \u0026lt;link href=\u0026#34;css/login.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;dowebok\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;logo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-item\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;username\u0026#34; type=\u0026#34;text\u0026#34; autocomplete=\u0026#34;off\u0026#34; placeholder=\u0026#34;账号\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-item\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; autocomplete=\u0026#34;off\u0026#34; placeholder=\u0026#34;登录密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;index.html\u0026#34;\u0026gt;\u0026lt;button id=\u0026#34;submit\u0026#34;\u0026gt;登 录\u0026lt;/button\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; index.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @charset \u0026#34;utf-8\u0026#34;; * { font-size: 12px; font-family: Arial, Helvetica, sans-serif; } body { margin: 0px auto; padding: 0px; text-align: center; position: relative; } #topNavBar { position: absolute; margin-left: 290px; font-size: 20px; } #topNavBar a { font-size: 12px; } #topNavBar a:link { color: white; text-decoration: none; } #topNavBar a:visited { color: white; text-decoration: none; } #topNavBar a:hover { color: white; text-decoration: none; } #topNavBar a:active { color: white; text-decoration: none; } #where { margin-right: 660px; } #container { width: 960px; padding: 0 auto; margin: 0 auto; } img { width: 960px; height: auto; } #menu ul { padding: 0; border: 0; list-style: none; line-height: 150%; margin-top: 0; margin-right: 0; margin-bottom: 0; margin-left: 40px; } #menu li { color: white; } #menu_out { width: 960px; padding-left: 4px; margin-left: auto; margin-right: auto; background: url(\u0026#34;../img/menu_left.gif\u0026#34;) no-repeat left top; overflow: hidden; /* ����������� */ } #menu_in { background: url(\u0026#34;../img/menu_right.gif\u0026#34;) no-repeat right top; padding-right: 4px; } #menu { background: url(\u0026#34;../img/menu_bg.gif\u0026#34;) repeat-x; height: 73px; width: 960px; } .menu_line { background: url(\u0026#34;../img/menu_line.gif\u0026#34;) no-repeat center top; width: 8px; } .menu_line2 { background: url(\u0026#34;../img/menu_line2.gif\u0026#34;) no-repeat center top; width: 15px; } #nav { padding-left: 20px; width: 960px; } #nav li { float: left; height: 35px; } #nav li a { float: left; display: block; padding-left: 6px; height: 35px; background: url(\u0026#34;../img/menu_on_left.gif\u0026#34;) no-repeat left top; cursor: pointer; text-decoration: none; } #nav li a span { float: left; padding: 11px 14px 10px 10px; line-height: 14px; background: url(\u0026#34;../img/menu_on_right.gif\u0026#34;) no-repeat right top; font-size: 14px; font-weight: bold; color: #FFFFFF; text-decoration: none; } #nav li .nav_on { background-position: left 100%; } #nav li .nav_on span { background-position: right 100%; color: #333333; text-decoration: none; padding: 14px 14px 7px 10px; } #menu_con { text-align: left; padding-left: 20px; clear: both; } #menu_con li { float: left; height: 22px; margin-top: 8px; } #menu_con li a { display: block; float: left; background: url(\u0026#34;../img/menu_on_left2.gif\u0026#34;) no-repeat left top; cursor: pointer; padding-left: 3px; } #menu_con li a span { float: left; padding: 6px 10px 4px 10px; line-height: 12px; background: url(\u0026#34;../img/menu_on_right2.gif\u0026#34;) no-repeat right top; color: black; } #menu_con li a:hover { text-decoration: none; background: url(\u0026#34;../img/menu_on_left2.gif\u0026#34;) no-repeat left bottom; } #menu_con li a:hover span { background: url(\u0026#34;../img/menu_on_right2.gif\u0026#34;) no-repeat right bottom; } #main { width: 960px; height: 300px; } #top { width: 960px; height: auto; border: 1px solid white; } #top img { width: 960px; height: 489px; } #down { width: 960px; height: 500px; margin: 0 auto; } #down iframe { width: 960px; height: 500px; border: 0px; padding: 0px; margin: 0px; } .bottom { clear: both; height: 80px; background: #000000; text-align: center; padding-top: 20px; color: white; font-size: 18px; width: 960px; margin-top: 694px; /* please */ } .bottom ul { list-style: none; color: white; } login.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 * { margin: 0; padding: 0; } html { height: 100%; } body { height: 100%; background: #fff url(../img/example1.jpg) 50% 50% no-repeat; background-size: cover; } .dowebok { position: absolute; left: 50%; top: 50%; width: 430px; height: 550px; margin: -300px 0 0 -215px; border: 1px solid #fff; border-radius: 20px; overflow: hidden; } .logo { width: 200px; height: 100px; margin-top: 130px; margin-bottom: 70px; margin-left: 130px; background: url(../img/logo-public.png) 0 0 no-repeat; } .form-item { position: relative; width: 360px; margin: 0 auto; padding-bottom: 30px; } .form-item input { width: 288px; height: 48px; padding-left: 70px; border: 1px solid #fff; border-radius: 25px; font-size: 18px; color: #fff; background-color: transparent; outline: none; } .form-item button { width: 360px; height: 50px; border: 0; border-radius: 25px; font-size: 18px; color: #1f6f4a; outline: none; cursor: pointer; background-color: #fff; } .tip { display: none; position: absolute; left: 20px; top: 52px; font-size: 14px; color: #f50; } .reg-bar { width: 360px; margin: 20px auto 0; font-size: 14px; overflow: hidden; } .reg-bar a { color: #fff; text-decoration: none; } .reg-bar a:hover { text-decoration: underline; } .reg-bar .reg { float: left; } .reg-bar .forget { float: right; } .dowebok ::-webkit-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff; } .dowebok :-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff; } .dowebok ::-moz-placeholder { font-size: 18px; line-height: 1.4; color: #fff; } .dowebok :-ms-input-placeholder { font-size: 18px; line-height: 1.4; color: #fff; } @media screen and (max-width: 500px) { * { box-sizing: border-box; } .dowebok { position: static; width: auto; height: auto; margin: 0 30px; border: 0; border-radius: 0; } .logo { margin: 50px auto; } .form-item { width: auto; } .form-item input, .form-item button, .reg-bar { width: 100%; } } swithpic.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /* switchpic.js */ var CurScreen = 1; var MaxScreen = 7; var timer = null; function $(id) { return document.getElementById(id); } function switchPic() { if (CurScreen == MaxScreen) { CurScreen = 1; } else { CurScreen++; } $(\u0026#34;pic\u0026#34;).src = \u0026#34;img/example\u0026#34; + CurScreen + \u0026#34;.jpg\u0026#34;; } function reStart() { switchPic(); init(); } function pause() { clearInterval(timer); } function init() { timer = setInterval(\u0026#39;switchPic();\u0026#39;, 1000); } csdn 链接 Web前端开发技术课程大作业\n","date":"2020-07-27T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B%E5%A4%A7%E4%BD%9C%E4%B8%9A/","title":"Web前端开发技术课程大作业"},{"content":"计算机视觉 - 实验十六 用高斯背景建模分离背景实验 实验目的和要求 理解背景建模的基本原理；掌握实现背景建模的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用VideoCapture类打开视频；\n（四）创建高斯混合模型；\n（五）通过更新打开的视频的每一帧图像，对高斯混合模型进行更新;\n（六）展示前景图像和背景图像。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio2015。\n实验原理 （一）在很多情况下，我们需要从一段视频或者一系列图片中找到感兴趣的目标，比如说当人进入已经打烊的超市时发出警报。为了达到这个目的，我们首先需要“学习”背景模型，然后将背景模型和当前图像进行比较，从而得到前景目标。\n（二）背景与前景都是相对的概念，以高速公路为例：有时我们对高速公路上来来往往的汽车感兴趣，这时汽车是前景，而路面以及周围的环境是背景；有时我们仅仅对闯入高速公路的行人感兴趣，这时闯入者是前景，而包括汽车之类的其他东西又成了背景。各种背景模型都有自己适用的场合。\n（三）高斯混合模型(MOG)是OpenCv实现的一种高级的背景统计模型。高斯模型就是用高斯概率密度函数(正态分布曲线)精确地量化事物，将一个事物分解为若干的基于高斯概率密度函数(正态分布曲线)形成的模型。 对图像背景建立高斯模型的原理及过程:图像灰度直方图反映的是图像中某个灰度值出现的频次，也可以以为是图像灰度概率密度的估计。如果图像所包含的目标区域和背景区域相差比较大，且背景区域和目标区域在灰度上有一定的差异，那么该图像的灰度直方图呈现双峰-谷形状，其中一个峰对应于目标，另一个峰对应于背景的中心灰度。对于复杂的图像，尤其是医学图像，一般是多峰的。通过将直方图的多峰特性看作是多个高斯分布的叠加，可以解决图像的分割问题。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）调用VideoCapture的open函数打开视频；\n（四）调用BackgroundSubtractorMOG2类创建高斯混合模型；\n（五）调用VideoCapture类的“\u0026raquo;”方法读取视频中的一帧图像；\n（六）通过更新打开的视频的每一帧图像，对高斯混合模型进行更新，调用getBackgroundImage函数获取背景图像;\n（七）调用imshow函数展示前景图像和背景图像。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）VideoCapture类的功能和使用方法；\n（三）BackgroundSubtractorMOG2类的功能和使用方法；\n（四）getBackgroundImage函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //----------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/core/core.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026#34;opencv2/video/background_segm.hpp\u0026#34; #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026lt;stdio.h\u0026gt; using namespace std; using namespace cv; //-------------------------【help( )函数】-------------------------------------- //\t描述：输出一些帮助信息 //---------------------------------------------------------------------------------- static void help() { printf(\u0026#34;\\n\\n\\n\\t此程序展示了用高斯背景建模进行视频的背景分离方法.\\n\\n\\t主要采用cvUpdateBGStatModel()函数\\n\u0026#34; \u0026#34;\\n\\t程序首先会“学习背景”，然后进行分割。\\n\u0026#34; \u0026#34;\\n\\t可以用过【Space】空格进行功能切换。\\n\\n\u0026#34;); } //---------------------------【main( )函数】-------------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main(int argc, const char** argv) { help(); VideoCapture cap; bool update_bg_model = true; cap.open(\u0026#34;1.avi\u0026#34;); if( !cap.isOpened() ) { printf(\u0026#34;can not open camera or video file\\n\u0026#34;); return -1; } namedWindow(\u0026#34;image\u0026#34;, WINDOW_AUTOSIZE); namedWindow(\u0026#34;foreground mask\u0026#34;, WINDOW_AUTOSIZE); namedWindow(\u0026#34;foreground image\u0026#34;, WINDOW_AUTOSIZE); namedWindow(\u0026#34;mean background image\u0026#34;, WINDOW_AUTOSIZE); BackgroundSubtractorMOG2 bg_model;//(100, 3, 0.3, 5); Mat img, fgmask, fgimg; for(;;) { cap \u0026gt;\u0026gt; img; if( img.empty() ) break; //cvtColor(_img, img, COLOR_BGR2GRAY); if( fgimg.empty() ) fgimg.create(img.size(), img.type()); //更新模型 bg_model(img, fgmask, update_bg_model ? -1 : 0); fgimg = Scalar::all(0); img.copyTo(fgimg, fgmask); Mat bgimg; bg_model.getBackgroundImage(bgimg); imshow(\u0026#34;image\u0026#34;, img); imshow(\u0026#34;foreground mask\u0026#34;, fgmask); imshow(\u0026#34;foreground image\u0026#34;, fgimg); if(!bgimg.empty()) imshow(\u0026#34;mean background image\u0026#34;, bgimg ); char k = (char)waitKey(30); if( k == 27 ) break; if( k == \u0026#39; \u0026#39; ) { update_bg_model = !update_bg_model; if(update_bg_model) printf(\u0026#34;\\t\u0026gt;背景更新(Background update)已打开\\n\u0026#34;); else printf(\u0026#34;\\t\u0026gt;背景更新(Background update)已关闭\\n\u0026#34;); } } return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解背景建模的基本原理；掌握实现背景建模的代码编写方法。新建工程；在VS2015中配置OpenCV；使用VideoCapture类打开视频；创建高斯混合模型；通过更新打开的视频的每一帧图像，对高斯混合模型进行更新；展示前景图像和背景图像。\n","date":"2020-06-12T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD-%E7%94%A8%E9%AB%98%E6%96%AF%E8%83%8C%E6%99%AF%E5%BB%BA%E6%A8%A1%E5%88%86%E7%A6%BB%E8%83%8C%E6%99%AF%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十六 用高斯背景建模分离背景实验"},{"content":"计算机视觉 - 实验十五 对视频的快速角点检测实验 实验目的和要求 理解角点检测的基本原理；掌握实现角点检测的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用VideoCapture类打开视频文件；\n（四）读取视频中的一帧图像；\n（五）转换灰度图并检测角点;\n（六）遍历每个点，进行绘制，在原图中显示角点。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio2015。\n实验原理 （一）角点检测是计算机视觉系统中用来获得图像特征的-种方法。角点通常被定义为两条边的交点，更严格地说法是，角点的局部邻域应该具有两个不同区域的不同方向的边界。而实际应用中，大多数所谓的角点检测方法检测的是拥有特定特征的图像点，而不仅仅是“角点”。这些特征点在图像中有具体的坐标，并具有某些数学特征，如局部最大或最小灰度等；\n（二）角点被大量用于解决物体识别、图像识别、图像匹配、视觉跟踪、三维重建等一系列的问题。我们不再观察整幅图，而是选择某些特殊的点，然后对它们进行局部有的放矢地分析。如果能检测到足够多的这种点，同时它们的区分度很高，并且可以精确定位稳定的特征，那么这个方法就具有实用价值；\n（三）角点检测方法的一个很重要的评价标准是其对多幅图像中相同或相似特征的检测能力，并且能够应对光照变化、图像旋转等图像变化。Shi-Tomasi算法是Harris算法的改进,本实验通过播放一段视频，展示对于视频中同一目标，Shi-Tomasi算法得到的角点具有很强的健壮性。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）调用VideoCapture类的open函数打开视频；\n（四）调用VideoCapture类的“\u0026raquo;”方法读取视频中的一帧图像；\n（五）调用cvtColor函数转换灰度图，调用goodFeaturesToTrack函数检测角点;\n（六）遍历每个点，调用circle在原图中进行绘制角点。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）VideoCapture类的功能和使用方法；\n（三）cvtColor函数的功能和使用方法；\n（四）goodFeaturesToTrack函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/calib3d/calib3d.hpp\u0026#34; #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026#34;opencv2/features2d/features2d.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; using namespace cv; //---------------------------------【help( )函数】-------------------------------------- //\t描述：输出一些帮助信息 //----------------------------------------------------------------------------------- int Harris(Mat \u0026amp;img) { Mat grayImage; //转换灰度图 cvtColor(img, grayImage, CV_BGR2GRAY); //开始进行角点检测 vector\u0026lt;Point2f\u0026gt; dstPoint2f; goodFeaturesToTrack(grayImage, dstPoint2f, 200, 0.01, 10, Mat(), 3); //遍历每个点，进行绘制，便于显示 //Mat dstImage; //img.copyTo(dstImage); for (int i = 0; i \u0026lt; (int)dstPoint2f.size(); i++) { circle(img, dstPoint2f[i], 3, Scalar(0,0,255), 2, 8); } return 0; } //---------------------------【main( )函数】-------------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main() { VideoCapture capture; capture.open(\u0026#34;1.avi\u0026#34;); if (!capture.isOpened()) { cout \u0026lt;\u0026lt; \u0026#34;capture device \u0026#34; \u0026lt;\u0026lt; \u0026#34; failed to open!\u0026#34; \u0026lt;\u0026lt; endl; return 1; } Mat frame; Mat gray; for (;;) { capture \u0026gt;\u0026gt; frame; if (frame.empty()) break; int h = frame.rows; int w = frame.cols; Harris(frame); imshow(\u0026#34;frame\u0026#34;, frame); waitKey(3); //延时30ms } return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解角点检测的基本原理；掌握实现角点检测的代码编写方法。新建工程；在VS2015中配置OpenCV；使用VideoCapture类打开视频文件；读取视频中的一帧图像；转换灰度图并检测角点；遍历每个点，进行绘制，在原图中显示角点。\n","date":"2020-06-10T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94-%E5%AF%B9%E8%A7%86%E9%A2%91%E7%9A%84%E5%BF%AB%E9%80%9F%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十五 对视频的快速角点检测实验"},{"content":"计算机视觉 - 实验十四 分水岭算法实验 实验目的和要求 理解分水岭算法的基本原理；掌握实现分水岭算法的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）载入原图并显示，初始化掩膜和灰度图；\n（四）寻找轮廓；\n（五）拷贝掩膜;\n（六）循环绘制出轮廓；\n（七）将分水岭图像遍历保存；\n（八）混合灰度图和分水岭效果图并显示最终的窗口。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio2015。\n实验原理 （一）在许多实际运用中，我们需要分割阁像，但无法从背景图像中获得有用信息。分水岭算法在这方面往往是非常有效的。此算法可以将图像中的边缘转化成“山脉”将均匀区域转化为“山谷”这样有助于分割目标。分水岭算法，是一种基于拓扑理论的数学形态学的分割方法，其基本思想是把图像看作是测地学上的拓扑地貌，图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值及其影响区域称为集水盆，而集水盆的边界则形成分水岭。分水岭的概念和形成可以通过模拟浸入过程来说明：在每一个局部极小值表面，刺穿一个小孔，然后把整个模型慢慢浸入水中，随着浸入的加深，每一个局部极小值的影响域慢慢向外扩展，在两个集水盆汇合处构筑大坝，即形成分水岭。\n（二）函数 watershed实现的分水岭算法是基于标记的分割算法中的一种。在把图像传给函数之前，我们需要大致勾画标记出图像中的期望进行分割的区域，它们被标记为正指数。所以，每一个区域都会被标记为像素值1、2、3等，表示成为一个或者多个连接组件。这些标记的值可以使用findContours函数和 drawContours函数由二进制的掩码检索出来。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）调用imread函数载入原图并显示，初始化掩膜和灰度图；\n（四）调用findContours函数寻找轮廓；\n（五）拷贝掩膜;\n（六）调用drawContours函数循环绘制出轮廓；\n（七）调用watershed函数计算分水岭，使用双层循环，将分水岭图像遍历保存；\n（八）混合灰度图和分水岭效果图并显示最终的窗口。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）watershed函数的功能和使用方法；\n（三）遍历保存分水岭图像的方法；\n（四）混合灰度图和分水岭效果图的方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 //---------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------------------ #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace cv; using namespace std; //-----------------------------------【宏定义部分】-------------------------------------------- // 描述：定义一些辅助宏 //------------------------------------------------------------------------------------------------ #define WINDOW_NAME1 \u0026#34;【程序窗口1】\u0026#34; //为窗口标题定义的宏 #define WINDOW_NAME2 \u0026#34;【分水岭算法效果图】\u0026#34; //为窗口标题定义的宏 //-----------------------------------【全局函变量声明部分】-------------------------------------- //\t描述：全局变量的声明 //----------------------------------------------------------------------------------------------- Mat g_maskImage, g_srcImage; Point prevPt(-1, -1); //-----------------------------------【全局函数声明部分】-------------------------------------- //\t描述：全局函数的声明 //----------------------------------------------------------------------------------------------- static void ShowHelpText(); static void on_Mouse( int event, int x, int y, int flags, void* ); //-----------------------------------【main( )函数】-------------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //----------------------------------------------------------------------------------------------- int main( int argc, char** argv ) {\t//【0】改变console字体颜色 system(\u0026#34;color 6F\u0026#34;); //【0】显示帮助文字 ShowHelpText( ); //【1】载入原图并显示，初始化掩膜和灰度图 g_srcImage = imread(\u0026#34;1.jpg\u0026#34;, 1); imshow( WINDOW_NAME1, g_srcImage ); Mat srcImage,grayImage; g_srcImage.copyTo(srcImage); cvtColor(g_srcImage, g_maskImage, COLOR_BGR2GRAY); cvtColor(g_maskImage, grayImage, COLOR_GRAY2BGR); g_maskImage = Scalar::all(0); //【2】设置鼠标回调函数 setMouseCallback( WINDOW_NAME1, on_Mouse, 0 ); //【3】轮询按键，进行处理 while(1) { //获取键值 int c = waitKey(0); //若按键键值为ESC时，退出 if( (char)c == 27 ) break; //按键键值为2时，恢复源图 if( (char)c == \u0026#39;2\u0026#39; ) { g_maskImage = Scalar::all(0); srcImage.copyTo(g_srcImage); imshow( \u0026#34;image\u0026#34;, g_srcImage ); } //若检测到按键值为1或者空格，则进行处理 if( (char)c == \u0026#39;1\u0026#39; || (char)c == \u0026#39; \u0026#39; ) { //定义一些参数 int i, j, compCount = 0; vector\u0026lt;vector\u0026lt;Point\u0026gt; \u0026gt; contours; vector\u0026lt;Vec4i\u0026gt; hierarchy; //寻找轮廓 findContours(g_maskImage, contours, hierarchy, RETR_CCOMP, CHAIN_APPROX_SIMPLE); //轮廓为空时的处理 if( contours.empty() ) continue; //拷贝掩膜 Mat maskImage(g_maskImage.size(), CV_32S); maskImage = Scalar::all(0); //循环绘制出轮廓 for( int index = 0; index \u0026gt;= 0; index = hierarchy[index][0], compCount++ ) drawContours(maskImage, contours, index, Scalar::all(compCount+1), -1, 8, hierarchy, INT_MAX); //compCount为零时的处理 if( compCount == 0 ) continue; //生成随机颜色 vector\u0026lt;Vec3b\u0026gt; colorTab; for( i = 0; i \u0026lt; compCount; i++ ) { int b = theRNG().uniform(0, 255); int g = theRNG().uniform(0, 255); int r = theRNG().uniform(0, 255); colorTab.push_back(Vec3b((uchar)b, (uchar)g, (uchar)r)); } //计算处理时间并输出到窗口中 double dTime = (double)getTickCount(); watershed( srcImage, maskImage ); dTime = (double)getTickCount() - dTime; printf( \u0026#34;\\t处理时间 = %gms\\n\u0026#34;, dTime*1000./getTickFrequency() ); //双层循环，将分水岭图像遍历存入watershedImage中 Mat watershedImage(maskImage.size(), CV_8UC3); for( i = 0; i \u0026lt; maskImage.rows; i++ ) for( j = 0; j \u0026lt; maskImage.cols; j++ ) { int index = maskImage.at\u0026lt;int\u0026gt;(i,j); if( index == -1 ) watershedImage.at\u0026lt;Vec3b\u0026gt;(i,j) = Vec3b(255,255,255); else if( index \u0026lt;= 0 || index \u0026gt; compCount ) watershedImage.at\u0026lt;Vec3b\u0026gt;(i,j) = Vec3b(0,0,0); else watershedImage.at\u0026lt;Vec3b\u0026gt;(i,j) = colorTab[index - 1]; } //混合灰度图和分水岭效果图并显示最终的窗口 watershedImage = watershedImage*0.5 + grayImage*0.5; imshow( WINDOW_NAME2, watershedImage ); } } return 0; } //-----------------------------------【onMouse( )函数】--------------------------------------- //\t描述：鼠标消息回调函数 //----------------------------------------------------------------------------------------------- static void on_Mouse( int event, int x, int y, int flags, void* ) { //处理鼠标不在窗口中的情况 if( x \u0026lt; 0 || x \u0026gt;= g_srcImage.cols || y \u0026lt; 0 || y \u0026gt;= g_srcImage.rows ) return; //处理鼠标左键相关消息 if( event == EVENT_LBUTTONUP || !(flags \u0026amp; EVENT_FLAG_LBUTTON) ) prevPt = Point(-1,-1); else if( event == EVENT_LBUTTONDOWN ) prevPt = Point(x,y); //鼠标左键按下并移动，绘制出白色线条 else if( event == EVENT_MOUSEMOVE \u0026amp;\u0026amp; (flags \u0026amp; EVENT_FLAG_LBUTTON) ) { Point pt(x, y); if( prevPt.x \u0026lt; 0 ) prevPt = pt; line( g_maskImage, prevPt, pt, Scalar::all(255), 5, 8, 0 ); line( g_srcImage, prevPt, pt, Scalar::all(255), 5, 8, 0 ); prevPt = pt; imshow(WINDOW_NAME1, g_srcImage); } } //-----------------------------------【ShowHelpText( )函数】---------------------------------- // 描述：输出一些帮助信息 //---------------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第77个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf( \u0026#34;\\n\\n\\n\\t欢迎来到【分水岭算法】示例程序~\\n\\n\u0026#34;); printf( \u0026#34;\\t请先用鼠标在图片窗口中标记出大致的区域，\\n\\n\\t然后再按键【1】或者【SPACE】启动算法。\u0026#34; \u0026#34;\\n\\n\\t按键操作说明: \\n\\n\u0026#34; \u0026#34;\\t\\t键盘按键【1】或者【SPACE】- 运行的分水岭分割算法\\n\u0026#34; \u0026#34;\\t\\t键盘按键【2】- 恢复原始图片\\n\u0026#34; \u0026#34;\\t\\t键盘按键【ESC】- 退出程序\\n\\n\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是理解分水岭算法的基本原理；掌握实现分水岭算法的代码编写方法。新建工程，在VS2015中配置OpenCV，载入原图并显示，初始化掩膜和灰度图，寻找轮廓，拷贝掩膜，循环绘制出轮廓，将分水岭图像遍历保存，混合灰度图和分水岭效果图并显示最终的窗口。\n","date":"2020-06-01T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B-%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十四 分水岭算法实验"},{"content":"计算机视觉 - 实验十三 轮廓形状分析实验 实验目的和要求 理解轮廓形状分析的基本原理；掌握实现轮廓形状分析的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）得到原图的灰度图像并进行平滑；\n（四）使用Threshold检测边缘；\n（五）找出轮廓;\n（六）多边形逼近轮廓，获取矩形和圆形边界框；\n（七）绘制多边形轮廓、包围的矩形框和圆形框。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015。\n实验原理 （一）在计算机视觉中，形状特征是描述高层视觉特征(如目标，对象)的重要手段。目标、对象对获取图像语义尤为重要，所以必须有好的形状特征的提取和描述算法。轮廓形状分析是提取形状特征的一种重要途径。\n（二）本实验首先找出目标轮廓，然后用指定精度逼近多边形曲线，接着计算点集的最外面矩形边界，寻找最小面积的包围圆形，最后绘制多边形轮廓、包围的矩形框、圆形框，比较提取的三种轮廓形状对目标对象的描述效果。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）得到原图的灰度图像并进行平滑；\n（四）使用OpenCV中的threshold函数二值化；\n（五）使用OpenCV中的findContours函数找出轮廓;\n（六）使用OpenCV中的approxPolyDP函数多边形逼近轮廓，使用OpenCV中的boundingRect函数获取矩形，使用OpenCV中的minEnclosingCircle函数圆形边界框；\n（七）使用OpenCV中的drawContours函数绘制多边形轮廓、使用OpenCV中的rectangle函数绘制包围的矩形框，使用OpenCV中的circle函数绘制包围的圆形框。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）threshold函数的功能和使用方法；\n（三）approxPolyDP函数的功能和使用方法；\n（四）rectangle函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 //---------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------------------ #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; using namespace cv; using namespace std; //-----------------------------------【宏定义部分】-------------------------------------------- // 描述：定义一些辅助宏 //------------------------------------------------------------------------------------------------ #define WINDOW_NAME1 \u0026#34;【原始图窗口】\u0026#34; //为窗口标题定义的宏 #define WINDOW_NAME2 \u0026#34;【效果图窗口】\u0026#34; //为窗口标题定义的宏 //-----------------------------------【全局变量声明部分】-------------------------------------- // 描述：全局变量的声明 //----------------------------------------------------------------------------------------------- Mat g_srcImage; Mat g_grayImage; int g_nThresh = 50;//阈值 int g_nMaxThresh = 255;//阈值最大值 RNG g_rng(12345);//随机数生成器 //-----------------------------------【全局函数声明部分】-------------------------------------- // 描述：全局函数的声明 //----------------------------------------------------------------------------------------------- void on_ContoursChange(int, void* ); static void ShowHelpText( ); //-----------------------------------【main( )函数】-------------------------------------------- // 描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //----------------------------------------------------------------------------------------------- int main( ) { //【0】改变console字体颜色 system(\u0026#34;color 1F\u0026#34;); //【0】显示欢迎和帮助文字 ShowHelpText( ); //【1】载入3通道的原图像 g_srcImage = imread( \u0026#34;2007_000837.jpg\u0026#34;, 1 ); if(!g_srcImage.data ) { printf(\u0026#34;读取图片错误，请确定目录下是否有imread函数指定的图片存在~！ \\n\u0026#34;); return false; } //【2】得到原图的灰度图像并进行平滑 cvtColor( g_srcImage, g_grayImage, COLOR_BGR2GRAY ); blur( g_grayImage, g_grayImage, Size(3,3) ); //【3】创建原始图窗口并显示 namedWindow( WINDOW_NAME1, WINDOW_AUTOSIZE ); imshow( WINDOW_NAME1, g_srcImage ); //【4】设置滚动条并调用一次回调函数 createTrackbar( \u0026#34; 阈值:\u0026#34;, WINDOW_NAME1, \u0026amp;g_nThresh, g_nMaxThresh, on_ContoursChange ); on_ContoursChange( 0, 0 ); waitKey(0); return(0); } //----------------------------【on_ContoursChange( )函数】--------------------------------- // 描述：回调函数 //------------------------------------------------------------------------------------------------- void on_ContoursChange(int, void* ) { //定义一些参数 Mat threshold_output; vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; contours; vector\u0026lt;Vec4i\u0026gt; hierarchy; // 使用Threshold检测边缘 threshold( g_grayImage, threshold_output, g_nThresh, 255, THRESH_BINARY ); // 找出轮廓 findContours( threshold_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) ); // 多边形逼近轮廓 + 获取矩形和圆形边界框 vector\u0026lt;vector\u0026lt;Point\u0026gt; \u0026gt; contours_poly( contours.size() ); vector\u0026lt;Rect\u0026gt; boundRect( contours.size() ); vector\u0026lt;Point2f\u0026gt;center( contours.size() ); vector\u0026lt;float\u0026gt;radius( contours.size() ); //一个循环，遍历所有部分，进行本程序最核心的操作 for( unsigned int i = 0; i \u0026lt; contours.size(); i++ ) { approxPolyDP( Mat(contours[i]), contours_poly[i], 3, true );//用指定精度逼近多边形曲线 boundRect[i] = boundingRect( Mat(contours_poly[i]) );//计算点集的最外面（up-right）矩形边界 minEnclosingCircle( contours_poly[i], center[i], radius[i] );//对给定的 2D点集，寻找最小面积的包围圆形 } // 绘制多边形轮廓 + 包围的矩形框 + 圆形框 //Mat drawing = Mat::zeros( threshold_output.size(), CV_8UC3 ); Mat drawing = g_srcImage.clone(); for( int unsigned i = 0; i\u0026lt;contours.size( ); i++ ) { Scalar color = Scalar( g_rng.uniform(0, 255), g_rng.uniform(0,255), g_rng.uniform(0,255) );//随机设置颜色 drawContours( drawing, contours_poly, i, color, 1, 8, vector\u0026lt;Vec4i\u0026gt;(), 0, Point() );//绘制轮廓 rectangle( drawing, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0 );//绘制矩形 circle( drawing, center[i], (int)radius[i], color, 2, 8, 0 );//绘制圆 } // 显示效果图窗口 namedWindow( WINDOW_NAME2, WINDOW_AUTOSIZE ); imshow( WINDOW_NAME2, drawing ); } //-----------------------------------【ShowHelpText( )函数】---------------------------------- // 描述：输出一些帮助信息 //---------------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第75个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf(\u0026#34;\\n\\n\\n\\t欢迎来到【创建包围轮廓的矩形和圆形边界框】示例程序~\\n\\n\u0026#34;); printf( \u0026#34;\\n\\n\\t按键操作说明: \\n\\n\u0026#34; \u0026#34;\\t\\t键盘按键【ESC】- 退出程序\\n\\n\u0026#34; \u0026#34;\\t\\t滑动滚动条 - 改变阈值\\n\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是理解轮廓形状分析的基本原理；掌握实现轮廓形状分析的代码编写方法。新建工程，在VS2015中配置OpenCV，得到原图的灰度图像并进行平滑，使用Threshold检测边缘，找出轮廓，多边形逼近轮廓，获取矩形和圆形边界框，绘制多边形轮廓、包围的矩形框和圆形框。\n","date":"2020-05-27T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89-%E8%BD%AE%E5%BB%93%E5%BD%A2%E7%8A%B6%E5%88%86%E6%9E%90%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十三 轮廓形状分析实验"},{"content":"计算机视觉 - 实验十二 离散傅里叶变换实验 实验目的和要求 理解傅立叶变换的基本原理；掌握实现傅立叶变换的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）以灰度模式读取原始图像并显示；\n（四）编写代码实现傅立叶变换；\n（五）显示傅立叶变换效果图。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）离散傅里叶变换(DFT)，是指傅里叶变换在时域和频域上都呈现离散的形式，将时域信号的采样变换为在离散时间傅里叶变换频域的采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。 即使对有限长的离散信号做DFT，也应当对其经过周期延拓成为周期信号再进行变换。在实际应用中，通常采用快速傅里叶变换来高效计算DFT。\n（二）在频域里面，对于一幅图像，亮度或灰度变化激烈的地方对应高频成分，如边缘、纹理信息；亮度或灰度变化不大的地方对应低频成分。如果图像受到的噪声恰好位于某个特定的“频率”范围内，则可以通过滤波器来恢复原来的图像。傅里叶变换在图像处理中可以做到图像增强与图像去噪、图像分割之边缘检测、图像特征提取、图像压缩等。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）以灰度模式读取原始图像并显示；\n（四）将输入图像延扩到最佳的尺寸，边界用0补充；\n（五）为傅立叶变换的结果(实部和虚部)分配存储空间；\n（六）进行离散傅里叶变换；\n（七）将复数转换为幅值；\n（八）进行对数尺度缩放；\n（九）剪切和重分布幅度图象限；\n（十）归一化，用0到1之间的浮点值将矩阵变换为可视的图像格式；\n（十一）显示傅立叶变换效果图。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）dft函数的功能和使用方法；\n（三）剪切和重分布幅度图象限的方法；\n（四）normalize函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //-----------------------【头文件、命名空间包含部分】----------------------------- //\t描述：包含程序所使用的头文件和命名空间 //--------------------------------------------------------------------------------- #include \u0026#34;opencv2/core/core.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace cv; //-----------------------------------【ShowHelpText( )函数】------------------------ //\t描述：输出一些帮助信息 //---------------------------------------------------------------------------------- void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第28个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); } //-------------------------------【main( )函数】----------------------------------------- // 描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //------------------------------------------------------------------------------------- int main( ) { //【1】以灰度模式读取原始图像并显示 Mat srcImage = imread(\u0026#34;feng.png\u0026#34;, 0); if(!srcImage.data ) { printf(\u0026#34;读取图片错误，请确定目录下是否有imread函数指定图片存在~！ \\n\u0026#34;); return false; } imshow(\u0026#34;原始图像\u0026#34; , srcImage); ShowHelpText(); //【2】将输入图像延扩到最佳的尺寸，边界用0补充 int m = getOptimalDFTSize( srcImage.rows ); int n = getOptimalDFTSize( srcImage.cols ); //将添加的像素初始化为0. Mat padded; copyMakeBorder(srcImage, padded, 0, m - srcImage.rows, 0, n - srcImage.cols, BORDER_CONSTANT, Scalar::all(0)); //【3】为傅立叶变换的结果(实部和虚部)分配存储空间。 //将planes数组组合合并成一个多通道的数组complexI Mat planes[] = {Mat_\u0026lt;float\u0026gt;(padded), Mat::zeros(padded.size(), CV_32F)}; Mat complexI; merge(planes, 2, complexI); //【4】进行就地离散傅里叶变换 dft(complexI, complexI); //【5】将复数转换为幅值，即=\u0026gt; log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2)) split(complexI, planes); // 将多通道数组complexI分离成几个单通道数组，planes[0] = Re(DFT(I), planes[1] = Im(DFT(I)) //void magnitude(InputArray x, InputArray y, OutputArray magnitude); magnitude(planes[0], planes[1], planes[0]);// planes[0] = magnitude Mat magnitudeImage = planes[0]; //【6】进行对数尺度(logarithmic scale)缩放 magnitudeImage += Scalar::all(1); log(magnitudeImage, magnitudeImage);//求自然对数 //【7】剪切和重分布幅度图象限 //若有奇数行或奇数列，进行频谱裁剪 magnitudeImage = magnitudeImage(Rect(0, 0, magnitudeImage.cols \u0026amp; -2, magnitudeImage.rows \u0026amp; -2)); //重新排列傅立叶图像中的象限，使得原点位于图像中心 int cx = magnitudeImage.cols/2; int cy = magnitudeImage.rows/2; Mat q0(magnitudeImage, Rect(0, 0, cx, cy)); // ROI区域的左上 Mat q1(magnitudeImage, Rect(cx, 0, cx, cy)); // ROI区域的右上 Mat q2(magnitudeImage, Rect(0, cy, cx, cy)); // ROI区域的左下 Mat q3(magnitudeImage, Rect(cx, cy, cx, cy)); // ROI区域的右下 //交换象限（左上与右下进行交换） Mat tmp; q0.copyTo(tmp); q3.copyTo(q0); tmp.copyTo(q3); //交换象限（右上与左下进行交换） q1.copyTo(tmp); q2.copyTo(q1); tmp.copyTo(q2); //【8】归一化，用0到1之间的浮点值将矩阵变换为可视的图像格式 //此句代码的OpenCV2版为： //normalize(magnitudeImage, magnitudeImage, 0, 1, CV_MINMAX); //此句代码的OpenCV3版为: normalize(magnitudeImage, magnitudeImage, 0, 1, NORM_MINMAX); //【9】显示效果图 imshow(\u0026#34;频谱幅值\u0026#34;, magnitudeImage); waitKey(); return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解傅立叶变换的基本原理；掌握实现傅立叶变换的代码编写方法。新建工程，在VS2015中配置OpenCV；以灰度模式读取原始图像并显示；编写代码实现傅立叶变换；显示傅立叶变换效果图。\n","date":"2020-05-18T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C-%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十二 离散傅里叶变换实验"},{"content":"计算机视觉 - 实验十一 LBP变换实验 实验目的和要求 理解局部二值模式的基本原理；掌握实现局部二值模式的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）读入原始图像并转换为灰度图像；\n（四）实现LBP算法，计算输入图像的LBP纹理特征；\n（五）显示LBP纹理特征图。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）LBP指局部二值模式，英文全称:Local Binary Patterns。最初功能为辅助图像局部对比度，并不是一个完整的特征描述子。后来提升为一种有效的纹理描述算子，度量和提取图像局部的纹理信息，对光照具有不变性。LBP有很多变种，或说改进。单纯的LBP记录像素点与其周围像素点的对比信息，或说差异。\n（二）LBP的基本思想是以图像中某个像素为中心，对相邻像素进行阈值比较。如果中心像素的亮度大于等于它的相邻像素，把相邻像素标记为0，否则标记为1。我们可以用二进制数字来表示LBP图中的每个像素的LBP编码。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）使用OpenCV的cvtColor函数将原始图像转换为灰度图像；\n（四）编写函数，实现LBP算法，计算输入图像的LBP纹理特征；\n（五）使用OpenCV的imshow函数显示LBP纹理特征图。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）cvtColor函数的功能和使用方法；\n（三）根据LBP算法的原理，用代码实现LBP算法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;limits\u0026gt; using namespace std; using namespace cv; //原始的LBP算法 //使用模板参数 /** *将原图去除最外围的一圈，里面的每个都作为中心点，来计算这个中心点相应矩形区域 *的lbp特征值。 *算出来的这个lbp特征值，就是目标mat的值， *目标mat的大小是原始mat的（rows-2,cols-2) */ template \u0026lt;typename _Tp\u0026gt; void OLBP_(const Mat\u0026amp; src, Mat\u0026amp; dst) { dst = Mat::zeros(src.rows - 2, src.cols - 2, CV_8UC1); for (int i = 1; i\u0026lt;src.rows - 1; i++) { for (int j = 1; j\u0026lt;src.cols - 1; j++) { _Tp center = src.at\u0026lt;_Tp\u0026gt;(i, j); unsigned char code = 0; code |= (src.at\u0026lt;_Tp\u0026gt;(i - 1, j - 1) \u0026gt; center) \u0026lt;\u0026lt; 7; code |= (src.at\u0026lt;_Tp\u0026gt;(i - 1, j) \u0026gt; center) \u0026lt;\u0026lt; 6; code |= (src.at\u0026lt;_Tp\u0026gt;(i - 1, j + 1) \u0026gt; center) \u0026lt;\u0026lt; 5; code |= (src.at\u0026lt;_Tp\u0026gt;(i, j + 1) \u0026gt; center) \u0026lt;\u0026lt; 4; code |= (src.at\u0026lt;_Tp\u0026gt;(i + 1, j + 1) \u0026gt; center) \u0026lt;\u0026lt; 3; code |= (src.at\u0026lt;_Tp\u0026gt;(i + 1, j) \u0026gt; center) \u0026lt;\u0026lt; 2; code |= (src.at\u0026lt;_Tp\u0026gt;(i + 1, j - 1) \u0026gt; center) \u0026lt;\u0026lt; 1; code |= (src.at\u0026lt;_Tp\u0026gt;(i, j - 1) \u0026gt; center) \u0026lt;\u0026lt; 0; dst.at\u0026lt;unsigned char\u0026gt;(i - 1, j - 1) = code; if (i == 1) cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; i - 1 \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; j - 1 \u0026lt;\u0026lt; \u0026#34;)=\u0026#34; \u0026lt;\u0026lt; (unsigned)code \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } if (i == 1) cout \u0026lt;\u0026lt; endl; } } template \u0026lt;typename _Tp\u0026gt; void ELBP_(const Mat\u0026amp; src, Mat\u0026amp; dst, int radius, int neighbors) { neighbors = max(min(neighbors, 31), 1); // set bounds... // Note: alternatively you can switch to the new OpenCV Mat_ // type system to define an unsigned int matrix... I am probably // mistaken here, but I didn\u0026#39;t see an unsigned int representation // in OpenCV\u0026#39;s classic typesystem... dst = Mat::zeros(src.rows - 2 * radius, src.cols - 2 * radius, CV_32SC1); for (int n = 0; n\u0026lt;neighbors; n++) { // sample points float x = static_cast\u0026lt;float\u0026gt;(radius) * cos(2.0*M_PI*n / static_cast\u0026lt;float\u0026gt;(neighbors)); float y = static_cast\u0026lt;float\u0026gt;(radius) * -sin(2.0*M_PI*n / static_cast\u0026lt;float\u0026gt;(neighbors)); // relative indices int fx = static_cast\u0026lt;int\u0026gt;(floor(x)); int fy = static_cast\u0026lt;int\u0026gt;(floor(y)); int cx = static_cast\u0026lt;int\u0026gt;(ceil(x)); int cy = static_cast\u0026lt;int\u0026gt;(ceil(y)); // fractional part float ty = y - fy; float tx = x - fx; // set interpolation weights float w1 = (1 - tx) * (1 - ty); float w2 = tx * (1 - ty); float w3 = (1 - tx) * ty; float w4 = tx * ty; // iterate through your data for (int i = radius; i \u0026lt; src.rows - radius; i++) { for (int j = radius; j \u0026lt; src.cols - radius; j++) { float t = w1*src.at\u0026lt;_Tp\u0026gt;(i + fy, j + fx) + w2*src.at\u0026lt;_Tp\u0026gt;(i + fy, j + cx) + w3*src.at\u0026lt;_Tp\u0026gt;(i + cy, j + fx) + w4*src.at\u0026lt;_Tp\u0026gt;(i + cy, j + cx); // we are dealing with floating point precision, so add some little tolerance dst.at\u0026lt;unsigned int\u0026gt;(i - radius, j - radius) += ((t \u0026gt; src.at\u0026lt;_Tp\u0026gt;(i, j)) \u0026amp;\u0026amp; (abs(t - src.at\u0026lt;_Tp\u0026gt;(i, j)) \u0026gt; std::numeric_limits\u0026lt;float\u0026gt;::epsilon())) \u0026lt;\u0026lt; n; } } } } int main(int argc, char* argv[]) { Mat color_face = imread(\u0026#34;2007_000807.jpg\u0026#34;, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); if (color_face.empty()) { cout \u0026lt;\u0026lt; \u0026#34;read picture fail!\\n\u0026#34;; return -1; } Mat olbp_face = Mat::zeros(color_face.size(), color_face.type()); //change to grey color picture cvtColor(color_face, olbp_face, CV_BGR2GRAY); //显示原始的输入图像 cvNamedWindow(\u0026#34;Src Image\u0026#34;, CV_WINDOW_AUTOSIZE); imshow(\u0026#34;Src Image\u0026#34;, olbp_face); //计算输入图像的LBP纹理特征 Mat lbp_face;//= Mat::zeros(color_face.size(),color_face.type()) ; OLBP_\u0026lt;uchar\u0026gt;(olbp_face, lbp_face); //显示LBP纹理特征图 namedWindow(\u0026#34;LBP Image1\u0026#34;, 1); imshow(\u0026#34;LBP Image1\u0026#34;, lbp_face); //use elbp // Mat elbp_face; // ELBP_\u0026lt;uchar\u0026gt;(olbp_face,elbp_face,2,4); waitKey(); return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解局部二值模式的基本原理；掌握实现局部二值模式的代码编写方法。新建工程，在VS2015中配置OpenCV，读入原始图像并转换为灰度图像；实现LBP算法，计算输入图像的LBP纹理特征；显示LBP纹理特征图。学会了cvtColor函数的功能和使用方法；根据LBP算法的原理，用代码实现LBP算法。\n","date":"2020-05-13T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80-lbp%E5%8F%98%E6%8D%A2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验十一 LBP变换实验"},{"content":"计算机视觉 - 实验十 创建包围轮廓的矩形边界 实验目的和要求 理解创建包围轮廓的矩形边界的基本原理；掌握使用OpenCV创建包围轮廓的矩形边界的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用OpenCV中的RNG类随机生成点坐标；\n（四）对给定的 2D 点集，寻找最小面积的包围矩形；\n（五）绘制出最小面积的包围矩形。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）在实际应用中，常常会有将检测到的轮廓用多边形表示出来的需求。本实验实现如何用矩形来表示轮廓，或者说如何根据轮廓提取出矩形。\n（二）在OpenCV中，使用RNG类可以随机生成点坐标，然后使用minAreaRect函数寻找最小面积的包围矩形，minAreaRect函数求得的矩形是可以有偏转角度的，可以与 图像的边界不平行。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用OpenCV中的RNG类随机生成点坐标；\n（四）编写代码，使用OpenCV中的minAreaRect函数，对上一步生成的2D点集，寻找最小面积的包围矩形；\n（五）编写代码，使用OpenCV中的line函数，绘制出minAreaRect函数检测到的最小面积的包围矩形。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）RNG类的功能和使用方法；\n（三）minAreaRect函数的功能和使用方法；\n（四）line函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //---------------------------------【头文件、命名空间包含部分】-------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; using namespace cv; using namespace std; //-----------------------------------【ShowHelpText( )函数】----------------------------- // 描述：输出一些帮助信息 //------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第73个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf(\u0026#34;\\n\\n\\n\\t\\t\\t欢迎来到【矩形包围示例】示例程序~\\n\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t按键操作说明: \\n\\n\u0026#34; \u0026#34;\\t\\t键盘按键【ESC】、【Q】、【q】- 退出程序\\n\\n\u0026#34; \u0026#34;\\t\\t键盘按键任意键 - 重新生成随机点，并寻找最小面积的包围矩形\\n\u0026#34; ); } int main( ) { //改变console字体颜色 system(\u0026#34;color 1F\u0026#34;); //显示帮助文字 ShowHelpText(); //初始化变量和随机值 Mat image(600, 600, CV_8UC3); RNG\u0026amp; rng = theRNG(); //循环，按下ESC,Q,q键程序退出，否则有键按下便一直更新 while(1) { //参数初始化 int count = rng.uniform(3, 103);//随机生成点的数量 vector\u0026lt;Point\u0026gt; points;//点值 //随机生成点坐标 for(int i = 0; i \u0026lt; count; i++ ) { Point point; point.x = rng.uniform(image.cols/4, image.cols*3/4); point.y = rng.uniform(image.rows/4, image.rows*3/4); points.push_back(point); } //对给定的 2D 点集，寻找最小面积的包围矩形 RotatedRect box = minAreaRect(Mat(points)); Point2f vertex[4]; box.points(vertex); //绘制出随机颜色的点 image = Scalar::all(0); for( int i = 0; i \u0026lt; count; i++ ) circle( image, points[i], 3, Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255)), FILLED, LINE_AA ); //绘制出最小面积的包围矩形 for( int i = 0; i \u0026lt; 4; i++ ) line(image, vertex[i], vertex[(i+1)%4], Scalar(100, 200, 211), 2, LINE_AA); //显示窗口 imshow( \u0026#34;矩形包围示例\u0026#34;, image ); //按下ESC,Q,或者q，程序退出 char key = (char)waitKey(); if( key == 27 || key == \u0026#39;q\u0026#39; || key == \u0026#39;Q\u0026#39; ) // \u0026#39;ESC\u0026#39; break; } return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解创建包围轮廓的矩形边界的基本原理；掌握使用OpenCV创建包围轮廓的矩形边界的代码编写方法。新建工程，在VS2015中配置OpenCV，使用OpenCV中的RNG类随机生成点坐标；对给定的 2D 点集，寻找最小面积的包围矩形；绘制出最小面积的包围矩形。学会了用OpenCV中的RNG类随机生成点坐标；学会了对给定的 2D 点集，如何寻找最小面积的包围矩形；学会了如何绘制出最小面积的包围矩形。\n","date":"2020-05-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%8D%81-%E5%88%9B%E5%BB%BA%E5%8C%85%E5%9B%B4%E8%BD%AE%E5%BB%93%E7%9A%84%E7%9F%A9%E5%BD%A2%E8%BE%B9%E7%95%8C/","title":"计算机视觉 - 实验十 创建包围轮廓的矩形边界"},{"content":"计算机视觉 - 实验九 寻找和绘制物体的凸包实验 实验目的和要求 理解使用凸包的基本原理；掌握使用OpenCV通过凸包理解物体形状或轮廊的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用OpenCV中的findContours函数查找图像轮廓；\n（四）遍历每个轮廓，使用OpenCV中的convexHull寻找其凸包；\n（五）编写代码，使用OpenCV中的drawContours函数绘出图像轮廓及其凸包。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）凸包(Convex Hull)是一个计算几何(图形学)中常见的概念。简单来说，给定二维平面上的点集，凸包就是将最外层的点连接起来构成的凸多边型，它是能包含点集中所有点的。理解物体形状或轮廊的一种比较有用的方法便是计算一个物体的凸包。\n（二）在OpenCV中，convexHull函数用于寻找图像点集的凸包。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用findContours函数查找图像轮廓；\n（四）编写代码，遍历每个轮廓，使用convexHull函数寻找其凸包；\n（五）编写代码，绘出图像轮廓及其凸包。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）findContours函数的功能和使用方法；\n（三）convexHull函数的功能和使用方法；\n（四）drawContours函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 //---------------------------------【头文件、命名空间包含部分】--------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace cv; using namespace std; //-----------------------------------【宏定义部分】---------------------------------- // 描述：定义一些辅助宏 //------------------------------------------------------------------------------------- #define WINDOW_NAME1 \u0026#34;【原始图窗口】\u0026#34;\t//为窗口标题定义的宏 #define WINDOW_NAME2 \u0026#34;【效果图窗口】\u0026#34;\t//为窗口标题定义的宏 //-----------------------------------【全局变量声明部分】------------------------------- // 描述：全局变量的声明 //------------------------------------------------------------------------------------ Mat g_srcImage; Mat g_grayImage; int g_nThresh = 50; int g_maxThresh = 255; RNG g_rng(12345); Mat srcImage_copy = g_srcImage.clone(); Mat g_thresholdImage_output; vector\u0026lt;vector\u0026lt;Point\u0026gt; \u0026gt; g_vContours; vector\u0026lt;Vec4i\u0026gt; g_vHierarchy; //----------------------------【全局函数声明部分】-------------------------------------- // 描述：全局函数的声明 //------------------------------------------------------------------------------------- static void ShowHelpText( ); void on_ThreshChange(int, void* ); void ShowHelpText(); //-----------------------【main( )函数】------------------------------------------ // 描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //------------------------------------------------------------------------------------ int main( ) { system(\u0026#34;color 3F\u0026#34;); ShowHelpText(); // 加载源图像 g_srcImage = imread( \u0026#34;2007_000804.jpg\u0026#34;, 1 ); // 将原图转换成灰度图并进行模糊降 cvtColor( g_srcImage, g_grayImage, COLOR_BGR2GRAY ); blur( g_grayImage, g_grayImage, Size(3,3) ); // 创建原图窗口并显示 namedWindow( WINDOW_NAME1, WINDOW_AUTOSIZE ); imshow( WINDOW_NAME1, g_srcImage ); //创建滚动条 createTrackbar( \u0026#34; 阈值:\u0026#34;, WINDOW_NAME1, \u0026amp;g_nThresh, g_maxThresh, on_ThreshChange ); on_ThreshChange( 0, 0 );//调用一次进行初始化 waitKey(0); return(0); } //---------------------------【thresh_callback( )函数】---------------------------------- // 描述：回调函数 //------------------------------------------------------------------------------------- void on_ThreshChange(int, void* ) { // 对图像进行二值化，控制阈值 threshold( g_grayImage, g_thresholdImage_output, g_nThresh, 255, THRESH_BINARY ); // 寻找轮廓 findContours( g_thresholdImage_output, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) ); // 遍历每个轮廓，寻找其凸包 vector\u0026lt;vector\u0026lt;Point\u0026gt; \u0026gt;hull( g_vContours.size() ); for( unsigned int i = 0; i \u0026lt; g_vContours.size(); i++ ) { convexHull( Mat(g_vContours[i]), hull[i], false ); } // 绘出轮廓及其凸包 Mat drawing = Mat::zeros( g_thresholdImage_output.size(), CV_8UC3 ); Mat drawing1; cv::cvtColor(g_grayImage, drawing1, cv::COLOR_GRAY2BGR); Mat drawing2 = Mat::zeros(g_thresholdImage_output.size(), CV_8UC3); for(unsigned int i = 0; i\u0026lt; g_vContours.size(); i++ ) { Scalar color = Scalar( g_rng.uniform(0, 255), g_rng.uniform(0,255), g_rng.uniform(0,255) ); drawContours( drawing, g_vContours, i, color, 1, 8, vector\u0026lt;Vec4i\u0026gt;(), 0, Point() ); drawContours( drawing, hull, i, color, 1, 8, vector\u0026lt;Vec4i\u0026gt;(), 0, Point() ); drawContours( drawing1, hull, i, color, 1, 8, vector\u0026lt;Vec4i\u0026gt;(), 0, Point() ); drawContours(drawing2, g_vContours, i, color, 1, 8, vector\u0026lt;Vec4i\u0026gt;(), 0, Point() ); } // 显示效果图 imshow( WINDOW_NAME2, drawing ); imshow( \u0026#34;hull\u0026#34;, drawing1); imshow( \u0026#34;Contours\u0026#34;, drawing2); } //-----------------------------------【ShowHelpText( )函数】----------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第72个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n------------------------------------------------------------------\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是理解使用凸包的基本原理；掌握使用OpenCV通过凸包理解物体形状或轮廊的代码编写方法。新建工程，在VS2015中配置OpenCV，使用OpenCV中的findContours函数查找图像轮廓；遍历每个轮廓，使用OpenCV中的convexHull寻找其凸包；编写代码，使用OpenCV中的drawContours函数绘出图像轮廓及其凸。学会了用findContours函数查找图像轮廓；学会了使用convexHull函数寻找其凸包；学会了使用drawContours函数绘出图像轮廓及其凸。\n","date":"2020-04-29T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%B9%9D-%E5%AF%BB%E6%89%BE%E5%92%8C%E7%BB%98%E5%88%B6%E7%89%A9%E4%BD%93%E7%9A%84%E5%87%B8%E5%8C%85%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验九 寻找和绘制物体的凸包实验"},{"content":"个人resume练习 最终页面效果 参考网页 https://rscard.px-lab.com/startuper/\n个人作品 代码 index.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Me的个人简历\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;./a.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;topNavBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;topNavBar-inner clearfix\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; class=\u0026#34;logo\u0026#34; alt=\u0026#34;logo\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;rs\u0026#34;\u0026gt;RS\u0026lt;/span\u0026gt;\u0026lt;span class=\u0026#34;card\u0026#34;\u0026gt;card\u0026lt;/span\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;关于\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#jineng\u0026#34;\u0026gt;技能\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#zuopin\u0026#34;\u0026gt;作品\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;博客\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;日历\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;联系方式\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;其他\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;banner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;mask\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;main\u0026gt; \u0026lt;div class=\u0026#34;userCard\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;pictureAndText clearfix\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;picture\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./img/avatar.jpg\u0026#34; width=\u0026#34;299\u0026#34; height=\u0026#34;347\u0026#34; alt=\u0026#34;头像\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;text\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;welcome\u0026#34;\u0026gt;Hello \u0026lt;span class=\u0026#34;triangle\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;h1\u0026gt;靳文杰\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;前端开发工程师\u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;dl\u0026gt; \u0026lt;dt\u0026gt;年龄\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;21\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;所在城市\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;西安\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;邮箱\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;j_861142@163.com\u0026lt;/dd\u0026gt; \u0026lt;dt\u0026gt;手机\u0026lt;/dt\u0026gt; \u0026lt;dd\u0026gt;15502979297\u0026lt;/dd\u0026gt; \u0026lt;/dl\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;footer class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./png/github.png\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./png/ins.png\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./png/qq.png\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./png/weibo.png\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./png/weixin.png\u0026#34; class=\u0026#34;icon\u0026#34; alt=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class=\u0026#34;downloadResume-wrapper\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;./resume.pdf\u0026#34; class=\u0026#34;downloadResume\u0026#34; target=\u0026#34;_blank\u0026#34; download\u0026gt;下载 PDF 简历\u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;selfIntroduction\u0026#34;\u0026gt; 靳文杰，计算机科学与技术1701班，1998年9月，共青团员。\u0026lt;br\u0026gt; 大一学年成绩在专业排名第8名，大二学年成绩在专业排名第1名。 \u0026lt;br\u0026gt; 荣获2017-2018学年国家励志奖学金、2018-2019学年国家奖学金等。 \u0026lt;/p\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;section class=\u0026#34;skills\u0026#34;\u0026gt; \u0026lt;a name=\u0026#34;jineng\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;h2\u0026gt;技能\u0026lt;/h2\u0026gt; \u0026lt;ol class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; HTML 5 \u0026amp;amp; CSS 3 \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 10%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; JavaScript \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 40%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; jQuery \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 60%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; Vue \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 90%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; React \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 20%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;h3\u0026gt; HTTP \u0026lt;/h3\u0026gt; \u0026lt;div class=\u0026#34;progressBar\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;progress\u0026#34; style=\u0026#34;width: 40%;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;portfolio\u0026#34;\u0026gt; \u0026lt;a name=\u0026#34;zuopin\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;h2\u0026gt;作品集\u0026lt;/h2\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ol class=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;portfolio1\u0026#34;\u0026gt;所有\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;portfolio2\u0026#34;\u0026gt;框架\u0026lt;/li\u0026gt; \u0026lt;li id=\u0026#34;portfolio3\u0026#34;\u0026gt;原生 JS \u0026amp;amp; CSS\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;div id=\u0026#34;portfolioBar\u0026#34; class=\u0026#34;bar state-1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;bar-inner\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;script\u0026gt; portfolio1.onclick = function () { portfolioBar.className = \u0026#39;bar state-1\u0026#39; } portfolio2.onclick = function () { portfolioBar.className = \u0026#39;bar state-2\u0026#39; } portfolio3.onclick = function () { portfolioBar.className = \u0026#39;bar state-3\u0026#39; } \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;works\u0026#34; style=\u0026#34;height: 576px;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;big\u0026#34; style=\u0026#34;top: 0px; left: 0px;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./jpg/111.JPG\u0026#34; alt=\u0026#34;作品1\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;small\u0026#34; style=\u0026#34;top: 0px; left: 644px;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./jpg/222.JPG\u0026#34; alt=\u0026#34;作品2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;small\u0026#34; style=\u0026#34;top: 298px; left: 644px;\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;./jpg/333.JPG\u0026#34; alt=\u0026#34;作品3\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; a.css 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 body { background: #EFEFEF; margin: 0; } a { color: inherit; text-decoration: none; } * { margin: 0; padding: 0; } hr { height: 0; border: none; border-top: 1px solid #DEDEDE; } ul, ol { list-style: none; } h1, h2, h3, h4, h5, h6 { font-weight: normal; } .clearfix::after { content: \u0026#39;\u0026#39;; display: block; clear: both; } .topNavBar nav\u0026gt;ul { list-style: none; margin: 0; padding: 0; } .topNavBar { /* padding-top: 20px; padding-bottom: 20px; padding-left: 16px; padding-right: 16px; padding:上 右 下 左 */ padding: 20px 0 20px 0; position: fixed; top: 0; left: 0; width: 100%; } .topNavBar-inner { padding: 0 16px; } .topNavBar nav { padding-top: 7px; padding-bottom: 2.19px; } .topNavBar nav\u0026gt;ul\u0026gt;li { float: left; margin-left: 17px; margin-right: 17px; } .topNavBar nav\u0026gt;ul\u0026gt;li\u0026gt;a { font-size: 12px; color: #B7B7B7; font-weight: bold; border-top: 3px solid transparent; border-bottom: 3px solid transparent; padding-top: 5px; padding-bottom: 5px; display: block; } .topNavBar nav\u0026gt;ul\u0026gt;li\u0026gt;a:hover { border-bottom: 3px solid #e06567; } .topNavBar a { float: left; } .topNavBar nav { float: right; } .topNavBar .logo { font-size: 24px; font-family: \u0026#34;Arial Black\u0026#34;; padding-top: 3px; padding-bottom: 4px; } .topNavBar .logo .rs { margin-right: 4px; color: #E6696A; } .topNavBar .logo .card { color: #9A9DA2; } .banner { height: 515px; background-image: url(./img/rs-cover.jpg); background-position: center center; background-size: cover; } .banner .mask { height: 515px; background-color: rgba(0, 0, 0, 0.8); } .userCard { max-width: 940px; margin-left: auto; margin-right: auto; background-color: #FFFFFF; box-shadow: 0px 1px 5px 0px rgba(0, 0, 0, 0.5); } .userCard .welcome { background: #E6686A; color: white; display: inline-block; /* width: 70px; height: 29px; line-height: 29px; text-align: center; */ padding: 3.5px 16.5px; line-height: 22px; position: relative; margin-bottom: 10px; } .userCard .welcome .triangle { display: block; border: 10px solid transparent; width: 0px; border-left-color: #E6686A; border-top-width: 0px; position: absolute; left: 4px; top: 100%; } .userCard .picture { float: left; } .userCard .text { float: left; margin-left: 65px; width: 470px; } .userCard .text h1 { margin-top: 18px; } .userCard .text hr { margin: 20px 0; } .userCard .pictureAndText { padding: 50px; } .userCard dl dt, .userCard dl dd { float: left; padding: 5px 0; } .userCard dl dt { width: 30%; font-weight: bold; } .userCard dl dd { width: 70%; color: #9da0a7; } .userCard\u0026gt;footer.media { background: #E6686A; text-align: center; } .userCard\u0026gt;footer.media\u0026gt;a { display: inline-block; width: 60px; line-height: 30px; padding: 15px 0; border-radius: 50%; margin: 8px; } .userCard\u0026gt;footer.media\u0026gt;a:hover { background: #CF5D5F; } .icon { width: 30px; height: 30px; overflow: hidden; vertical-align: top; } body\u0026gt;main { margin-top: -340px; } body\u0026gt;main .downloadResume-wrapper { text-align: center; } body\u0026gt;main .downloadResume { font-size: 14px; line-height: 16px; padding: 21px 55px; border: 1px solid #CDCFD1; background: #EFEFEF; display: inline-block; border-radius: 5px; color: #3d4451; font-weight: bold; margin: 32px 0; transition: box-shadow 0.2s; } body\u0026gt;main .downloadResume:hover { box-shadow: 0px 4px 13px 0px rgba(0, 0, 0, 0.2); } .selfIntroduction { max-width: 940px; margin-left: auto; margin-right: auto; text-align: center; font-family: cursive; line-height: 1.8; font-size: 18px; font-weight: 900; } section.skills, section.portfolio { max-width: 940px; margin-left: auto; margin-right: auto; margin-top: 60px; } section.skills\u0026gt;h2, section.portfolio\u0026gt;h2 { text-align: center; color: #3d4451; font-size: 34px; line-height: 1.2; font-weight: 600; } section.skills h3 { font-size: 14px; line-height: 1.1; padding-right: 40px; } section.skills\u0026gt;ol { background: white; box-shadow: 0px 1px 5px 0px rgba(0, 0, 0, 0.5); padding: 42px 50px 0; margin-top: 30px; } section.skills\u0026gt;ol\u0026gt;li { float: left; width: 48%; box-sizing: border-box; } section.skills\u0026gt;ol\u0026gt;li:nth-child(even) { float: right; } section.skills .progressBar { height: 5px; background: #fae1e1; border-radius: 9px; margin: 4px 0 40px; } section.skills .progressBar\u0026gt;.progress { height: 100%; background: #e6686a; width: 70%; border-radius: 9px; } section.portfolio { text-align: center; margin-bottom: 100px; } section.portfolio\u0026gt;nav { text-align: center; } section.portfolio\u0026gt;nav\u0026gt;ol { margin: 0 auto; display: inline-block; vertical-align: top; } section.portfolio\u0026gt;nav\u0026gt;ol\u0026gt;li { float: left; margin-left: 40px; cursor: pointer; } section.portfolio\u0026gt;nav\u0026gt;ol\u0026gt;li:nth-child(1) { margin-left: 0; } section.portfolio\u0026gt;nav { display: inline-block; vertical-align: top; margin-top: 32px; } section.portfolio\u0026gt;nav .bar { height: 5px; background: white; margin-top: 5px; margin-bottom: 28px; border-radius: 9px; } section.portfolio\u0026gt;nav .bar-inner { height: 100%; background: #E6686A; width: 10%; border-radius: 9px; transition: all 0.3s; } section.portfolio\u0026gt;nav .bar.state-1 .bar-inner { margin-left: 0px; width: 33px; } section.portfolio\u0026gt;nav .bar.state-2 .bar-inner { margin-left: 73px; width: 33px; } section.portfolio\u0026gt;nav .bar.state-3 .bar-inner { margin-left: 143px; width: 107px; } section.portfolio .works { position: relative; } section.portfolio .works\u0026gt;.big, section.portfolio .works\u0026gt;.small { position: absolute; } csdn 链接 前端-个人resume练习\n","date":"2020-04-23T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%89%8D%E7%AB%AF-%E4%B8%AA%E4%BA%BAresume%E7%BB%83%E4%B9%A0/","title":"前端 - 个人Resume练习"},{"content":"计算机视觉 - 实验八 图像分割实验 实验目的和要求 理解使用meanShfit进行图像分割的基本原理；掌握使用OpenCV通过均值漂移算法实现彩色图像分割的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用OpenCV中的pyrMeanShiftFiltering函数实现彩色图像分割；\n（四）使用OpenCV中的floodFill函数对其分割的结果用不同的颜色进行填充。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）meanShfit（均值漂移）算法是一种通用的聚类算法，它的基本原理是：对于给定的一定数量样本，任选其中一个样本，以该样本为中心点划定一个圆形区域，求取该圆形区域内样本的质心，即密度最大处的点，再以该点为中心继续执行上述迭代过程，直至最终收敛。\n（二）meanShfit不仅可以用于图像滤波，视频跟踪，还可以用于图像分割。可以利用均值漂移的算法特性，实现彩色图像分割。Opencv中对应的函数是pyrMeanShiftFiltering。pyrMeanShiftFiltering是图像在色彩层面的平滑滤波，它可以中和色彩分布相近的颜色，平滑色彩细节，侵蚀掉面积较小的颜色区域，从而实现分割效果。\n（三）本实验的主要过程是，首先设置好参数，然后用函数pyrMeanShiftFiltering函数对输入的图像进行分割。分割后的结果保存在该函数的第二个参数即输出图像中，最后根据该分割图像的特点用floodFill函数对其分割的结果用不同的颜色进行填充。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用pyrMeanShiftFiltering函数实现彩色图像分割；\n（四）编写代码，使用floodFill函数对其分割的结果用不同的颜色进行填充。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）pyrMeanShiftFiltering函数的功能和使用方法；\n（三）floodFill函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 //-------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/core/core.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace cv; using namespace std; //---------------------------------【help( )函数】-------------------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- static void help() { cout \u0026lt;\u0026lt; \u0026#34;\\n\\t此程序演示了OpenCV中MeanShift图像分割的使用。\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\\t程序运行后我们可以通过3个滑动条调节分割效果。调节滑动条后可能会有些许卡顿，请耐心等待\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\n\\t3个滑动条代表的参数分别为空间窗的半径 （spatialRad）、色彩窗的半径（colorRad）、最大图像金字塔级别（maxPyrLevel）\\n\u0026#34; \u0026lt;\u0026lt; endl; } //This colors the segmentations static void floodFillPostprocess( Mat\u0026amp; img, const Scalar\u0026amp; colorDiff=Scalar::all(1) ) { CV_Assert( !img.empty() ); RNG rng = theRNG(); Mat mask( img.rows+2, img.cols+2, CV_8UC1, Scalar::all(0) ); for( int y = 0; y \u0026lt; img.rows; y++ ) { for( int x = 0; x \u0026lt; img.cols; x++ ) { if( mask.at\u0026lt;uchar\u0026gt;(y+1, x+1) == 0 ) { Scalar newVal( rng(256), rng(256), rng(256) ); floodFill( img, mask, Point(x,y), newVal, 0, colorDiff, colorDiff ); } } } } string winName = \u0026#34;meanshift\u0026#34;; int spatialRad, colorRad, maxPyrLevel; Mat img, res; static void meanShiftSegmentation( int, void* ) { cout \u0026lt;\u0026lt; \u0026#34;spatialRad=\u0026#34; \u0026lt;\u0026lt; spatialRad \u0026lt;\u0026lt; \u0026#34;; \u0026#34; \u0026lt;\u0026lt; \u0026#34;colorRad=\u0026#34; \u0026lt;\u0026lt; colorRad \u0026lt;\u0026lt; \u0026#34;; \u0026#34; \u0026lt;\u0026lt; \u0026#34;maxPyrLevel=\u0026#34; \u0026lt;\u0026lt; maxPyrLevel \u0026lt;\u0026lt; endl; pyrMeanShiftFiltering( img, res, spatialRad, colorRad, maxPyrLevel ); floodFillPostprocess( res, Scalar::all(2) ); imshow( winName, res ); } //--------------------------【main( )函数】-------------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------ int main(int argc, char** argv) { help(); img = imread( \u0026#34;1.jpg\u0026#34; ); if( img.empty() ) return -1; imshow(\u0026#34;原始图\u0026#34;,img); spatialRad = 10; colorRad = 10; maxPyrLevel = 1; namedWindow( winName, WINDOW_AUTOSIZE ); createTrackbar( \u0026#34;spatialRad\u0026#34;, winName, \u0026amp;spatialRad, 80, meanShiftSegmentation ); createTrackbar( \u0026#34;colorRad\u0026#34;, winName, \u0026amp;colorRad, 60, meanShiftSegmentation ); createTrackbar( \u0026#34;maxPyrLevel\u0026#34;, winName, \u0026amp;maxPyrLevel, 5, meanShiftSegmentation ); meanShiftSegmentation(0, 0); waitKey(); return 0; } （二）显示结果\n实验总结 本次实验的主要内容是理解使用meanShfit进行图像分割的基本原理；掌握使用OpenCV通过均值漂移算法实现彩色图像分割的代码编写方法。新建工程，在VS2015中配置OpenCV，使用OpenCV中的pyrMeanShiftFiltering函数实现彩色图像分割；使用OpenCV中的floodFill函数对其分割的结果用不同的颜色进行填充。学会了用pyrMeanShiftFiltering函数实现彩色图像分割；floodFill函数对其分割的结果用不同的颜色进行填充。\n","date":"2020-04-20T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%85%AB-%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验八 图像分割实验"},{"content":"计算机视觉 - 实验七 查找并绘制轮廓实验 实验目的和要求 理解查找图像轮廓的基本原理；掌握使用OpenCV实现查找轮廓的代码编写方法；掌握使用OpenCV实现绘制轮廓的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用OpenCV中的findContours函数实现查找轮廓；\n（四）使用OpenCV中的drawContours函数实现绘制轮廓。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）虽然Canny之类的边缘检测算法可以根据像素之间的差异，检测出轮廓边界的像素，但是它并没有将轮廓作为一个整体。所以，本实验便是把这些边缘像素组装成轮廓。\n（二）一个轮廓一般对应一系列的点，也就是图像中的一条曲线。其表示方法可能根据不同的情况而有所不同。在OpenCV中，可以用findContours函数从二值图像中查找轮廓。drawContours函数用于在图像中绘制外部或内部轮廓 。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用findContours函数实现实现查找轮廓；\n（四）编写代码，使用drawContours函数实现实现绘制轮廓。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）findContours函数的功能和使用方法；\n（三）drawContours函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 //----------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace cv; using namespace std; //----------------------------【宏定义部分】-------------------------------------------- //\t描述：定义一些辅助宏 //------------------------------------------------------------------------------------- #define WINDOW_NAME1 \u0026#34;【原始图窗口】\u0026#34;\t//为窗口标题定义的宏 #define WINDOW_NAME2 \u0026#34;【轮廓图】\u0026#34;\t//为窗口标题定义的宏 //----------------------------【全局变量声明部分】-------------------------------------- //\t描述：全局变量的声明 //------------------------------------------------------------------------------------- Mat g_srcImage; Mat g_grayImage; int g_nThresh = 80; int g_nThresh_max = 255; RNG g_rng(12345); Mat g_cannyMat_output; vector\u0026lt;vector\u0026lt;Point\u0026gt;\u0026gt; g_vContours; vector\u0026lt;Vec4i\u0026gt; g_vHierarchy; //----------------------------【全局函数声明部分】-------------------------------------- //\t描述：全局函数的声明 //------------------------------------------------------------------------------------- static void ShowHelpText( ); void on_ThreshChange(int, void* ); //---------------------------【main( )函数】-------------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //------------------------------------------------------------------------------------- int main( int argc, char** argv ) { //【0】改变console字体颜色 system(\u0026#34;color 1F\u0026#34;); //【0】显示欢迎和帮助文字 ShowHelpText( ); // 加载源图像 g_srcImage = imread( \u0026#34;1.jpg\u0026#34;, 1 ); if(!g_srcImage.data ) { printf(\u0026#34;读取图片错误，请确定目录下是否有imread函数指定的图片存在~！ \\n\u0026#34;); return false; } // 转成灰度并模糊化降噪 cvtColor( g_srcImage, g_grayImage, COLOR_BGR2GRAY ); blur( g_grayImage, g_grayImage, Size(3,3) ); // 创建窗口 namedWindow( WINDOW_NAME1, WINDOW_AUTOSIZE ); imshow( WINDOW_NAME1, g_srcImage ); //创建滚动条并初始化 createTrackbar( \u0026#34;canny阈值\u0026#34;, WINDOW_NAME1, \u0026amp;g_nThresh, g_nThresh_max, on_ThreshChange ); on_ThreshChange( 0, 0 ); waitKey(0); return(0); } //-----------------------------【on_ThreshChange( )函数】------------------------------ // 描述：回调函数 //------------------------------------------------------------------------------------- void on_ThreshChange(int, void* ) { // 用Canny算子检测边缘 Canny( g_grayImage, g_cannyMat_output, g_nThresh, g_nThresh*2, 3 ); imshow(\u0026#34;canny\u0026#34;, g_cannyMat_output); // 寻找轮廓 //void findContours(InputOutputArray image, OutputArrayOfArrays contours, //\tOutputArray hierarchy, int mode, //\tint method, Point offset = Point()); findContours( g_cannyMat_output, g_vContours, g_vHierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0) ); // 绘出轮廓 Mat drawing = Mat::zeros( g_cannyMat_output.size(), CV_8UC3 ); for( int i = 0; i\u0026lt; g_vContours.size(); i++ ) { Scalar color = Scalar( g_rng.uniform(0, 255), g_rng.uniform(0,255), g_rng.uniform(0,255) );//任意值 drawContours( drawing, g_vContours, i, color, 2, 8, g_vHierarchy, 0, Point() ); } // 显示效果图 imshow( WINDOW_NAME2, drawing ); } //----------------------------【ShowHelpText( )函数】---------------------------------- // 描述：输出一些帮助信息 //------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第70个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf( \u0026#34;\\n\\n\\t欢迎来到【在图形中寻找轮廓】示例程序~\\n\\n\u0026#34;); printf( \u0026#34;\\n\\n\\t按键操作说明: \\n\\n\u0026#34; \u0026#34;\\t\\t键盘按键任意键- 退出程序\\n\\n\u0026#34; \u0026#34;\\t\\t滑动滚动条-改变阈值\\n\u0026#34; ); } （二）显示结果\n实验总结 本次实验的主要内容是理解查找图像轮廓的基本原理；掌握使用OpenCV实现查找轮廓的代码编写方法；掌握使用OpenCV实现绘制轮廓的代码编写方法。新建工程，在VS2015中配置OpenCV，使用OpenCV中的findContours函数实现查找轮廓；使用OpenCV中的drawContours函数实现绘制轮廓。学会了用findContours函数从二值图像中查找轮廓。drawContours函数用于在图像中绘制外部或内部轮廓。\n","date":"2020-04-15T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%B8%83-%E6%9F%A5%E6%89%BE%E5%B9%B6%E7%BB%98%E5%88%B6%E8%BD%AE%E5%BB%93%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验七 查找并绘制轮廓实验"},{"content":"题目 1616: [算法训练VIP]反置数 时间限制: 1Sec 内存限制: 128MB\n题目描述 一个整数的“反置数”指的是把该整数的每一位 数字的顺序颠倒过来所得到的另一个整数。如果一个整数的末尾是以0结尾，那么在它的反置数当中，这些0就被省略掉了。比如说，1245的反置数是 5421，而1200的反置数是21。请编写一个程序，输入两个整数，然后计算这两个整数的反置数之和sum，然后再把sum的反置数打印出来。要求：由 于在本题中需要多次去计算一个整数的反置数，因此必须把这部分代码抽象为一个函数的形式。\n输入 输入只有一行，包括两个整数，中间用空格隔开。\n输出 输出只有一行，即相应的结果。\n样例输入 1 435 754 样例输出 1 199 C代码 解法A 先将整数转换为字符串，再倒置，再转换为整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int fun(int n) { char s[20],t; int len,m; sprintf(s,\u0026#34;%d\u0026#34;,n); len=strlen(s); for(int i=0;i\u0026lt;len/2;i++) { t=s[i];s[i]=s[len-1-i];s[len-1-i]=t; } sscanf(s,\u0026#34;%d\u0026#34;,\u0026amp;m); return m; } int main() { int x,y,sum; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); sum=fun(x)+fun(y); printf(\u0026#34;%d\\n\u0026#34;,fun(sum)); return 0; } 解法B 是先删除整数后面的0，然后倒置形成新的整数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; int fun(int n) { int m=0; while(n%10==0) n=n/10; while(n!=0) { m=m*10+n%10; n=n/10; } return m; } int main() { int x,y,sum; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;x,\u0026amp;y); sum=fun(x)+fun(y); printf(\u0026#34;%d\\n\u0026#34;,fun(sum)); return 0; } 通过C语言网编译运行 ","date":"2020-04-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1616-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98vip%E5%8F%8D%E7%BD%AE%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1616 [算法提高VIP]反置数 (C语言)"},{"content":"题目 1815: [2014年第五届真题]排列序数 时间限制: 1Sec 内存限制: 128MB\n题目描述 如果用a b c d这4个字母组成一个串，有4!=24种，如果把它们排个序，每个串都对应一个序号： abcd 0 abdc 1 acbd 2 acdb 3 adbc 4 adcb 5 bacd 6 badc 7 bcad 8 bcda 9 bdac 10 bdca 11 cabd 12 cadb 13 cbad 14 cbda 15 cdab 16 cdba 17 \u0026hellip; 现在有不多于10个两两不同的小写字母，给出它们组成的串，你能求出该串在所有排列中的序号吗？\n输入 一行，一个串。\n输出 一行，一个整数，表示该串在其字母所有排列生成的串中的序号。注意：最小的序号是0。\n样例输入 1 bdca 样例输出 1 11 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; char s[11],p[11],d[11],c; //p用来存放s数组(不变的) d用来记录s数组(变的) int cd,num=0,b[11]; //b用来标记； cd记录数组的长度； num计数 void dfs(int x) { int i,j; if(x==cd) //如果x的长度和cd长度一样 num++ { num++; if(strcmp(p,d)==0) //如果当前数组与s数组一样 就输出（num-1）因为abcd是1 { printf(\u0026#34;%d\u0026#34;,num-1); } return ; } for(i=0;i\u0026lt;cd;i++) { if(!b[i]) { d[x]=s[i]; //记录 b[i]=1; //标记 dfs(x+1); //dfs b[i]=0; //回溯 } } } int main() { int i,j,n=0; scanf(\u0026#34;%s\u0026#34;,s); //输入 strcpy(p,s); //复制到p数组 cd=strlen(s); //记录长度 for(i=0;i\u0026lt;strlen(s)-1;i++) //冒泡法排序 { for(j=0;j\u0026lt;strlen(s)-1-i;j++) { if(s[j]\u0026gt;s[j+1]) { c=s[j]; s[j]=s[j+1]; s[j+1]=c; } } } memset(b,0,sizeof(b)); //把b置零 把一开始的置零也行 dfs(0); //dfs return 0; } 通过C语言网编译运行 ","date":"2020-04-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1815-2014%E5%B9%B4%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%9F%E9%A2%98%E6%8E%92%E5%88%97%E5%BA%8F%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1815 [2014年第五届真题]排列序数 (C语言)"},{"content":"计算机视觉 - 实验六 哈夫变换实验 实验目的和要求 理解哈夫变换的基本原理；掌握使用OpenCV实现哈夫变换的代码编写方法。\n实验内容 （一）新建工程;\n（二）在VS2015中配置OpenCV;\n（三）使用OpenCV中的函数实现哈夫变换检测线段。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）在图像处理和计算机视觉领域中，如何从当前的图像提取所需要的特征信息是图像识别的关键所在。在许多应用场什中需要快速准确地检测出直线或者圆，其中一种非常有效的解决问题的方法是哈夫变换。\n（二）哈夫线变换是一种用来寻找直线的方法，在使用哈夫线变换之前，首先要对图像进行边缘检测的处理，即哈夫线变换的直接输入只能是边缘二值图像。\n（三）在OpenCV中，可以用HoughLines函数来调用标准哈夫变换和多尺度哈夫变换。而HoughLinesP函数用于调用累计概率霍夫变换。累计概率霍夫变换执行效率很高，相比于HoughLines函数，我们更倾向于使用HoughLinesP函数。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用HoughLines或者HoughLinesP函数实现哈夫线变换检测线段。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）HoughLines或者HoughLinesP函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 //--------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026lt;opencv2/opencv.hpp\u0026gt; #include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt; #include \u0026lt;opencv2/imgproc/imgproc.hpp\u0026gt; using namespace std; using namespace cv; //--------------------------------【全局变量声明部分】----------------------------------- //\t描述：全局变量声明 //------------------------------------------------------------------------------------- Mat g_srcImage, g_dstImage,g_midImage;//原始图、中间图和效果图 vector\u0026lt;Vec4i\u0026gt; g_lines;//定义一个矢量结构g_lines用于存放得到的线段矢量集合 //变量接收的TrackBar位置参数 int g_nthreshold=100; //--------------------------------【全局函数声明部分】----------------------------------- //\t描述：全局函数声明 //------------------------------------------------------------------------------------- static void on_HoughLines(int, void*);//回调函数 static void ShowHelpText(); //-------------------------------【main( )函数】----------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main( ) { //改变console字体颜色 system(\u0026#34;color 4F\u0026#34;); ShowHelpText(); //载入原始图和Mat变量定义 Mat g_srcImage = imread(\u0026#34;1.jpg\u0026#34;); //工程目录下应该有一张名为1.jpg的素材图 //显示原始图 imshow(\u0026#34;【原始图】\u0026#34;, g_srcImage); //创建滚动条 namedWindow(\u0026#34;【效果图】\u0026#34;,1); createTrackbar(\u0026#34;值\u0026#34;, \u0026#34;【效果图】\u0026#34;,\u0026amp;g_nthreshold,200,on_HoughLines); //进行边缘检测和转化为灰度图 Canny(g_srcImage, g_midImage, 50, 200, 3);//进行一次canny边缘检测 imshow(\u0026#34;canny\u0026#34;, g_midImage); cvtColor(g_midImage,g_dstImage, COLOR_GRAY2BGR);//转化边缘检测后的图为灰度图 //调用一次回调函数，调用一次HoughLinesP函数 on_HoughLines(g_nthreshold,0); HoughLinesP(g_midImage, g_lines, 1, CV_PI/180, 80, 50, 10 ); //显示效果图 imshow(\u0026#34;【效果图】\u0026#34;, g_dstImage); waitKey(0); return 0; } //---------------------------------【on_HoughLines( )函数】------------------------------ //\t描述：【顶帽运算/黑帽运算】窗口的回调函数 //------------------------------------------------------------------------------------- static void on_HoughLines(int, void*) { //定义局部变量储存全局变量 Mat dstImage=g_dstImage.clone(); Mat midImage=g_midImage.clone(); //调用HoughLinesP函数 //CV_EXPORTS_W void HoughLinesP(InputArray image, OutputArray lines, //\tdouble rho, double theta, int threshold, //\tdouble minLineLength = 0, double maxLineGap = 0); //image： 必须是二值图像，推荐使用canny边缘检测的结果图像； //rho: 线段以像素为单位的距离精度，double类型的，推荐用1.0 //theta： 线段以弧度为单位的角度精度，推荐用numpy.pi / 180 //threshod : 累加平面的阈值参数，int类型，超过设定阈值才被检测出线段，值越大，基本上意味着检出的线段越长，检出的线段个数越少。根据情况推荐先用100试试 //lines：这个参数的意义未知，发现不同的lines对结果没影响，但是不要忽略了它的存在 //minLineLength：线段以像素为单位的最小长度，根据应用场景设置 //maxLineGap：同一方向上两条线段判定为一条线段的最大允许间隔（断裂），超过了设定值，则把两条线段当成一条线段，值越大，允许线段上的断裂越大，越有可能检出潜在的直线段 vector\u0026lt;Vec4i\u0026gt; mylines; HoughLinesP(midImage, mylines, 1, CV_PI/180, g_nthreshold+1, 50, 10 ); //循环遍历绘制每一条线段 for( size_t i = 0; i \u0026lt; mylines.size(); i++ ) { Vec4i l = mylines[i]; line( dstImage, Point(l[0], l[1]), Point(l[2], l[3]), Scalar(23,180,55), 1, LINE_AA); } //显示图像 imshow(\u0026#34;【效果图】\u0026#34;,dstImage); } //--------------------------------【ShowHelpText( )函数】-------------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第64个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf(\u0026#34;\\n\\n\\n\\t请调整滚动条观察图像效果~\\n\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是理解哈夫变换的基本原理；掌握使用OpenCV实现哈夫变换的代码编写方法。新建工程，在VS2015中配置OpenCV，使用OpenCV中的函数实现哈夫变换检测线段。使用HoughLines函数来调用标准哈夫变换和多尺度哈夫变换，HoughLinesP函数用于调用累计概率霍夫变换。通过编写代码，我学会了使用HoughLines函数来调用标准哈夫变换和多尺度哈夫变换，使用HoughLinesP函数来调用累计概率霍夫变换。\n","date":"2020-04-01T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%93%88%E5%A4%AB%E5%8F%98%E6%8D%A2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验六 哈夫变换实验"},{"content":"计算机视觉 - 实验五 边缘检测实验 实验目的和要求 （一）通过实验掌握图像的canny边缘检测的原理和编程实现方法；\n（二）通过实验掌握图像的sobel边缘检测的原理和编程实现方法；\n（三）通过实验掌握图像的scharr滤波器的原理和编程实现方法。\n实验内容 （一）使用OpenCV中的Canny函数实现边缘检测;\n（二）使用OpenCV中的Sobel函数实现边缘检测;\n（三）使用OpenCV中的Scharr函数实现边缘检测。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）最优边缘检测的三个主要评价标准。低错误率：标识出尽可能多的实际边缘，同时尽可能地减少噪声产生的误报；高定位性：标识出的边缘要与图像中的实际边缘尽可能接近；最小响应：图像中的边缘只能标识一次，并且可能存在的图像噪声不应标识为边缘。\n（二）Canny边缘检测算子是John F.Canny于1986年开发出来的一个多级边缘检测算法。Canny 算法被推崇为当今最优的边缘检测的算法。\n（三）Sobel算子是一个主要用于边缘检测的离散微分算子。它结合了高斯平滑和徽分求导，用来计算图像灰度函数的近似梯度。scharr一般称它为滤波器，而不是算子，它在OpenCV中主要是配合Sobel算子的运算而存在的。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用Canny函数实现边缘检测；\n（四）编写代码，使用Sobel函数实现边缘检测；\n（五）编写代码，使用Scharr函数实现边缘检测。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）Canny函数、Sobel函数、Scharr函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 //--------------------------------【头文件、命名空间包含部分】---------------------------- //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt; #include \u0026lt;opencv2/imgproc/imgproc.hpp\u0026gt; using namespace cv; //--------------------------------【全局变量声明部分】----------------------------------- //\t描述：全局变量声明 //------------------------------------------------------------------------------------- //原图，原图的灰度版，目标图 Mat g_srcImage, g_srcGrayImage,g_dstImage; //Canny边缘检测相关变量 Mat g_cannyDetectedEdges; int g_cannyLowThreshold=1;//TrackBar位置参数 //Sobel边缘检测相关变量 Mat g_sobelGradient_X, g_sobelGradient_Y; Mat g_sobelAbsGradient_X, g_sobelAbsGradient_Y; int g_sobelKernelSize=1;//TrackBar位置参数 //Scharr滤波器相关变量 Mat g_scharrGradient_X, g_scharrGradient_Y; Mat g_scharrAbsGradient_X, g_scharrAbsGradient_Y; //--------------------------------【全局函数声明部分】----------------------------------- //\t描述：全局函数声明 //------------------------------------------------------------------------------------- static void ShowHelpText( ); static void on_Canny(int, void*);//Canny边缘检测窗口滚动条的回调函数 static void on_Sobel(int, void*);//Sobel边缘检测窗口滚动条的回调函数 void Scharr( );//封装了Scharr边缘检测相关代码的函数 //-------------------------------【main( )函数】----------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main( int argc, char** argv ) { //改变console字体颜色 system(\u0026#34;color 2F\u0026#34;); //显示欢迎语 ShowHelpText(); //载入原图 g_srcImage = imread(\u0026#34;1.jpg\u0026#34;); if( !g_srcImage.data ) { printf(\u0026#34;Oh，no，读取srcImage错误~！ \\n\u0026#34;); return false; } //显示原始图 namedWindow(\u0026#34;【原始图】\u0026#34;); imshow(\u0026#34;【原始图】\u0026#34;, g_srcImage); // 创建与src同类型和大小的矩阵(dst) g_dstImage.create( g_srcImage.size(), g_srcImage.type() ); // 将原图像转换为灰度图像 cvtColor( g_srcImage, g_srcGrayImage, COLOR_BGR2GRAY ); // 创建显示窗口 namedWindow( \u0026#34;【效果图】Canny边缘检测\u0026#34;, WINDOW_AUTOSIZE ); namedWindow( \u0026#34;【效果图】Sobel边缘检测\u0026#34;, WINDOW_AUTOSIZE ); // 创建trackbar createTrackbar( \u0026#34;参数值：\u0026#34;, \u0026#34;【效果图】Canny边缘检测\u0026#34;, \u0026amp;g_cannyLowThreshold, 120, on_Canny ); createTrackbar( \u0026#34;参数值：\u0026#34;, \u0026#34;【效果图】Sobel边缘检测\u0026#34;, \u0026amp;g_sobelKernelSize, 3, on_Sobel ); // 调用回调函数 on_Canny(0, 0); on_Sobel(0, 0); //调用封装了Scharr边缘检测代码的函数 Scharr( ); //轮询获取按键信息，若按下Q，程序退出 while((char(waitKey(1)) != \u0026#39;q\u0026#39;)) {} return 0; } //--------------------------------【ShowHelpText( )函数】-------------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- static void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第60个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); //输出一些帮助信息 printf( \u0026#34;\\n\\n\\t运行成功，请调整滚动条观察图像效果~\\n\\n\u0026#34; \u0026#34;\\t按下“q”键时，程序退出。\\n\u0026#34;); } //----------------------------------【on_Canny( )函数】---------------------------------- //\t描述：Canny边缘检测窗口滚动条的回调函数 //------------------------------------------------------------------------------------- void on_Canny(int, void*) { // 先使用 3x3内核来降噪 blur( g_srcGrayImage, g_cannyDetectedEdges, Size(3,3) ); // 运行我们的Canny算子 //void cvCanny( //\tconst CvArr* image, //第一个参数表示输入图像，必须为单通道灰度图 //\tCvArr* edges, //第二个参数表示输出的边缘图像，为单通道黑白图 //\tdouble threshold1, //\tdouble threshold2, //第三个参数和第四个参数表示阈值，这二个阈值中当中的小阈值用来控制边缘连接， //\t大的阈值用来控制强边缘的初始分割即如果一个像素的梯度大与上限值，则被认为 //\t是边缘像素，如果小于下限阈值，则被抛弃。如果该点的梯度在两者之间则当这个 //\t点与高于上限值的像素点连接时我们才保留，否则删除。 //\tint aperture_size = 3 //第五个参数表示Sobel 算子大小，默认为3即表示一个3*3的矩阵。Sobel 算子与 //\t高斯拉普拉斯算子都是常用的边缘算子 //\t); Canny( g_cannyDetectedEdges, g_cannyDetectedEdges, g_cannyLowThreshold, g_cannyLowThreshold*3, 3 ); //先将g_dstImage内的所有元素设置为0 g_dstImage = Scalar::all(0); //使用Canny算子输出的边缘图g_cannyDetectedEdges作为掩码，来将原图g_srcImage拷到目标图g_dstImage中 g_srcImage.copyTo( g_dstImage, g_cannyDetectedEdges); //显示效果图 imshow( \u0026#34;【效果图】Canny边缘检测\u0026#34;, g_dstImage ); imshow( \u0026#34;g_cannyDetectedEdges\u0026#34;, g_cannyDetectedEdges); } //----------------------------------【on_Sobel( )函数】---------------------------------- //\t描述：Sobel边缘检测窗口滚动条的回调函数 //------------------------------------------------------------------------------------- void on_Sobel(int, void*) { // 求 X方向梯度 //void Sobel(InputArray src, OutputArray dst, int ddepth, //\tint dx, int dy, int ksize = 3, //第四个参数，int类型dx，x 方向上的差分阶数。 //第五个参数，int类型dy，y方向上的差分阶数。 Sobel( g_srcImage, g_sobelGradient_X, CV_16S, 1, 0, (2*g_sobelKernelSize+1)); convertScaleAbs( g_sobelGradient_X, g_sobelAbsGradient_X );//计算绝对值，并将结果转换成8位 //显示效果图 imshow(\u0026#34;【效果图】Sobel边缘检测x\u0026#34;, g_sobelAbsGradient_X); // 求Y方向梯度 Sobel( g_srcImage, g_sobelGradient_Y, CV_16S, 0, 1, (2*g_sobelKernelSize+1)); convertScaleAbs( g_sobelGradient_Y, g_sobelAbsGradient_Y );//计算绝对值，并将结果转换成8位 imshow(\u0026#34;【效果图】Sobel边缘检测y\u0026#34;, g_sobelAbsGradient_Y); // 合并梯度 //void addWeighted(InputArray src1, double alpha, InputArray src2, //\tdouble beta, double gamma, OutputArray dst, int dtype = -1); //dst = src1*alpha + src2*beta + gamma; addWeighted( g_sobelAbsGradient_X, 0.5, g_sobelAbsGradient_Y, 0.5, 0, g_dstImage ); //显示效果图 imshow(\u0026#34;【效果图】Sobel边缘检测\u0026#34;, g_dstImage); } //-----------------------------------【Scharr( )函数】---------------------------------- //\t描述：封装了Scharr边缘检测相关代码的函数 //------------------------------------------------------------------------------------- void Scharr( ) { // 求 X方向梯度 Scharr( g_srcImage, g_scharrGradient_X, CV_16S, 1, 0); //void convertScaleAbs(InputArray src, OutputArray dst, //\tdouble alpha = 1, double beta = 0); //先缩放元素再取绝对值，最后转换格式为8bit型 convertScaleAbs( g_scharrGradient_X, g_scharrAbsGradient_X );//计算绝对值，并将结果转换成8位 //显示效果图 imshow(\u0026#34;【效果图】Scharr滤波器x\u0026#34;, g_scharrAbsGradient_X); // 求Y方向梯度 Scharr( g_srcImage, g_scharrGradient_Y, CV_16S, 0, 1); convertScaleAbs( g_scharrGradient_Y, g_scharrAbsGradient_Y );//计算绝对值，并将结果转换成8位 imshow(\u0026#34;【效果图】Scharr滤波器y\u0026#34;, g_scharrAbsGradient_Y); // 合并梯度 addWeighted( g_scharrAbsGradient_X, 0.5, g_scharrAbsGradient_Y, 0.5, 0, g_dstImage ); //显示效果图 imshow(\u0026#34;【效果图】Scharr滤波器\u0026#34;, g_dstImage); } （二）显示结果\n实验总结 本次实验的主要内容是掌握图像的canny边缘检测的原理和编程实现方法、掌握图像的sobel边缘检测的原理和编程实现方法、掌握图像的scharr滤波器的原理和编程实现方法。使用OpenCV中的Canny函数实现边缘检测、使用OpenCV中的Sobel函数实现边缘检测、使用OpenCV中的Scharr函数实现边缘检测。通过编写代码，我学会了使用Canny函数、Sobel函数和Scharr函数实现边缘检测。\n","date":"2020-03-30T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%BA%94-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验五 边缘检测实验"},{"content":"题目 1427: [2014年第五届真题]分糖果 时间限制: 1Sec 内存限制: 128MB\n题目描述 有n个小朋友围坐成一圈。老师给每个小朋友随机发偶数个糖果，然后进行下面的游戏：\n每个小朋友都把自己的糖果分一半给左手边的孩子。\n一轮分糖后，拥有奇数颗糖的孩子由老师补给1个糖果，从而变成偶数。\n反复进行这个游戏，直到所有小朋友的糖果数都相同为止。\n你的任务是预测在已知的初始糖果情形下，老师一共需要补发多少个糖果。\n输入 程序首先读入一个整数N(2\u0026lt; N\u0026lt; 100)，表示小朋友的人数。 接着是一行用空格分开的N个偶数（每个偶数不大于1000，不小于2）\n输出 要求程序输出一个整数，表示老师需要补发的糖果数。\n样例输入 1 2 3 2 2 4 样例输出 1 4 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;stdio.h\u0026gt; int main() { int a,i,j,k,sum=0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a);//输入的几个小朋友 int student[a]; for(i=0;i\u0026lt;a;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;student[i]);//每个小朋友手上的糖果 } while(1){ j=1;//另标志位为1,为0是表示不满足条件,需要分糖果 for(i=0;i\u0026lt;a-1;i++){ if(student[i]!=student[i+1]){ j=0;//一旦有一位不相同就标志位置0并跳出这个循环 break; } } if(j==0){//如果不满足条件,开始分糖果 int c=student[0]/2;//第一位的分出糖果数记录一下,留给最后一位同学,因为是围在一起坐的,所以是一个循环 for(i=0;i\u0026lt;a;i++){ student[i]=student[i]/2;//每个同学的糖果数都减半 if(i\u0026gt;=1){ student[i-1]+=student[i];//从0位开始加上后一位同学给的糖果,这样过后就剩最后一个同学是没有人分糖果给他,那么我们一位的同学的糖果就可以给他了 } } student[a-1]+=c;//最后一个同学的糖果给他 for(i=0;i\u0026lt;a;i++){//分完糖果如果有同学手上是奇数糖果,就老师就给他一个,+1,并让sum+1记录老师给的糖果数,最后输出 if(student[i]%2!=0){ sum++;//记录 student[i]++;//老师给了一个糖果,所以+1; } } } else{ printf(\u0026#34;%d\u0026#34;,sum);//满足条件的情况下j不会置0,进入这个输出后brake跳出while循环,至此整个函数运行完毕 break; } } return 0; } 通过C语言网编译运行 ","date":"2020-03-28T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1427-2014%E5%B9%B4%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%9F%E9%A2%98%E5%88%86%E7%B3%96%E6%9E%9C-c%E8%AF%AD%E8%A8%80/","title":"题目 1427 [2014年第五届真题]分糖果 (C语言)"},{"content":"题目 1609: [算法训练VIP]黑色星期五 时间限制: 1Sec 内存限制: 128MB\n题目描述 有些西方人比较迷信，如果某个月的13号正好是星期五，他们就会觉得不太吉利，用古人的说法，就是“诸事不宜”。请你编写一个程序，统计出在某个特定的年份中，出现了多少次既是13号又是星期五的情形，以帮助你的迷信朋友解决难题。 说明：（1）一年有365天，闰年有366天，所谓闰年，即能被4整除且不能被100整除的年份，或是既能被100整除也能被400整除的年份；（2）已知1998年1月1日是星期四，用户输入的年份肯定大于或等于1998年。\n输入 输入只有一行，即某个特定的年份（大于或等于1998年）。\n输出 输出只有一行，即在这一年中，出现了多少次既是13号又是星期五的情形。\n样例输入 1 1998 样例输出 1 3 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include\u0026lt;stdio.h\u0026gt; int day[14]; int month[2][20]={{31,28,31,30,31,30,31,31,30,31,30,31},{31,29,31,30,31,30,31,31,30,31,30,31}}; int leap(int year) { if ((year % 4 == 0 \u0026amp;\u0026amp; year % 100 != 0) || year % 400 == 0) { //是闰年 return 1; }else{ //不是闰年 return 0; } } void f(int n) { int i,j; long sum=0; int count = 0; for(i=1998;i\u0026lt;n;i++) { if(leap(i)) { sum += 366; }else{ sum += 365; } } //统计每个月的13号距1998年1月1日有几天 if(leap(n)) { for(i=1;i\u0026lt;13;i++) { day[i]=12+sum; for(j=0;j\u0026lt;i-1;j++) { day[i] +=month[1][j]; } } }else{ for(i=1;i\u0026lt;13;i++) { day[i]=12+sum; for(j=0;j\u0026lt;i-1;j++) { day[i] += month[0][j]; } } } //统计星期5出现的次数 for(i=1;i\u0026lt;=12;i++) { if((day[i]-3)%7==5) { count ++; } } printf(\u0026#34;%d\\n\u0026#34;,count); } int main() { int year; scanf(\u0026#34;%d\u0026#34;,\u0026amp;year); f(year); return 0; } 通过C语言网编译运行 ","date":"2020-03-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1609-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98vip%E9%BB%91%E8%89%B2%E6%98%9F%E6%9C%9F%E4%BA%94-c%E8%AF%AD%E8%A8%80/","title":"题目 1609 [算法提高VIP]黑色星期五 (C语言)"},{"content":"题目 1616: [算法训练VIP]传球游戏 时间限制: 1Sec 内存限制: 128MB\n题目描述 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方 法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方 式有1-\u0026gt; 2-\u0026gt; 3-\u0026gt; 1和1-\u0026gt; 3-\u0026gt; 2-\u0026gt; 1，共2种。\n输入 共一行，有两个用空格隔开的整数n，m（3\u0026lt; =n\u0026lt; =30，1\u0026lt; =m\u0026lt; =30）。\n数据规模和约定 100%的数据满足：3\u0026lt; =n\u0026lt; =30，1\u0026lt; =m\u0026lt; =30\n输出 t共一行，有一个整数，表示符合题意的方法数。\n样例输入 1 3 3 样例输出 1 2 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; int n; int main(){ int at(int); int m,i,j,f[31][31] = {0}; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); f[1][2] = f[1][n] = 1; //第1次传球，1号只可能传给2号或n号 for(i = 2;i \u0026lt;= m;i++) //从第2次到第m次传球 for(j = 1;j \u0026lt;= n;j++) //每次传给1号到n号的可能，取决于上次球传到相邻位置的可能 f[i][j] = f[i - 1][at(j - 1)] + f[i - 1][at(j + 1)]; printf(\u0026#34;%d\u0026#34;,f[m][1]); //第m次传球，传给1号的可能方式有几种 return 0; } int at(int x){ //站成圆圈传球 if(x\u0026lt;1) return x + n; //编号减少到0时，传到编号n if(x\u0026gt;n) return x - n; //编号增加到n+1时，传到编号1 return x; } 通过C语言网编译运行 ","date":"2020-03-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1616-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98vip%E4%BC%A0%E7%90%83%E6%B8%B8%E6%88%8F-c%E8%AF%AD%E8%A8%80/","title":"题目 1616 [算法提高VIP]传球游戏 (C语言)"},{"content":"题目 1629: [算法训练VIP]接水问题 时间限制: 1Sec 内存限制: 128MB\n题目描述 学校里有一个水房，水房里一共装有 m 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 1。\n现在有 n 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 1 到 n 编号，i号同学的接水量为 wi。接水开始时，1 到 m 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 j 完成其接水量要求 wj后，下一名排队等候接水的同学 k 马上接替 j 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 j 同学第 x 秒结束时完成接水，则 k 同学第 x+1 秒立刻开始接水。 若当前接水人数 n’不足 m，则只有 n’个龙头供水，其它 m-n’个龙头关闭。\n现在给出 n 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n输入 第 1 行2 个整数 n 和 m，用一个空格隔开，分别表示接水人数和龙头个数。 第 2 行 n 个整数 w1、w2、……、wn，每两个整数之间用一个空格隔开，wi表示 i 号同学的接水量。 1 ≤ n ≤ 10000，1 ≤ m ≤ 100 且 m ≤ n； 1 ≤ wi ≤ 100。\n输出 输出只有一行，1 个整数，表示接水所需的总时间。\n样例输入 1 2 5 3 4 4 1 2 1 样例输出 1 4 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; int dm[101]={0}; int w[10001]; int t=1; int bj=0; int main() { int n,m,i,j,d=1; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m); for(i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]); while(1) { for(i=1;i\u0026lt;=m;i++) { if(dm[i]==0)//若有水龙头 这一单位时间 没使用 则替换 接水者 { if(d\u0026lt;=n)dm[i]=d++;//dm[i] i 代表 水龙头 编号 dm[i]存储 这一单位时间 接水人编号 } if(dm[i]!=0)//水龙头有人接水 本水龙头接水人节水量-1 { w[dm[i]]-=1; if(w[dm[i]]==0)dm[i]=0;bj=1;}//这一单位本水龙头接水人接水量为0则空出水龙头 } if(bj!=1) break; //bj==1则表示 本次单位时间 有水龙头使用 bj==0则标记本单位时间没水龙头使用则所有过程上一秒已完成 bj=0; t++; } printf(\u0026#34;%d\\n\u0026#34;,t-1); return 0; } 通过C语言网编译运行 ","date":"2020-03-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1629-%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83vip%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98-c%E8%AF%AD%E8%A8%80/","title":"题目 1629 [算法训练VIP]接水问题 (C语言)"},{"content":"题目 1632: [算法训练VIP]数对 时间限制: 1Sec 内存限制: 128MB\n题目描述 编写一个程序，该程序从用户读入一个整数，然后列出所有的数对，每个数对的乘积即为该数。\n输入 输入只有一行，即一个整数。\n输出 输出有若干行，每一行是一个乘法式子。（注意：运算符号与数字之间有一个空格）\n样例输入 1 32 样例输出 1 2 3 4 5 6 1 * 32 = 32 2 * 16 = 32 4 * 8 = 32 8 * 4 = 32 16 * 2 = 32 32 * 1 = 32 C代码 1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main(){ int i,n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(i=1;i\u0026lt;=n;i++){ if(n%i==0)printf(\u0026#34;%d * %d = %d\\n\u0026#34;,i,n/i,n); } } 通过C语言网编译运行 ","date":"2020-03-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1632-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98vip%E6%95%B0%E5%AF%B9-c%E8%AF%AD%E8%A8%80/","title":"题目 1632 [算法提高VIP]数对 (C语言)"},{"content":"题目 1648: [算法训练VIP]求先序排列 时间限制: 1Sec 内存限制: 128MB\n题目描述 给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度\u0026lt; =8）。\n输入 两行，每行一个字符串，分别表示中序和后序排列\n输出 一个字符串，表示所求先序排列\n样例输入 1 2 BADC BDCA 样例输出 1 ABCD C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #define Max(x,y) x\u0026gt;y?x:y char s[100],s1[100]; void Pd(char *x,char *x1) { int i,j,k,l,p; char c; char x3[100],x4[100];//X3:x的左 X4:x的右 char x6[100],x7[100];//X6:x1的左 X7:x1的右 int t=strlen(x1)-1; c=x1[t];//输出后序序列的最后一位 (根节点) printf(\u0026#34;%c\u0026#34;,c); p=strlen(x); for(i=0;x[i];i++) { if(c==x[i]) { break; } x3[i]=x[i];//把X的前i个放入左节点的中序 X1的前i个放入右节点的中序 x6[i]=x1[i]; } x3[i]=\u0026#39;\\0\u0026#39;;//别忘了 x6[i]=\u0026#39;\\0\u0026#39;; k=0; for(l=i+1;l\u0026lt;p;l++)//把X i后边(i是根节点)的数放入x4 { x4[k++]=x[l]; } x4[k]=\u0026#39;\\0\u0026#39;; k=0; for(l=i;l\u0026lt;p-1;l++)//把X1 的i---（最后-1）放入x7中(因为最后是根节点) { x7[k++]=x1[l]; } x7[k]=\u0026#39;\\0\u0026#39;; if(x3[0]) Pd(x3,x6); if(x4[0]) Pd(x4,x7); } int main() { int i,j; scanf(\u0026#34;%s\u0026#34;,s); scanf(\u0026#34;%s\u0026#34;,s1); Pd(s,s1); return 0; } 通过C语言网编译运行 ","date":"2020-03-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1648-%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83vip%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97-c%E8%AF%AD%E8%A8%80/","title":"题目 1648 [算法训练VIP]求先序排列 (C语言)"},{"content":"计算机视觉 - 实验四 图像非线性滤波实验 实验目的和要求 （一）通过实验掌握图像的中值滤波原理和编程实现方法；\n（二）通过实验掌握图像的双边滤波原理和编程实现方法。\n实验内容 （一）使用OpenCV中的medianBlur函数实现中值滤波;\n（二）使用OpenCV中的bilateralFilter函数实现双边滤波。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）图像滤波，指在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。\n（二）在很多情况下，需要使用邻域像素的非线性滤披得到更好的效果。比如噪声是散粒噪声而不是高斯噪声，即图像偶尔会出现很大的值的时候，用高斯滤波器对图像进行模糊的话，噪声像素是不会被去除的，它们只是转换为更为柔和但仍然可见的散粒。此时使用中值滤波就可以达到更好的效果。\n（三）双边滤波是一种非线性的滤波方法，是结合图像的空间邻近度和像素值相似度的一种折中处理，同时考虑空域信息和灰度相似性，达到保边去噪的目的，具有简单、局部的特点。\n（四）在OpenCV中，使用medianBlur函数实现中值滤波，使用bilateralFilter函数实现双边滤波。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用medianBlur函数实现中值滤波；\n（四）使用bilateralFilter函数实现双边滤波。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）medianBlur函数、bilateralFilter函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 //---------------------------------【头文件包含部分】------------------------------------ //\t描述：包含程序所依赖的头文件 //------------------------------------------------------------------------------------- #include \u0026lt;opencv2/core/core.hpp\u0026gt; #include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt; #include \u0026lt;opencv2/imgproc/imgproc.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; //--------------------------------【命名空间声明部分】----------------------------------- //\t描述：包含程序所使用的命名空间 //------------------------------------------------------------------------------------- using namespace std; using namespace cv; //---------------------------------【全局变量声明部分】---------------------------------- //\t描述：全局变量声明 //------------------------------------------------------------------------------------- Mat g_srcImage,g_dstImage1,g_dstImage2,g_dstImage3,g_dstImage4,g_dstImage5; int g_nBoxFilterValue=6; //方框滤波内核值 int g_nMeanBlurValue=10; //均值滤波内核值 int g_nGaussianBlurValue=6; //高斯滤波内核值 int g_nMedianBlurValue=10; //中值滤波参数值 int g_nBilateralFilterValue=10; //双边滤波参数值 //--------------------------------【全局函数声明部分】----------------------------------- //\t描述：全局函数声明 //------------------------------------------------------------------------------------- //轨迹条回调函数 static void on_BoxFilter(int, void *);\t//方框滤波 static void on_MeanBlur(int, void *);\t//均值块滤波器 static void on_GaussianBlur(int, void *);\t//高斯滤波器 static void on_MedianBlur(int, void *);\t//中值滤波器 static void on_BilateralFilter(int, void *);\t//双边滤波器 void ShowHelpText(); //--------------------------------【main( )函数】---------------------------------------- //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main( ) { system(\u0026#34;color 4F\u0026#34;); ShowHelpText();\t// 载入原图 g_srcImage = imread( \u0026#34;20170829110313260.png\u0026#34;, 1 ); if( !g_srcImage.data ) { printf(\u0026#34;读取srcImage错误~！ \\n\u0026#34;); return false; } //克隆原图到5个Mat类型中 g_dstImage1 = g_srcImage.clone( ); g_dstImage2 = g_srcImage.clone( ); g_dstImage3 = g_srcImage.clone( ); g_dstImage4 = g_srcImage.clone( ); g_dstImage5 = g_srcImage.clone( ); //显示原图 namedWindow(\u0026#34;【\u0026lt;0\u0026gt;原图窗口】\u0026#34;, 1); imshow(\u0026#34;【\u0026lt;0\u0026gt;原图窗口】\u0026#34;,g_srcImage); //=================【\u0026lt;1\u0026gt;方框滤波】========================= //创建窗口 namedWindow(\u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;,\u0026amp;g_nBoxFilterValue, 50,on_BoxFilter ); on_MeanBlur(g_nBoxFilterValue,0); imshow(\u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, g_dstImage1); //===================================================== //=================【\u0026lt;2\u0026gt;均值滤波】========================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;,\u0026amp;g_nMeanBlurValue, 50,on_MeanBlur ); on_MeanBlur(g_nMeanBlurValue,0); //====================================================== //=================【\u0026lt;3\u0026gt;高斯滤波】=========================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;,\u0026amp;g_nGaussianBlurValue, 50,on_GaussianBlur ); on_GaussianBlur(g_nGaussianBlurValue,0); //======================================================= //=================【\u0026lt;4\u0026gt;中值滤波】=========================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;4\u0026gt;中值滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;参数值：\u0026#34;, \u0026#34;【\u0026lt;4\u0026gt;中值滤波】\u0026#34;,\u0026amp;g_nMedianBlurValue, 50,on_MedianBlur ); on_MedianBlur(g_nMedianBlurValue,0); //======================================================= //=================【\u0026lt;5\u0026gt;双边滤波】=========================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;5\u0026gt;双边滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;参数值：\u0026#34;, \u0026#34;【\u0026lt;5\u0026gt;双边滤波】\u0026#34;,\u0026amp;g_nBilateralFilterValue, 50,on_BilateralFilter); on_BilateralFilter(g_nBilateralFilterValue,0); //======================================================= //输出一些帮助信息 cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t运行成功，请调整滚动条观察图像效果~\\n\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;\\t按下“q”键时，程序退出。\\n\u0026#34;; while(char(waitKey(1)) != \u0026#39;q\u0026#39;) {} return 0; } //-----------------------------【on_BoxFilter( )函数】---------------------------------- //\t描述：方框滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_BoxFilter(int, void *) { //方框滤波操作 boxFilter( g_srcImage, g_dstImage1, -1,Size( g_nBoxFilterValue+1, g_nBoxFilterValue+1)); //显示窗口 imshow(\u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, g_dstImage1); } //-----------------------------【on_MeanBlur( )函数】------------------------------------ //\t描述：均值滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_MeanBlur(int, void *) { blur( g_srcImage, g_dstImage2, Size( g_nMeanBlurValue+1, g_nMeanBlurValue+1), Point(-1,-1)); imshow(\u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;, g_dstImage2); } //----------------------------【on_GaussianBlur( )函数】--------------------------------- //\t描述：高斯滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_GaussianBlur(int, void *) { GaussianBlur( g_srcImage, g_dstImage3, Size( g_nGaussianBlurValue*2+1, g_nGaussianBlurValue*2+1 ), 0, 0); imshow(\u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;, g_dstImage3); } //-----------------------------【on_MedianBlur( )函数】--------------------------------- //\t描述：中值滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_MedianBlur(int, void *) { medianBlur ( g_srcImage, g_dstImage4, g_nMedianBlurValue*2+1 ); imshow(\u0026#34;【\u0026lt;4\u0026gt;中值滤波】\u0026#34;, g_dstImage4); } //-------------------------【on_BilateralFilter( )函数】--------------------------------- //\t描述：双边滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_BilateralFilter(int, void *) { bilateralFilter ( g_srcImage, g_dstImage5, g_nBilateralFilterValue, g_nBilateralFilterValue*2, g_nBilateralFilterValue/2 ); imshow(\u0026#34;【\u0026lt;5\u0026gt;双边滤波】\u0026#34;, g_dstImage5); } //-----------------------------------【ShowHelpText( )函数】----------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第37个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是掌握图像的中值滤波原理和编程实现方法、掌握图像的双边滤波原理和编程实现方法。使用OpenCV中的medianBlur函数实现中值滤波、使用OpenCV中的bilateralFilter函数实现双边滤波。通过编写代码，我学会了使用medianBlur函数和bilateralFilter函数实现中值滤波和双边滤波。\n","date":"2020-03-18T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E5%9B%BE%E5%83%8F%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验四 图像非线性滤波实验"},{"content":"计算机视觉 - 实验三 图像线性滤波实验 实验目的和要求 （一）通过实验掌握图像的方框滤波原理和编程实现方法；\n（二）通过实验掌握图像的均值滤波原理和编程实现方法；\n（二）通过实验掌握图像的高斯滤波原理和编程实现方法。\n实验内容 （一）使用OpenCV中的boxFilter函数实现方框滤波;\n（二）使用OpenCV中的blur函数实现均值滤波；\n（三）使用OpenCV中的GaussianBlur函数实现高斯滤波。\n实验仪器、设备 计算机一台，已安装 Windows7操作系统和Visual Studio 2015\n实验原理 （一）图像滤波，指在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。线性滤波器每个像素的输出值是一些输入像素的加权和。线性滤波器易于构造，井且易于从频率响应角度来进行分析。\n（二）在OpenCV中，提供了如下三种常用的线性滤波操作，它们分别被封装在单独的函数中，使用起来非常方便，分别是：方框滤波boxFilter函数，均值滤波blur函数；高斯滤波GaussianBlur函数。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用boxFilter函数实现方框滤波；\n（四）编写代码，使用blur函数实现均值滤波；\n（五）编写代码，使用gaussianBlur函数实现高斯滤波。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）boxFilter函数、blur函数、gaussianBlur函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 //------------------------------【头文件、命名空间包含部分】------------------------------ //\t描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026lt;opencv2/core/core.hpp\u0026gt; #include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt; #include \u0026lt;opencv2/imgproc/imgproc.hpp\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; using namespace cv; //----------------------------------【全局变量声明部分】--------------------------------- //\t描述：全局变量声明 //------------------------------------------------------------------------------------- Mat g_srcImage,g_dstImage1,g_dstImage2,g_dstImage3;//存储图片的Mat类型 int g_nBoxFilterValue=3; //方框滤波参数值 int g_nMeanBlurValue=3; //均值滤波参数值 int g_nGaussianBlurValue=3; //高斯滤波参数值 //---------------------------------【全局函数声明部分】---------------------------------- //\t描述：全局函数声明 //------------------------------------------------------------------------------------- //四个轨迹条的回调函数 static void on_BoxFilter(int, void *);\t//方框滤波 static void on_MeanBlur(int, void *);\t//均值滤波 static void on_GaussianBlur(int, void *);\t//高斯滤波 void ShowHelpText(); //----------------------------------【main( )函数】------------------------------------ //\t描述：控制台应用程序的入口函数，我们的程序从这里开始 //------------------------------------------------------------------------------------- int main( ) { //改变console字体颜色 system(\u0026#34;color 5F\u0026#34;); //输出帮助文字 ShowHelpText(); // 载入原图 g_srcImage = imread( \u0026#34;20170829110313260.png\u0026#34;, 1 ); if( !g_srcImage.data ) { printf(\u0026#34;Oh，no，读取srcImage错误~！ \\n\u0026#34;); return false; } //克隆原图到三个Mat类型中 g_dstImage1 = g_srcImage.clone( ); g_dstImage2 = g_srcImage.clone( ); g_dstImage3 = g_srcImage.clone( ); //显示原图 namedWindow(\u0026#34;【\u0026lt;0\u0026gt;原图窗口】\u0026#34;, 1); imshow(\u0026#34;【\u0026lt;0\u0026gt;原图窗口】\u0026#34;,g_srcImage); //=================【\u0026lt;1\u0026gt;方框滤波】================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, \u0026amp;g_nBoxFilterValue, 40, on_BoxFilter); on_BoxFilter(g_nBoxFilterValue, 0); //================================================ //=================【\u0026lt;2\u0026gt;均值滤波】================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;,\u0026amp;g_nMeanBlurValue, 40,on_MeanBlur ); on_MeanBlur(g_nMeanBlurValue,0); //================================================ //=================【\u0026lt;3\u0026gt;高斯滤波】===================== //创建窗口 namedWindow(\u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;, 1); //创建轨迹条 createTrackbar(\u0026#34;内核值：\u0026#34;, \u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;,\u0026amp;g_nGaussianBlurValue, 40,on_GaussianBlur ); on_GaussianBlur(g_nGaussianBlurValue,0); //================================================ //输出一些帮助信息 cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t运行成功，请调整滚动条观察图像效果~\\n\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;\\t按下“q”键时，程序退出。\\n\u0026#34;; //按下“q”键时，程序退出 while(char(waitKey(1)) != \u0026#39;q\u0026#39;) {} return 0; } //----------------------------【on_BoxFilter( )函数】------------------------------------ //\t描述：方框滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_BoxFilter(int, void *) { //方框滤波操作，其主要功能是：在给定的滑动窗口大小下，对每个窗口内的像素值进行快速相加求和 boxFilter( g_srcImage, g_dstImage1, -1,Size( g_nBoxFilterValue+1, g_nBoxFilterValue+1)); //显示窗口 imshow(\u0026#34;【\u0026lt;1\u0026gt;方框滤波】\u0026#34;, g_dstImage1); } //-----------------------------【on_MeanBlur( )函数】------------------------------------ //\t描述：均值滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_MeanBlur(int, void *) { //均值滤波操作，均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。 //其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点， //去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。 //. Size ksize : 滤波模板kernel的尺寸，一般使用Size(w, h)来指定，如Size(3, 3) //.Point anchor = Point(-1, -1) : 字面意思是锚点，也就是处理的像素位于kernel的什么位置， //默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改 blur( g_srcImage, g_dstImage2, Size( g_nMeanBlurValue+1, g_nMeanBlurValue+1), Point(-1,-1)); //显示窗口 imshow(\u0026#34;【\u0026lt;2\u0026gt;均值滤波】\u0026#34;, g_dstImage2); } //-----------------------------【ContrastAndBright( )函数】------------------------------ //\t描述：高斯滤波操作的回调函数 //------------------------------------------------------------------------------------- static void on_GaussianBlur(int, void *) { //高斯滤波操作 //void GaussianBlur(InputArray src, OutputArray dst, Size ksize, //\tdouble sigmaX, double sigmaY = 0, //\tint borderType = BORDER_DEFAULT); //. double sigmaX : 高斯核函数在X方向上的标准偏差 //. double sigmaY : 高斯核函数在Y方向上的标准偏差 //如果sigmaX和sigmaY都是0，这两个值将由ksize.width和ksize.height计算而来。 //具体可以参考getGaussianKernel()函数查看具体细节。 GaussianBlur( g_srcImage, g_dstImage3, Size( g_nGaussianBlurValue*2+1, g_nGaussianBlurValue*2+1 ), 0, 0); //显示窗口 imshow(\u0026#34;【\u0026lt;3\u0026gt;高斯滤波】\u0026#34;, g_dstImage3); } //--------------------------------【ShowHelpText( )函数】-------------------------------- //\t描述：输出一些帮助信息 //------------------------------------------------------------------------------------- void ShowHelpText() { //输出欢迎信息和OpenCV版本 printf(\u0026#34;\\n\\n\\t\\t\\t非常感谢购买《OpenCV3编程入门》一书！\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t此为本书OpenCV3版的第34个配套示例程序\\n\u0026#34;); printf(\u0026#34;\\n\\n\\t\\t\\t 当前使用的OpenCV版本为：\u0026#34; CV_VERSION ); printf(\u0026#34;\\n\\n ----------------------------------------------------------------------------\\n\u0026#34;); } （二）显示结果\n实验总结 本次实验的主要内容是掌握图像的方框滤波原理和编程实现方法、掌握图像的均值滤波原理和编程实现方法、掌握图像的高斯滤波原理和编程实现方法。使用OpenCV中的boxFilter函数实现方框滤波、使用OpenCV中的blur函数实现均值滤波、使用OpenCV中的GaussianBlur函数实现高斯滤波。通过编写代码，我学会了使用boxFilter函数、blur函数和GaussianBlur函数实现方框滤波、均值滤波和高斯滤波。\n","date":"2020-03-16T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%B8%89-%E5%9B%BE%E5%83%8F%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E5%AE%9E%E9%AA%8C/","title":"计算机视觉 - 实验三 图像线性滤波实验"},{"content":"计算机视觉 - 实验二 图像的直方图 实验目的和要求 （一）通过实验掌握绘制图像的直方图方法；\n（二）通过实验掌握图像直方图均衡化方法。\n实验内容 （一）使用OpenCV中的calcHist函数计算直方图，计算完成之后，采用OpenCV中的rectangle函数绘制矩形来完成直方图绘制;\n（二）在OpenCV中，使用equalizeHist函数实现直方图均衡化的功能。\n实验仪器、设备 计算机一台，已安装 Windows 7 操作系统和 Visual Studio 2015\n实验原理 （一）直方图的计算在OpenCV中可以使用calcHist函数，而计算完成之后，可以采用 OpenCV中的绘图函数，如绘制矩形的rectangle函数来完成;\n（二）很多时候，用相机拍摄的照片的效果往往会不尽人意。这时可以对这些图像进行一些处理，来扩大图像的动态范围。这种情况下最常用到的技术就是直方图均衡化，经过均衡化的图像，其频谱更加舒展，有效地利用了0-255的空间，图像表现力更加出色；在OpenCV 中，直方图均衡化的功能实现由equalizeHist函数完成。\n实验步骤 （一）创建Visual Studio 2015控制台程序；\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用calcHist函数和rectangle绘制图像直方图；\n（四）编写代码，使用equalizeHist函数完成直方图均衡化。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）calcHist、equalizeHist函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //------------------------------【头文件、命名空间包含部分】--------------------------- // 描述：包含程序所使用的头文件和命名空间 //------------------------------------------------------------------------------------- #include \u0026#34;opencv2/highgui/highgui.hpp\u0026#34; #include \u0026#34;opencv2/imgproc/imgproc.hpp\u0026#34; using namespace cv; //-----------------------------------【main( )函数】------------------------------------- // 描述：控制台应用程序的入口函数，我们的程序从这里开始执行 //------------------------------------------------------------------------------------- Mat drawHist(Mat srcImage) { //【2】定义变量 MatND dstHist; // 在cv中用CvHistogram *hist = cvCreateHist int dims = 1; float hranges[] = { 0, 255 }; const float *ranges[] = { hranges }; // 这里需要为const类型 int size = 256; //设定bin数目，必须和灰度级数目相等，这里是0到255，所以size为256 int channels = 0; //【3】计算图像的直方图 //void calcHist(const Mat* images, int nimages, //\tconst int* channels, InputArray mask, //\tOutputArray hist, int dims, const int* histSize, //\tconst float** ranges, bool uniform = true, bool accumulate = false) //参数1表示需要用来计算直方图的源图像序列，因此可以允许有多张大小一样，数据类型相同的图像被用来统计其直方图特征。 //参数2表示的就是使用多少张图像序列中的图像用于计算直方图。 //参数3的出现主要是考虑到输入的每一张图像有可能是多通道的，比如说RGB图就是3通道的，那么从统计意义上来讲，一张RGB图其实就是3张单通道的图像，而计算直方图时其本质也是针对单张图像进行的。这里虽然我们输入的图像序列images中有很多图片，但是并不是每一张图片的每一个通道都会被用来计算。所以参数3的功能是指定哪些通道的图像被用来计算（后面的解释都假设图像序列中图像是3通道的，那么有的图像可能有多个通道都被用来计算，有的图像可能连一个通道都没有被采用），这时参数3里面保存的是通道的序号，那么图像序列images中的第一张图片的通道序号（假设图像时3通道的）为0, 1, 2；images中第二张图片的图像序列接着上一次的，为3, 4, 5, ；依次类推即可。 //参数4是mask掩膜操作，即指定每张图片的哪些像素被用于计算直方图，这个掩膜矩阵不能够针对特定图像设定特定的掩膜，因此在这里是一视同仁对待的。 //参数5是保存计算的直方图结果的矩阵，有可能是多维矩阵。 //参数6是需要计算的直方图的维数。 //参数7是所需计算直方图的每一维的大小，即每一维bin的个数。 calcHist(\u0026amp;srcImage, 1, \u0026amp;channels, Mat(), dstHist, dims, \u0026amp;size, ranges); // cv 中是cvCalcHist int scale = 1; Mat dstImage(size * scale, size, CV_8U, Scalar(0)); //【4】获取最大值和最小值 double minValue = 0; double maxValue = 0; minMaxLoc(dstHist, \u0026amp;minValue, \u0026amp;maxValue, 0, 0); // 在cv中用的是cvGetMinMaxHistValue //【5】绘制出直方图 //saturate_cast\u0026lt;int\u0026gt;(double v) { return cvRound(v); } int hpt = saturate_cast\u0026lt;int\u0026gt;(0.9 * size);//防止溢出,hpt=230 for (int i = 0; i \u0026lt; 256; i++) { float binValue = dstHist.at\u0026lt;float\u0026gt;(i); // 注意hist中是float类型 而在OpenCV1.0版中用cvQueryHistValue_1D int realValue = saturate_cast\u0026lt;int\u0026gt;(binValue * hpt / maxValue); rectangle(dstImage, Point(i*scale, size - 1), Point((i + 1)*scale - 1, size - realValue), Scalar(255)); } return dstImage; } int main() { // 【1】加载源图像 Mat srcImage, dstImage; srcImage = imread(\u0026#34;1.jpg\u0026#34;, 1); if (!srcImage.data) { printf(\u0026#34;读取图片错误，请确定目录下是否有imread函数指定图片存在~！ \\n\u0026#34;); return false; } // 【2】转为灰度图并显示出来 cvtColor(srcImage, srcImage, COLOR_BGR2GRAY); imshow(\u0026#34;原始图\u0026#34;, srcImage); Mat histSrc = drawHist(srcImage); imshow(\u0026#34;histSrc\u0026#34;, histSrc); // 【3】进行直方图均衡化 equalizeHist(srcImage, dstImage); Mat histDst = drawHist(dstImage); imshow(\u0026#34;histDst\u0026#34;, histDst); // 【4】显示结果 imshow(\u0026#34;经过直方图均衡化后的图\u0026#34;, dstImage); // 等待用户按键退出程序 waitKey(0); return 0; } （二）显示结果\n实验总结 本次实验的主要内容是掌握绘制图像的直方图方法和图像直方图均衡化方法。使用OpenCV中的calcHist函数计算直方图，计算完成之后，采用 OpenCV中的rectangle函数绘制矩形来完成直方图绘制; 在OpenCV中，使用equalizeHist函数实现直方图均衡化的功能。通过编写代码，我学会了使用calcHist函数和rectangle绘制图像直方图；学会了使用equalizeHist函数完成直方图均衡化。\n","date":"2020-03-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%9B%BE%E5%83%8F%E7%9A%84%E7%9B%B4%E6%96%B9%E5%9B%BE/","title":"计算机视觉 - 实验二 图像的直方图"},{"content":"计算机视觉 - 实验一 图像的载入、显示与输出 实验目的和要求 （一）通过实验掌握 Windows 中安装 OpenCV 的方法；\n（二）通过实验掌握图像的载入、显示与输出的方法\n实验内容 （一）Windows中安装OpenCV;\n（二）编写图像的载入、显示与输出的程序.\n实验仪器、设备 计算机一台，已安装 Windows 7 操作系统和 Visual Studio 2015\n实验原理 Opencv用 Mat类来实现图像的存储。图像存储在矩阵格式中，每个像素都有个位置，可以通过列数和行数引用。Mat类不只用于存储图像，而且还可以存储任意大小的不同类型的矩阵。可以使用Mat类执行矩阵加法、矩阵乘法、创建矩阵等操作。imread函数用于读取图像。imwrite函数用于写图像。imshow函数用于显示图像。\n实验步骤 （一）Windows中安装OpenCV\n在网址https://sourceforge.net/projects/opencvlibrary/中下载opencv源代码，在Windows中安装OpenCV。\n（二）在Visual Studio 2015中配置OpenCV；\n（三）编写代码，使用imread函数读取图像；\n（四）编写代码，使用imwrite函数写图像；\n（五）编写代码，使用imshow函数显示图像。\n实验注意事项 （一）完成OpenCV安装之后，VS中配置OpenCV的方法；\n（二）imread、imwrite、imshow函数的功能和使用方法。\n实验结果 （一）实验代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;opencv2/core/core.hpp\u0026gt; #include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt; using namespace cv; int main( ) { //-------------------------------【一、图像的载入和显示】---------------------------- //\t描述：以下三行代码用于完成图像的载入和显示 //--------------------------------------------------------------------------------- cv::Mat girl = cv::imread(\u0026#34;girl.jpg\u0026#34;, 0); //载入图像到Mat namedWindow(\u0026#34;【1】动漫图\u0026#34;); //创建一个名为 \u0026#34;【1】e动漫图\u0026#34;的窗口 imshow(\u0026#34;【1】动漫图\u0026#34;,girl);//显示名为 \u0026#34;【1】动漫图\u0026#34;的窗口 //-------------------------------【二、初级图像混合】--------------------------------- //\t描述：二、初级图像混合 //--------------------------------------------------------------------------------- //载入图片 Mat image = imread(\u0026#34;dota.jpg\u0026#34;); Mat logo = imread(\u0026#34;dota_logo.jpg\u0026#34;); //载入后先显示 namedWindow(\u0026#34;【2】原画图\u0026#34;); imshow(\u0026#34;【2】原画图\u0026#34;,image); namedWindow(\u0026#34;【3】logo图\u0026#34;); imshow(\u0026#34;【3】logo图\u0026#34;,logo); // 定义一个Mat类型，用于存放，图像的ROI Mat imageROI; //方法一 imageROI= image(Rect(800,350,logo.cols,logo.rows)); //方法二 //imageROI= image(Range(350,350+logo.rows),Range(800,800+logo.cols)); // 将logo加到原图上 addWeighted(imageROI,0.5,logo,0.3,0.,imageROI); //显示结果 namedWindow(\u0026#34;【4】原画+logo图\u0026#34;); imshow(\u0026#34;【4】原画+logo图\u0026#34;,image); //--------------------------------【三、图像的输出】---------------------------------- //\t描述：将一个Mat图像输出到图像文件 //--------------------------------------------------------------------------------- //输出一张jpg图片到工程目录下 imwrite(\u0026#34;由imwrite生成的图片.jpg\u0026#34;, image); //imwrite(\u0026#34;由imwrite生成的图片.jpg\u0026#34;, image); waitKey(0); return 0; } （二）显示结果\n实验总结 本次实验的主要内容是编写图像的载入、显示与输出的程序。用到的函数主要有cv::Mat girl=cv::imread(\u0026ldquo;xx.jpg\u0026rdquo;, 0);（载入图像到Mat，第一个参数xx.jpg是图片名称，第二个参数0是灰度图）；namedWindow(\u0026ldquo;窗口名称\u0026rdquo;); ；显示函数imshow(\u0026ldquo;窗口名称\u0026rdquo;,xx); ；载入图片函数Mat image= imread(\u0026ldquo;xx.jpg\u0026rdquo;); ；imageROI= image(Rect());；addWeighted();；imwrite(\u0026quot;.jpg\u0026quot;,image); ；等等函数。本次试验让我充分理解了上述的函数以及试验流程。学会了自己使用上述函数进行图片最基本的载入、显示与输入。\n","date":"2020-03-09T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%AE%9E%E9%AA%8C%E4%B8%80-%E5%9B%BE%E5%83%8F%E7%9A%84%E8%BD%BD%E5%85%A5%E6%98%BE%E7%A4%BA%E4%B8%8E%E8%BE%93%E5%87%BA/","title":"计算机视觉 - 实验一 图像的载入、显示与输出"},{"content":"题目 1084: 用筛法求之N内的素数 时间限制: 1Sec 内存限制: 128MB\n题目描述 用筛法求之N内的素数。\n输入 N\n输出 0～N的素数\n样例输入 1 100 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; int main() { int n,i,j,k; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(i=2;i\u0026lt;=n;i++) { k=1; for(j=2;j\u0026lt;i;j++) { if(i%j == 0) k=0; } if(k==1) printf(\u0026#34;%d\\n\u0026#34;,i); } int vio; scanf(\u0026#34;%d\u0026#34;,\u0026amp;vio); return 0; } 通过C语言网编译运行 ","date":"2020-02-14T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1084-%E7%94%A8%E7%AD%9B%E6%B3%95%E6%B1%82%E4%B9%8Bn%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1084 用筛法求之N内的素数 (C语言)"},{"content":"题目 1432: [2013年第四届真题]剪格子 时间限制: 1Sec 内存限制: 128MB\n题目描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 历届试题 剪格子 时间限制：1.0s 内存限制：256.0MB 问题描述 如下图所示，3 x 3 的格子中填写了一些整数。 +--*--+--+ |10* 1|52| +--****--+ |20|30* 1| *******--+ | 1| 2| 3| +--+--+--+ 我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。 本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。 如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。 如果无法分割，则输出 0。 输入 程序先读入两个整数 m n 用空格分割 (m,n\u0026lt; 10)。 表示表格的宽度和高度。 接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。\n输出 输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。\n样例输入 1 2 3 4 3 3 10 1 52 20 30 1 1 2 3 样例输出 1 3 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include \u0026lt;stdio.h\u0026gt; int a[10][10];//存值 int b[10][10];//标记数组 int count=100; int m,n,sum=0; int dx[4]={0,1,0,-1}; int dy[4]={1,0,-1,0}; void f(int s,int i,int j,int bs) { //s-\u0026gt; 当前和 i,j 当前点的坐标 ，bs 当前步数（格子数） if(s==sum/2\u0026amp;\u0026amp;count\u0026gt;bs)count=bs;//判断是否更新答案 else{ for(int k=0;k\u0026lt;4;k++){ int x=dx[k]+i; int y=dy[k]+j;//边界判断和剪枝 if(b[x][y]==1\u0026amp;\u0026amp;i\u0026gt;=0\u0026amp;\u0026amp;i\u0026lt;n\u0026amp;\u0026amp;j\u0026gt;=0\u0026amp;\u0026amp;j\u0026lt;m\u0026amp;\u0026amp;(s+a[x][y])\u0026lt;=sum/2){ b[x][y]=0; //此时a[0][0] 只作连接用 所以格子和值都不增加 if(x==0\u0026amp;\u0026amp;y==0) f(s,x,y,bs); else f(s+a[x][y],x,y,bs+1); b[x][y]=1;//消除标记 }\t} } } int main() {int i,j,tem; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;m,\u0026amp;n);//输入宽、高 for(i=0;i\u0026lt;n;i++)//注意坑点 先输入纵坐标的m 再输入的横坐标 for(j=0;j\u0026lt;m;j++) {scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]);//值 sum+=a[i][j]; b[i][j]=1;//初始化标记数组 } if(sum%2==1)printf(\u0026#34;0\u0026#34;);//预判是否可以分两部分 else{ f(a[0][0],0,0,1); if(count!=100) printf(\u0026#34;%d\\n\u0026#34;,count); else printf(\u0026#34;0\\n\u0026#34;); } return 0; } 通过C语言网编译运行 ","date":"2020-02-11T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1432-2013%E5%B9%B4%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%9C%9F%E9%A2%98%E5%89%AA%E6%A0%BC%E5%AD%90-c%E8%AF%AD%E8%A8%80/","title":"题目 1432 [2013年第四届真题]剪格子 (C语言)"},{"content":"题目 1429: [2014年第五届真题]兰顿蚂蚁 时间限制: 1Sec 内存限制: 128MB\n题目描述 兰顿蚂蚁，是于1986年，由克里斯·兰顿提出来的，属于细胞自动机的一种。\n平面上的正方形格子被填上黑色或白色。在其中一格正方形内有一只“蚂蚁”。 蚂蚁的头部朝向为：上下左右其中一方。\n蚂蚁的移动规则十分简单： 若蚂蚁在黑格，右转90度，将该格改为白格，并向前移一格； 若蚂蚁在白格，左转90度，将该格改为黑格，并向前移一格。\n规则虽然简单，蚂蚁的行为却十分复杂。刚刚开始时留下的路线都会有接近对称，像是会重复，但不论起始状态如何，蚂蚁经过漫长的混乱活动后，会开辟出一条规则的“高速公路”。\n蚂蚁的路线是很难事先预测的。\n你的任务是根据初始状态，用计算机模拟兰顿蚂蚁在第n步行走后所处的位置。\n输入 输入数据的第一行是 m n 两个整数（3 \u0026lt; m, n \u0026lt; 100），表示正方形格子的行数和列数。 接下来是 m 行数据。 每行数据为 n 个被空格分开的数字。0 表示白格，1 表示黑格。\n接下来是一行数据：x y s k, 其中x y为整数，表示蚂蚁所在行号和列号（行号从上到下增长，列号从左到右增长，都是从0开始编号）。s 是一个大写字母，表示蚂蚁头的朝向，我们约定：上下左右分别用：UDLR表示。k 表示蚂蚁走的步数。\n输出 输出数据为一个空格分开的整数 p q, 分别表示蚂蚁在k步后，所处格子的行号和列号。\n样例输入 1 2 3 4 5 6 7 5 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 L 5 样例输出 1 1 3 C代码 解法A 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include\u0026lt;stdio.h\u0026gt; int main() { int m,n,a[105][105],i,j,x,y,k; char s; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;m,\u0026amp;n); for(i=0;i\u0026lt;m;i++) for(j=0;j\u0026lt;n;j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i][j]); scanf(\u0026#34;%d%d %c%d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;s,\u0026amp;k); for(;k\u0026gt;0;k--) { if(s == \u0026#39;U\u0026#39;) { if(a[x][y] == 1) { s = \u0026#39;R\u0026#39;; a[x][y] = 0; y++; } else { s = \u0026#39;L\u0026#39;; a[x][y] = 1; y--; } } else if(s == \u0026#39;D\u0026#39;) { if(a[x][y] == 1) { s = \u0026#39;L\u0026#39;; a[x][y] = 0; y--; } else { s = \u0026#39;R\u0026#39;; a[x][y] = 1; y++; } } else if(s == \u0026#39;L\u0026#39;) { if(a[x][y] == 1) { s = \u0026#39;U\u0026#39;; a[x][y] = 0; x--; } else { s = \u0026#39;D\u0026#39;; a[x][y] = 1; x++; } } else { if(a[x][y] == 1) { s = \u0026#39;D\u0026#39;; a[x][y] = 0; x++; } else { s = \u0026#39;U\u0026#39;; a[x][y] = 1; x--; } } } printf(\u0026#34;%d %d\u0026#34;,x,y); return 0; } 解法B 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stdio.h\u0026gt; char d0[4]= {\u0026#39;L\u0026#39;,\u0026#39;U\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;D\u0026#39;}; char d1[4]= {\u0026#39;L\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;R\u0026#39;,\u0026#39;U\u0026#39;}; int main() { int x,y,k,m,n; char s; int i,j,maze[100][100]; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); for(i=0; i\u0026lt;m; i++) for(j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;maze[i][j]); scanf(\u0026#34;%d %d %c %d\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;s,\u0026amp;k); while(k--) { if(maze[x][y]) { maze[x][y]=0; for(i=0; i\u0026lt;4; i++) if(s==d0[i]) break; s=d0[(i+1)%4]; switch(s) { case\u0026#39;L\u0026#39;: y--; break; case\u0026#39;R\u0026#39;: y++; break; case\u0026#39;U\u0026#39;: x--; break; case\u0026#39;D\u0026#39;: x++; break; } } else { maze[x][y]=1; for(i=0; i\u0026lt;4; i++) if(s==d1[i]) break; s=d1[(i+1)%4]; switch(s) { case\u0026#39;L\u0026#39;: y--; break; case\u0026#39;R\u0026#39;: y++; break; case\u0026#39;U\u0026#39;: x--; break; case\u0026#39;D\u0026#39;: x++; break; } } } printf(\u0026#34;%d %d\\n\u0026#34;,x,y); return 0; } 通过C语言网编译运行 ","date":"2020-02-10T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1429-2014%E5%B9%B4%E7%AC%AC%E4%BA%94%E5%B1%8A%E7%9C%9F%E9%A2%98%E5%85%B0%E9%A1%BF%E8%9A%82%E8%9A%81-c%E8%AF%AD%E8%A8%80/","title":"题目 1429 [2014年第五届真题]兰顿蚂蚁 (C语言)"},{"content":"题目 1427: [2013年第四届真题]买不到的数目 时间限制: 1Sec 内存限制: 128MB\n题目描述 小明开了一家糖果店。他别出心裁：把水果糖包成4颗一包和7颗一包的两种。糖果不能拆包卖。 小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。 你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。大于17的任何数字都可以用4和7组合出来。 本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。\n输入 两个正整数，表示每种包装中糖的颗数(都不多于1000)\n输出 一个正整数，表示最大不能买到的糖数\n样例输入 1 4 7 样例输出 1 17 C代码 1 2 3 4 5 6 7 # include\u0026lt;stdio.h\u0026gt; int main(){ int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;,a*b-a-b); return 0; } 通过C语言网编译运行 ","date":"2020-02-09T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1427-2013%E5%B9%B4%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%9C%9F%E9%A2%98%E4%B9%B0%E4%B8%8D%E5%88%B0%E7%9A%84%E6%95%B0%E7%9B%AE-c%E8%AF%AD%E8%A8%80/","title":"题目 1427 [2013年第四届真题]买不到的数目 (C语言)"},{"content":"题目 1255: [算法提高]能量项链 时间限制: 1Sec 内存限制: 128MB\n题目描述 在Mars星球上，每个Mars人都随身佩带着一串能量项链。在项链上有 N颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标 记。因为只有这样，通过吸盘（吸盘是Mars人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗 能量珠的头标记为m，尾标记为r，后一颗能量珠的头标记为r，尾标记为n，则聚合后释放的能量为mrn（Mars单位），新产生的珠子的头标记为m， 尾标记为n。 需要时，Mars人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设N=4，4颗珠子的头标记与尾标记依次为(2，3) (3，5) (5，10) (10，2)。我们用记号◎表示两颗珠子的聚合操作，(j◎k)表示第j，k两颗珠子聚合后所释放的能量。则第4、1两颗珠子聚合后释放的能量为： (4◎1)=1023=60。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为 ((4◎1)◎2)◎3）=1023+1035+10510=710。\n输入 第一行是一个正整数N（4≤N≤100），表示项链上珠子的个数。第二行 是N个用空格隔开的正整数，所有的数均不超过1000。第i个数为第i颗珠子的头标记（1≤i≤N），当i〈N时，第i颗珠子的尾标记应该等于第i+1颗 珠子的头标记。第N颗珠子的尾标记应该等于第1颗珠子的头标记。 至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。\n输出 只有一行，是一个正整数E（E≤2.1*10^9），为一个最优聚合顺序所释放的总能量\n样例输入 1 2 4 2 3 5 10 样例输出 1 710 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #define Max(a,b) a\u0026gt;b?a:b int main() { long long int dp[202][202]; long long int s[202]; memset(dp,0,sizeof(dp)); long long int sum=0; int n,i,j,k,len; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;s[i]),s[i+n]=s[i]; for(len=2;len\u0026lt;=n;len++) for(i=1;i+len-1\u0026lt;2*n;i++) { j=i+len-1; for(k=i;k\u0026lt;j;k++) dp[i][j]=Max(dp[i][j],dp[i][k]+dp[k+1][j]+s[i]*s[k+1]*s[j+1]); } for(i=1;i\u0026lt;=n;i++) if(sum\u0026lt;dp[i][i+n-1])sum=dp[i][i+n-1]; printf(\u0026#34;%lld\\n\u0026#34;,sum); return 0; } 通过C语言网编译运行 ","date":"2020-02-06T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1115-%E7%AE%97%E6%B3%95%E6%8F%90%E9%AB%98%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE-c%E8%AF%AD%E8%A8%80/","title":"题目 1115 [算法提高]能量项链 (C语言)"},{"content":"题目 1117: K-进制数 时间限制: 1Sec 内存限制: 128MB\n题目描述 考虑包含N位数字的K-进制数. 定义一个数有效, 如果其K-进制表示不包含两连续的0.\n例: 1010230 是有效的7位数 1000198 无效 0001235 不是7位数, 而是4位数.\n给定两个数N和K, 要求计算包含N位数字的有效K-进制数的总数.\n假设2 \u0026lt;= K \u0026lt;= 10; 2 \u0026lt;= N; 4 \u0026lt;= N+K \u0026lt;= 18.\n输入 两个十进制整数N和K\n输出 十进制表示的结果\n样例输入 1 2 2 10 样例输出 1 90 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; int a[20],n,k; int cnt; void dfs(int s) { if(s==n) { cnt++; return; } for(int i=0; i\u0026lt;k; i++) { if((s==0\u0026amp;\u0026amp;i==0)||(s\u0026gt;0\u0026amp;\u0026amp;i==0\u0026amp;\u0026amp;a[s-1]==0)) continue; a[s]=i; dfs(s+1); } } int main() { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); cnt=0; dfs(0); printf(\u0026#34;%d\\n\u0026#34;,cnt); return 0; } 通过C语言网编译运行 ","date":"2020-02-05T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1117-k-%E8%BF%9B%E5%88%B6%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1117 K-进制数 (C语言)"},{"content":"题目 1110: 2^k进制数 时间限制: 1Sec 内存限制: 128MB\n题目描述 设r是个2^k 进制数，并满足以下条件： （1）r至少是个2位的2^k 进制数。 （2）作为2^k 进制数，除最后一位外，r的每一位严格小于它右边相邻的那一位。 （3）将r转换为2进制数q后，则q的总位数不超过w。 在这里，正整数k（1≤k≤9）和w（k〈w≤30000）是事先给定的。\n问：满足上述条件的不同的r共有多少个？ 我们再从另一角度作些解释：设S是长度为w 的01字符串（即字符串S由w个“0”或“1”组成），S对应于上述条件（3）中的q。将S从右起划分为若干个长度为k 的段，每段对应一位2^k进制的数，如果S至少可分成2段，则S所对应的二进制数又可以转换为上述的2^k 进制数r。 例：设k=3，w=7。则r是个八进制数（2^3=8）。由于w=7，长度为7的01字符串按3位一段分，可分为3段（即1，3，3，左边第一段只有一个二进制位），则满足条件的八进制数有： 2位数：高位为1：6个（即12，13，14，15，16，17），高位为2：5个，…，高位为6：1个（即67）。共6+5+…+1=21个。 3位数：高位只能是1，第2位为2：5个（即123，124，125，126，127），第2位为3：4个，…，第2位为6：1个（即167）。共5+4+…+1=15个。 所以，满足要求的r共有36个。\n输入 只有1行，为两个正整数，用一个空格隔开： k w\n输出 1行，是一个正整数，为所求的计算结果，即满足条件的不同的r的个数（用十进制数表示），要求最高位不得为0，各数字之间不得插入数字以外的其他字符（例如空格、换行符、逗号等）。 （提示：作为结果的正整数可能很大，但不会超过200位）\n样例输入 3 7\n样例输出 36\nC代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; long C(int n,int m) { long sum = 1; int i; for(i=1;i\u0026lt;=m;i++) { sum *= (n-i); sum /= i; } return sum; } int main() { long sum=0; int k,w,max,wei,high,i; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;k,\u0026amp;w); max = pow(2,k); wei = w/k+1; high = pow(2,w%k)-1; if(max-wei \u0026lt; high) high = max-wei; for(i=2;i\u0026lt;wei;i++) sum += C(max,i); if(high != 0) sum += (C(max,wei)-C(max-high,wei)); printf(\u0026#34;%d\u0026#34;,sum); return 0; } 通过C语言网编译运行 ","date":"2020-02-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1110-2k%E8%BF%9B%E5%88%B6%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1110 2^k进制数 (C语言)"},{"content":"题目 1115: DNA 时间限制: 1Sec 内存限制: 128MB\n题目描述 小强从小就喜欢生命科学，他总是好奇花草鸟兽从哪里来的。终于， 小强上中学了，接触到了神圣的名词\u0026ndash;DNA.它有一个双螺旋的结构。这让一根筋的小强抓破头皮，“要是能画出来就好了” 小强喊道。现在就请你帮助他吧\n输入 输入包含多组测试数据。第一个整数N（N\u0026lt;=15）,N表示组数，每组数据包含两个整数a,b。a表示一个单位的DNA串的行数，a为奇数且 3\u0026lt;=a\u0026lt;=39。b表示重复度(1\u0026lt;=b\u0026lt;=20)。\n输出 输出DNA的形状，每组输出间有一空行。\n样例输入 1 2 3 2 3 1 5 4 样例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;stdio.h\u0026gt; int main() { int N,a[20],b[20],i,j,k,p; scanf(\u0026#34;%d\u0026#34;,\u0026amp;N); i = 1; while(i\u0026lt;=N) { scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a[i],\u0026amp;b[i]); i++; } for(i=1;i\u0026lt;=N;i++) { for(j=1;j\u0026lt;=b[i];j++) { for(k=1;k\u0026lt;a[i];k++) { for(p=1;p\u0026lt;=a[i];p++) { if(p == k || p+k == a[i]+1) printf(\u0026#34;X\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } } for(j=1;j\u0026lt;=a[i];j++) { if(j == k || j+k == a[i]+1) printf(\u0026#34;X\u0026#34;); else printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); if(i != N) printf(\u0026#34;\\n\u0026#34;); } return 0; } 通过C语言网编译运行 ","date":"2020-02-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1115-dna-c%E8%AF%AD%E8%A8%80/","title":"题目 1115 DNA (C语言)"},{"content":"西京学院导游系统 学习数据结构+C语言实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;graphics.h\u0026gt; #define MaxViewNum 50 /*景点个数最大50*/ #define MaxRoad 10000 /*定义路径为无穷大*/ typedef int dist[MaxViewNum]; typedef int path[MaxViewNum]; //定义三个结构体表示图中内容 typedef struct { char name[30]; /*景点名称*/ char introduce[200]; /*景点介绍*/\tint x,y; /*景点坐标*/ }JDXX; /*景点信息*/ typedef struct { JDXX jd[MaxViewNum]; /*存放顶点的一维数组，数组第零单元没有用上*/ int length[MaxViewNum][MaxViewNum]; /*存放路径长度*/ }MGraph; MGraph M; /*全局变量,定义M为MGraph类型*/ int N=0; /*全局变量，目前景点个数*/ path p; dist d; void init() { int i,j; strcpy(M.jd[1].name,\u0026#34;北门\u0026#34;); strcpy(M.jd[1].introduce,\u0026#34;坐落于西京路，毗邻生活区，购物方便，交通便利\u0026#34;); strcpy(M.jd[2].name,\u0026#34;艺舫\u0026#34;); strcpy(M.jd[2].introduce,\u0026#34;坐落于桂湖上，通往艺术的天堂\u0026#34;); strcpy(M.jd[3].name,\u0026#34;花街\u0026#34;); strcpy(M.jd[3].introduce,\u0026#34;以s形花坛作为背景，一年四季花常开\u0026#34;); strcpy(M.jd[4].name,\u0026#34;科苑\u0026#34;); strcpy(M.jd[4].introduce,\u0026#34;为学生英语听力，计算机等课程提供场所\u0026#34;); strcpy(M.jd[5].name,\u0026#34;广场\u0026#34;); strcpy(M.jd[5].introduce,\u0026#34;包括博能国旗时代广场，为学生提供娱乐活动场地\u0026#34;); strcpy(M.jd[6].name,\u0026#34;教学楼\u0026#34;); strcpy(M.jd[6].introduce,\u0026#34;学生日常上课的地方，通往知识的殿堂\u0026#34;); strcpy(M.jd[7].name,\u0026#34;工程舫\u0026#34;); strcpy(M.jd[7].introduce,\u0026#34;为学生提供实验，实训，学习的场地\u0026#34;); strcpy(M.jd[8].name,\u0026#34;图书馆\u0026#34;); strcpy(M.jd[8].introduce,\u0026#34;具有浓厚的文化积淀，供同学安静读书学习的环境\u0026#34;); strcpy(M.jd[9].name,\u0026#34;公寓楼\u0026#34;); strcpy(M.jd[9].introduce,\u0026#34;11——18号公寓楼\u0026#34;); strcpy(M.jd[10].name,\u0026#34;大学生发展与服务中心\u0026#34;); strcpy(M.jd[10].introduce,\u0026#34;各书院办公地点，为学生提供一站式服务\u0026#34;); strcpy(M.jd[11].name,\u0026#34;璞玉餐厅\u0026#34;); strcpy(M.jd[11].introduce,\u0026#34;四层餐厅，为学生提供一日三餐\u0026#34;); strcpy(M.jd[12].name,\u0026#34;京华大礼堂\u0026#34;); strcpy(M.jd[12].introduce,\u0026#34;学校最大的礼堂\u0026#34;); strcpy(M.jd[13].name,\u0026#34;体育馆\u0026#34;); strcpy(M.jd[13].introduce,\u0026#34;为学生室内运动提供场所\u0026#34;); strcpy(M.jd[14].name,\u0026#34;科研楼\u0026#34;); strcpy(M.jd[14].introduce,\u0026#34;进行科学研究的场所\u0026#34;); strcpy(M.jd[15].name,\u0026#34;南操场\u0026#34;); strcpy(M.jd[15].introduce,\u0026#34;同学们傍晚刷运动软件\u0026#34;); strcpy(M.jd[16].name,\u0026#34;南湖\u0026#34;); strcpy(M.jd[16].introduce,\u0026#34;又名含笑湖，夜晚灯光非常美丽\u0026#34;); strcpy(M.jd[17].name,\u0026#34;南门\u0026#34;); strcpy(M.jd[17].introduce,\u0026#34;坐落于神禾二路，交通方便\u0026#34;); for(i=1;i\u0026lt;=MaxViewNum;i++) { for(j=1;j\u0026lt;=MaxViewNum;j++) { M.length[i][j]=MaxRoad; } } for(i=1;i\u0026lt;=MaxViewNum;i++) M.length[i][i]=0; M.length[1][2]=M.length[2][1]=30; M.length[1][3]=M.length[3][1]=30; M.length[2][3]=M.length[3][2]=30; M.length[2][4]=M.length[4][2]=70; M.length[3][5]=M.length[5][3]=30; M.length[3][6]=M.length[6][3]=50; M.length[4][5]=M.length[5][4]=50; M.length[4][7]=M.length[7][4]=100; M.length[5][6]=M.length[6][5]=30; M.length[6][7]=M.length[7][6]=100; M.length[6][10]=M.length[10][6]=20; M.length[7][8]=M.length[8][7]=30; M.length[7][9]=M.length[9][7]=30; M.length[7][10]=M.length[10][7]=30; M.length[8][9]=M.length[9][8]=30; M.length[9][10]=M.length[10][9]=50; M.length[9][11]=M.length[11][9]=30; M.length[10][11]=M.length[11][10]=30; M.length[11][12]=M.length[12][11]=100; M.length[11][13]=M.length[13][11]=50; M.length[12][13]=M.length[13][12]=50; M.length[12][15]=M.length[15][12]=30; M.length[12][17]=M.length[17][12]=150; M.length[13][14]=M.length[14][13]=70; M.length[13][15]=M.length[15][13]=30; M.length[13][16]=M.length[16][13]=50; M.length[14][16]=M.length[16][14]=50; M.length[15][16]=M.length[16][15]=20; M.length[16][17]=M.length[17][16]=30; N=17; M.jd[1].x=50; M.jd[1].y=25; M.jd[2].x=150; M.jd[2].y=125; M.jd[3].x=250; M.jd[3].y=25; M.jd[4].x=150; M.jd[4].y=475; M.jd[5].x=350; M.jd[5].y=175; M.jd[6].x=475; M.jd[6].y=50; M.jd[7].x=475; M.jd[7].y=475; M.jd[8].x=575; M.jd[8].y=650; M.jd[9].x=675; M.jd[9].y=525; M.jd[10].x=575; M.jd[10].y=150; M.jd[11].x=750; M.jd[11].y=225; M.jd[12].x=575; M.jd[12].y=525; M.jd[13].x=575; M.jd[13].y=225; M.jd[14].x=1075; M.jd[14].y=25; M.jd[15].x=1000; M.jd[15].y=375; M.jd[16].x=1100; M.jd[16].y=225; M.jd[17].x=1175; M.jd[17].y=325; } void scsyjd() { int t; printf(\u0026#34;所有景点如下：\\n\u0026#34;); for(t=1;t\u0026lt;=N;t++) { printf(\u0026#34;编号：%d\\n 景点：%s\\n 介绍：%s\\n\u0026#34;,t,M.jd[t].name,M.jd[t].introduce); } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void zengj() { char s1[30],s2[200]; //景点名称；景点介绍 int t,i,q,p,x,y; //t为与该景点共有几个景点相连；i为应第几个景点与之相连； //q为与之相连的景点；p为这个景点和新景点的距离 //x为此景点位置的x值；y为此景点位置的y值 N++; printf(\u0026#34;请输入该景点的名称：\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;s1); printf(\u0026#34;请输入该景点的介绍：\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;s2); printf(\u0026#34;请输入该景点的位置的x值：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); printf(\u0026#34;请输入该景点的位置的y值：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;y); strcpy(M.jd[N].name,s1); strcpy(M.jd[N].introduce,s2); M.jd[N].x=x; M.jd[N].y=y; printf(\u0026#34;请输入共有几个景点与此景点相通：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); for(i=1;i\u0026lt;=t;i++) { printf(\u0026#34;第%d个景点与之相通；\u0026#34;,i); scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); printf(\u0026#34;他们之间的距离为：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;p); M.length[N][q]=M.length[q][N]=p; } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void scjd() { printf(\u0026#34;请输入要删除的景点序号数\u0026#34;); int t,p,Q; scanf(\u0026#34;%d\u0026#34;,\u0026amp;p); Q=p; if(p\u0026lt;=N) { for(t=1;t\u0026lt;=N;t++) for(p=p;p\u0026lt;=N;p++) { M.length[t][p]=M.length[t][p+1]; M.length[p][t]=M.length[p+1][t];\t} for(Q;Q\u0026lt;N;Q++) M.jd[Q]=M.jd[Q+1]; printf(\u0026#34;删除成功O(∩_∩)O\u0026#34;); } else printf(\u0026#34;删除失败←_←\u0026#34;); N--; printf(\u0026#34;\\n按任意键返回！\u0026#34;);\tgetch(); } void gxjd() { int t; char s1[30],s2[200]; printf(\u0026#34;请输入要更新的景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); if(t\u0026gt;N) printf(\u0026#34;此景点不存在，更新失败\u0026#34;); else { printf(\u0026#34;请输入景点名称：\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;s1); printf(\u0026#34;请输入景点介绍：\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;s2); strcpy(M.jd[t].name,s1); strcpy(M.jd[t].introduce,s2); printf(\u0026#34;更新完成！\u0026#34;); } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void zengjl() { int a,b,c; printf(\u0026#34;请问要在那两个景点之间增加一条路\\n\u0026#34;); printf(\u0026#34;请输入第一个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;请输入第二个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;b); printf(\u0026#34;请输入这条路的长度：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;c); if(a\u0026gt;N||b\u0026gt;N) printf(\u0026#34;景点超出了已有景点范围，路径增加失败！\u0026#34;); else { M.length[a][b]=M.length[b][a]=c; printf(\u0026#34;路径增加成功！\u0026#34;); } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void scl() { int a,b; printf(\u0026#34;请问要删除那两个景点之间的路\\n\u0026#34;); printf(\u0026#34;请输入第一个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;请输入第二个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;b); if(a\u0026gt;N||b\u0026gt;N) printf(\u0026#34;景点超出了已有景点范围，路径删除失败！\u0026#34;); else { M.length[a][b]=M.length[b][a]=MaxRoad; printf(\u0026#34;路径删除成功！\u0026#34;); } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void gxl() { int a,b,c; printf(\u0026#34;请问要更新那两个景点之间的路\\n\u0026#34;); printf(\u0026#34;请输入第一个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;请输入第二个景点编号：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;b); printf(\u0026#34;请输入更新后的长度：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;c); if(a\u0026gt;N||b\u0026gt;N) printf(\u0026#34;这条路不存在，路径更新失败！\u0026#34;); else { M.length[a][b]=M.length[b][a]=c; printf(\u0026#34;路径更新成功！\u0026#34;); } printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void cxjd() { int a; printf(\u0026#34;请问您要查询的景点编号是：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if(a\u0026gt;N) printf(\u0026#34;查询的景点不存在，查询失败！\u0026#34;); else printf(\u0026#34;编号：%d\\n 景点：%s\\n 介绍：%s\\n\u0026#34;,a,M.jd[a].name,M.jd[a].introduce); printf(\u0026#34;\\n按任意键返回！\u0026#34;); getch(); } void dijkstra_syjd() { int v0; printf(\u0026#34;请输入查询的景点：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;v0); boolean final[MaxViewNum]; int i,k,j,v,min,x; for(v=1;v\u0026lt;=N;v++) { final[v]=FALSE; d[v]=M.length[v0][v]; if(d[v]\u0026lt;MaxRoad\u0026amp;\u0026amp;d[v]!=0) p[v]=v0; else p[v]=-1; } final[v0]=TRUE; d[v0]=0; for(i=2;i\u0026lt;=N;i++) { min=MaxRoad; for(k=1;k\u0026lt;=N;++k) if(!final[k]\u0026amp;\u0026amp;d[k]\u0026lt;min) { v=k; min=d[k]; } if(min==MaxRoad) return; final[v]=TRUE; for(k=1;k\u0026lt;=N;++k) if(!final[k]\u0026amp;\u0026amp;(min+M.length[v][k]\u0026lt;d[k])) { d[k]=min+M.length[v][k]; p[k]=v; } } } void printsyjd() { int st[MaxViewNum],i,pre,top=-1; for(i=1;i\u0026lt;=N;i++) { printf(\u0026#34;\\n到达景点%2d的总距离是: %5d , 所经过路径:\u0026#34;,i,d[i]); st[++top]=i; pre=p[i]; while(pre!=-1) { st[++top]=pre; pre=p[pre]; } while(top\u0026gt;0) { printf(\u0026#34;%d\u0026#34;,st[top--]); if(top\u0026gt;0) printf(\u0026#34;---\u0026#34;); } } getch(); } void dijkstra_ygjd() { int v0; printf(\u0026#34;请输入出发景点：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;v0); boolean final[MaxViewNum]; int i,k,j,v,min,x; for(v=1;v\u0026lt;=N;v++) { final[v]=FALSE; d[v]=M.length[v0][v]; if(d[v]\u0026lt;MaxRoad\u0026amp;\u0026amp;d[v]!=0) p[v]=v0; else p[v]=-1; } final[v0]=TRUE; d[v0]=0; for(i=2;i\u0026lt;=N;i++) { min=MaxRoad; for(k=1;k\u0026lt;=N;++k) if(!final[k]\u0026amp;\u0026amp;d[k]\u0026lt;min) { v=k; min=d[k]; } if(min==MaxRoad) return; final[v]=TRUE; for(k=1;k\u0026lt;=N;++k) if(!final[k]\u0026amp;\u0026amp;(min+M.length[v][k]\u0026lt;d[k])) { d[k]=min+M.length[v][k]; p[k]=v; } } } void printygjd() { int y; printf(\u0026#34;\\n请输入到达景点：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;y); int st[MaxViewNum],i,pre,top=-1; for(i=1;i\u0026lt;=N;i++) { if(i==y) printf(\u0026#34;\\n总距离是: %5d , 所经过路径:\u0026#34;,d[i]); st[++top]=i; pre=p[i]; while(pre!=-1) { st[++top]=pre; pre=p[pre]; } while(top\u0026gt;0) { if(i==y) { printf(\u0026#34;%d\u0026#34;,st[top--]); if(top\u0026gt;0) printf(\u0026#34;---\u0026#34;); } else top--; } } getch(); } void scdt() { int i,j; char s[100]; strcpy(s,\u0026#34;西京学院地图\u0026#34;); initgraph(1200,800); for(i=1;i\u0026lt;=N;i++) { setfillcolor(RGB(225,236,0)); fillcircle(M.jd[i].x,M.jd[i].y,20); outtextxy(M.jd[i].x,M.jd[i].y,M.jd[i].name); } for(i=1;i\u0026lt;=N;i++) for(j=1;j\u0026lt;=N;j++) { if(M.length[i][j]\u0026gt;0\u0026amp;\u0026amp;M.length[i][j]\u0026lt;1000) line(M.jd[i].x,M.jd[i].y,M.jd[j].x,M.jd[j].y); } outtextxy(900,650,s); getch(); closegraph(); } main() { init(); int x; while(1) { printf(\u0026#34;**********************************************************************\\n\u0026#34;); printf(\u0026#34;* =.= =.= *\\n\u0026#34;); printf(\u0026#34;* ` ` *\\n\u0026#34;); printf(\u0026#34;* ` 主人，欢迎来到西京哟~ 喵~ ` *\\n\u0026#34;); printf(\u0026#34;* ` ^-^ ^-^ ` *\\n\u0026#34;); printf(\u0026#34;* ` ^-^ ` *\\n\u0026#34;); printf(\u0026#34;**********************************************************************\\n\u0026#34;); printf(\u0026#34;\\n 西京导游系统（输入0退出程序）：\u0026#34;); printf(\u0026#34;\\n 1、输出所有景点及其介绍\u0026#34;); printf(\u0026#34;\\n 2、查询某一个景点及其介绍\u0026#34;); printf(\u0026#34;\\n 3、增加一个景点\u0026#34;); printf(\u0026#34;\\n 4、删除一个景点\u0026#34;); printf(\u0026#34;\\n 5、更新一个景点\u0026#34;); printf(\u0026#34;\\n 6、增加一条路\u0026#34;); printf(\u0026#34;\\n 7、删除一条路\u0026#34;); printf(\u0026#34;\\n 8、更新一条路\u0026#34;); printf(\u0026#34;\\n 9、查询某一景点到其他所有景点的最短路径\u0026#34;); printf(\u0026#34;\\n 10、查询某两个景点之间的最短路径 \u0026#34;); printf(\u0026#34;\\n 11、输出地图 已有景点：%d个\\n\u0026#34;,N); printf(\u0026#34;请输入选项：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); if(x==0) break; else switch(x) { case 1:scsyjd();break; case 2:cxjd();break; case 3:zengj();break; case 4:scjd();break; case 5:gxjd();break; case 6:zengjl();break; case 7:scl();break; case 8:gxl();break; case 9:dijkstra_syjd();printsyjd();break; case 10:dijkstra_ygjd();printygjd();break; case 11:scdt();break; } system(\u0026#34;cls\u0026#34;); } } ","date":"2019-11-27T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E6%A0%A1%E5%9B%AD%E5%AF%BC%E6%B8%B8%E7%B3%BB%E7%BB%9F%E7%BA%AFc%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-dijkstra%E7%AE%97%E6%B3%95/","title":"校园导游系统（纯C语言实现）最短路径 - Dijkstra算法"},{"content":"机器学习 - 贝叶斯分类实验 1. 中文文本分类介绍 文本挖掘是指从大量的文本数据中抽取事先未知的、可理解的、最终可用的知识的过程，同时运用这些知识更好的组织信息以便将来参考。\n主要有以下几个方面的应用：\n搜索和信息检索（IR）：存储和文本文档的检索，包括搜索引擎个关键字搜索。\n文本聚类：使用聚类方法，对词汇、片段、段落或文件进行分组和归类。\n文本分类：对片段、段落或文件进行分组和归类，在使用数据挖掘分类方法的基础上，经过训练的标记示例模型。\nWeb挖掘：在互联网上进行数据和文本的挖掘，并特别关注网络的规模和相互的联系。\n信息抽取（IE）：从非结构化文本中识别与提取有关的事实和关系：从非结构化或半结构化文本中抽取结构化数据的过程。\n自然语言处理（NLP）：将语言作为一种有意义、有规则的符号系统，从底层解析和理解语言的任务（例如词性的标注）；目前的技术方法主要从语法、语义的角度发现语言最本质的结构和所表达的意义。\n概念的提取：把单词和短语按语义分成意义相似的组。\n2. 文本分类的一般步骤： （1）预处理：去除文本的噪声信息，例如HTML标签、文本的格式转换、检测句子边界等。\n（2）中文分词：什么是分词？分词有什么用？怎样分词？\n例如一句话：“2019年底部队友谊篮球赛结束”，分词结果为2019/年底/部队/友谊/篮球赛/结束。如果分出的词是底部、队友呢？\n使用中文分词器为文本分词，并去除停用词。\n中文分词和英文分词对比，中文分词难点：没有形式上的分界符。（英文用空格区分单词）\n（3）构建词向量空间：统计文本词频，生成文本的词向量空间。\n词映射到向量空间。余弦相似度。“快乐”、“高兴”、“悲伤”三个向量的余弦？\n余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫\u0026quot;余弦相似性\u0026quot;。\n（4）权重策略—TF-IDF方法：使用TF-IDF发现特征词，并抽取为反映文档主题的特征。\nTF：词频。\nIDF：逆向文档频率。\n衡量词语重要性的程度。\n（5）分类器：使用朴素贝叶斯算法训练分类器。scikit-learn网站介绍。Naive Bayes\n（6）评价分类结果：分类器的测试结果分析。\n3. 具体操作 （1）下载并安装“结巴”jieba类库。https://pypi.org/project/jieba/\n学习在python中安装外部类库的方法。\n（2）文本语料库的获取和预处理。\n常用的语料库：复旦大学谭松波中文文本分类语料库，搜狐新闻文本分类语料库。\n停用词的清理。什么是停用词？停用词库的获取。hlt_stop_words.txt\njieba中文分词。安装、使用，自行把一段话用三种模式进行分词。\n（3）将分词向量化，TF_IDF方法。\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.feature_extraction.text import TfidfVectorizer\n（4）使用朴素贝叶斯分类模块。scikit-learn网站查看、学习Naive Bayes分类算法。\n（5）分类结果评估。\nfrom sklearn.metrics import classification_report\nfrom sklearn.metrics import classification accuracy_score\n4. 实验步骤 5. 实验完整代码python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 import jieba #需要先安装结巴类库，再引入，否则报错 seg_list=jieba.cut(\u0026#34;西京网讯：10月31日晚，“庆祝中华人民共和国成立70周年暨西京学院建校25周年教职工竹竿舞比赛”举行。\u0026#34;,cut_all=True) print(\u0026#34;Full Mode全切分模式:\u0026#34;,\u0026#34;/\u0026#34;.join(seg_list)) seg_list=jieba.cut(\u0026#34;教师五分会的《欢乐西京团》与教师二分会的《跳起来》伴随着活泼的音乐和轻盈的舞蹈，把“欢乐”表现的淋淋尽致。\u0026#34;) print(\u0026#34;搜索引擎分词模式:\u0026#34;,\u0026#34;/\u0026#34;.join(seg_list)) seg_list=jieba.cut(\u0026#34;2019年底部队友谊篮球赛结束\u0026#34;,cut_all=False) print(\u0026#34;默认切分模式:\u0026#34;,\u0026#34;/\u0026#34;.join(seg_list)) seg_list=jieba.cut(\u0026#34;西京网讯：10月31日晚，“庆祝中华人民共和国成立70周年暨西京学院建校25周年教职工竹竿舞比赛”举行。\u0026#34;,cut_all=False) print(\u0026#34;Full Mode全切分模式:\u0026#34;,\u0026#34;/\u0026#34;.join(seg_list)) import os #定义读取文件内容的函数 def readfile(path): #注意文本文件的编码格式，使用自己语料库和测试集txt文件的编码格式。 fp=open(path,\u0026#39;r\u0026#39;,encoding=\u0026#39;ANSI\u0026#39;,errors=\u0026#39;ignore\u0026#39;) content=fp.read() fp.close() return content #定义保存到文件的函数 def savefile(savepath,content): fp=open(savepath,\u0026#39;w\u0026#39;,encoding=\u0026#39;ANSI\u0026#39;,errors=\u0026#39;ignore\u0026#39;) fp.write(content) fp.close() #定义一个存放训练集分词后各文档内容的列表 train_corpus=[] #定义一个存放训练集各文档类别标签的列表 train_label=[] #未分词的训练集语料库路径，替换为自己电脑保存的路径。train_corpus文件夹。 corpus_path=\u0026#34;E:/program/train_corpus/\u0026#34; #训练集分词以后存放路径，自己提前建立好名字为seg_train_corpus的空文件夹 save_path=\u0026#34;E:/program/seg_train_corpus/\u0026#34; #获取未分词的语料库下所有子目录列表 cate_list=os.listdir(corpus_path) print(\u0026#34;努力分词中，请稍等.........\u0026#34;) #获取每个子目录下的所有文件 for mydir in cate_list: class_path=corpus_path+mydir+\u0026#39;/\u0026#39; #语料集中的某个子目录路径 seg_dir=save_path+mydir+\u0026#39;/\u0026#39; #分类后的子目录路径 file_list=os.listdir(class_path) #获取具体的文件名称列表 for file_path in file_list: fullname=class_path + file_path content=readfile(fullname).strip() #str.strip()就是把字符串(str)的头和尾的空格，以及位于头尾的\\n \\t之类给删掉 content=content.replace(\u0026#34;\\r\\n\u0026#34;,\u0026#34;\u0026#34;).strip() #删除换行和多余的空格 content_seg=jieba.cut(content) savefile(seg_dir+file_path,\u0026#34; \u0026#34;.join(content_seg)) train_label.append(mydir) print(\u0026#34;训练集语料库文本分词结束！\u0026#34;) oldpath=r\u0026#34;e:/program/seg_train_corpus/\u0026#34; newpath=r\u0026#34;e:/program/seg_val_corpus/\u0026#34; import random #随机排序文件 import shutil #从训练集中随机取出20%的文件，保存为验证集。 catelist=os.listdir(oldpath) for eachlist in catelist: fullpath=oldpath+eachlist newvalpath=newpath+eachlist+\u0026#34;/\u0026#34; isExists=os.path.exists(newvalpath) #判断路径是否存在，若存在，报错。不存在，创建。 if isExists==True: print(newvalpath+\u0026#34;目录已存在，将不再保存新的文件！请确认是否已划分好。\u0026#34;) else: os.makedirs(newvalpath,exist_ok=True) filename=os.listdir(fullpath) filenumber=len(filename) random.shuffle(filename) #将文件随机排序 splitfile=int(filenumber*0.2) for i in range(splitfile): #将随机抽取出的20%文件保存到验证集目录下。 src=fullpath+\u0026#34;/\u0026#34;+filename[i] shutil.move(src,newvalpath) print(\u0026#34;目录\u0026#34;+newvalpath+\u0026#34;创建成功！\u0026#34;) print(\u0026#34;训练集和验证集划分完毕\u0026#34;) newvalpath #对测试集文档进行分词。注意，测试集中直接保存的文档，没有子目录。 test_corpus_path=\u0026#34;E:/program/test_corpus/\u0026#34; save_test_path=\u0026#34;E:/program/seg_test_corpus/\u0026#34; #自行建立该文件夹 test_file_list=os.listdir(test_corpus_path) #获取具体的文件名称列表 print(\u0026#34;努力分词中，请稍等.........\u0026#34;) for file_path in test_file_list: fullname=test_corpus_path + file_path content=readfile(fullname).strip() #str.strip()就是把字符串(str)的头和尾的空格，以及位于头尾的\\n \\t之类给删掉 content=content.replace(\u0026#34;\\r\\n\u0026#34;,\u0026#34;\u0026#34;).strip() #删除换行和多余的空格 content_seg=jieba.cut(content) savefile(save_test_path+file_path,\u0026#34; \u0026#34;.join(content_seg)) print(\u0026#34;测试集语料库文本分词结束！\u0026#34;) from sklearn.datasets.base import Bunch bunch = Bunch(target_name=[],label=[],filenames=[],contents=[]) #先对训练集进行操作 wordbag_path=\u0026#34;E:/program/train_word_bag/train_set.dat\u0026#34;#train_word_bag文件夹已经自己创建 seg_path=\u0026#34;E:/program/seg_train_corpus/\u0026#34; cate_list=os.listdir(seg_path) bunch.target_name.extend(cate_list)#将类别信息保存到Bunch对象 for mydir in cate_list: class_path=seg_path+mydir+\u0026#34;/\u0026#34; file_list=os.listdir(class_path) for file_path in file_list: fullname=class_path+file_path bunch.label.append(mydir)#保存当前文件的分类标签 bunch.filenames.append(fullname)#保存当前文件的文件路径 bunch.contents.append(readfile(fullname).strip())#保存文件词向量 #Bunch对象持久化 import pickle file_obj=open(wordbag_path,\u0026#34;wb\u0026#34;) pickle.dump(bunch,file_obj) file_obj.close() print(\u0026#34;训练集构建文本对象结束\u0026#34;) from sklearn import feature_extraction from sklearn.feature_extraction.text import TfidfTransformer#TF-IDF向量转换类 from sklearn.feature_extraction.text import TfidfVectorizer#TF-IDF向量生成类 def readbunchobj(path): file_obj=open(path,\u0026#34;rb\u0026#34;) bunch=pickle.load(file_obj) file_obj.close() return bunch def writebunchobj(path,bunchobj): file_obj=open(path,\u0026#34;wb\u0026#34;) pickle.dump(bunchobj,file_obj) file_obj.close() def readfile(path): fp = open(path,\u0026#34;r\u0026#34;,encoding=\u0026#39;ANSI\u0026#39;,errors=\u0026#39;ignore\u0026#39;) content = fp.read() fp.close() return content path=\u0026#34;E:/program/train_word_bag/train_set.dat\u0026#34; bunch=readbunchobj(path) #停用词 stopword_path=\u0026#34;E:/program/hlt_stop_words.txt\u0026#34; stpwrdlst=readfile(stopword_path).splitlines() #构建TF-IDF词向量空间对象 tfidfspace=Bunch(target_name=bunch.target_name,label=bunch.label,filenames=bunch.filenames,tdm=[],vocabulary={}) #使用TfidVectorizer初始化向量空间模型 vectorizer=TfidfVectorizer(stop_words=stpwrdlst,sublinear_tf=True,max_df=0.5) #transformer=TfidfTransformer()#该类会统计每个词语的TF-IDF权值 #文本转为词频矩阵，单独保存字典文件 tfidfspace.tdm=vectorizer.fit_transform(bunch.contents) tfidfspace.vocabulary=vectorizer.vocabulary_ #创建词袋的持久化 space_path=\u0026#34;E:/program/train_word_bag/tfidfspace.dat\u0026#34; writebunchobj(space_path,tfidfspace) tfidfspace.tdm.shape bunch = Bunch(target_name=[],label=[],filenames=[],contents=[]) wordbag_path=\u0026#34;E:/program/val_word_bag/val_set.dat\u0026#34;#train_word_bag文件夹已经自己创建 seg_path=\u0026#34;E:/program/seg_val_corpus/\u0026#34; cate_list=os.listdir(seg_path) bunch.target_name.extend(cate_list)#将类别信息保存到Bunch对象 for mydir in cate_list: class_path=seg_path+mydir+\u0026#34;/\u0026#34; file_list=os.listdir(class_path) for file_path in file_list: fullname=class_path+file_path bunch.label.append(mydir)#保存当前文件的分类标签 bunch.filenames.append(fullname)#保存当前文件的文件路径 bunch.contents.append(readfile(fullname).strip())#保存文件词向量 #Bunch对象持久化 import pickle file_obj=open(wordbag_path,\u0026#34;wb\u0026#34;) pickle.dump(bunch,file_obj) file_obj.close() print(\u0026#34;验证集构建文本对象结束\u0026#34;) #对于验证集生成向量空间，在训练词向量模型时需要加载训练集词袋，将验证集产生的词向量映射到训练集词袋的词典中，生成向量空间模型 path=\u0026#34;E:/program/val_word_bag/val_set.dat\u0026#34; bunch=readbunchobj(path) #停用词 stopword_path=\u0026#34;E:/program/hlt_stop_words.txt\u0026#34; stpwrdlst=readfile(stopword_path).splitlines() #构建TF-IDF词向量空间对象 tfidfspace=Bunch(target_name=bunch.target_name,label=bunch.label,filenames=bunch.filenames,tdm=[],vocabulary={}) #导入训练集词袋 train_path=\u0026#34;E:/program/train_word_bag/tfidfspace.dat\u0026#34; trainbunch=readbunchobj(train_path) #使用TfidVectorizer初始化向量空间模型 vectorizer=TfidfVectorizer(stop_words=stpwrdlst,sublinear_tf=True,max_df=0.5,vocabulary=trainbunch.vocabulary) #transformer=TfidfTransformer()#该类会统计每个词语的TF-IDF权值 #文本转为词频矩阵，单独保存字典文件 tfidfspace.tdm=vectorizer.fit_transform(bunch.contents) tfidfspace.vocabulary=trainbunch.vocabulary #创建词袋的持久化 space_path=\u0026#34;E:/program/val_word_bag/tfidfspace.dat\u0026#34; writebunchobj(space_path,tfidfspace) type(tfidfspace.tdm) tfidfspace.tdm.shape bunch = Bunch(target_name=[],label=[],filenames=[],contents=[]) wordbag_path=\u0026#34;E:/program/test_word_bag/test_set.dat\u0026#34;#test_word_bag文件夹已经自己创建 seg_path=\u0026#34;E:/program/seg_test_corpus/\u0026#34; file_list=os.listdir(seg_path) for file_path in file_list: fullname=seg_path+file_path bunch.filenames.append(fullname)#保存当前文件的文件路径 bunch.contents.append(readfile(fullname).strip())#保存文件词向量 #Bunch对象持久化 file_obj=open(wordbag_path,\u0026#34;wb\u0026#34;) pickle.dump(bunch,file_obj) file_obj.close() print(\u0026#34;测试集构建文本对象结束\u0026#34;) path=\u0026#34;E:/program/test_word_bag/test_set.dat\u0026#34; bunch=readbunchobj(path) #停用词 stopword_path=\u0026#34;E:/program/hlt_stop_words.txt\u0026#34; stpwrdlst=readfile(stopword_path).splitlines() #构建TF-IDF词向量空间对象 tfidfspace=Bunch(target_name=bunch.target_name,label=bunch.label,filenames=bunch.filenames,tdm=[],vocabulary={}) #使用TfidVectorizer初始化向量空间模型 vectorizer=TfidfVectorizer(stop_words=stpwrdlst,sublinear_tf=True,max_df=0.5) transfoemer=TfidfTransformer()#该类会统计每个词语的TF-IDF权值 #文本转为词频矩阵，单独保存字典文件 tfidfspace.tdm=vectorizer.fit_transform(bunch.contents) #tfidfspace.vocabulary=vectorizer.vocabulary #创建词袋的持久化 space_path=\u0026#34;E:/program/test_word_bag/tfidfspace.dat\u0026#34; writebunchobj(space_path,tfidfspace) from sklearn.naive_bayes import MultinomialNB# 导入多项式贝叶斯算法包 # 导入训练集向量空间 trainpath = \u0026#34;E:/program/train_word_bag/tfidfspace.dat\u0026#34; train_set = readbunchobj(trainpath) # 导入验证集向量空间 valpath = \u0026#34;E:/program/val_word_bag/tfidfspace.dat\u0026#34; val_set = readbunchobj(valpath) # 应用贝叶斯算法 # alpha:0.001 alpha 越小，迭代次数越多，精度越高 clf = MultinomialNB(alpha=0.001).fit(train_set.tdm, train_set.label) # 预测分类结果 predicted = clf.predict(val_set.tdm) total = len(predicted) rate = 0 for flabel, file_name, expct_cate in zip(val_set.label, val_set.filenames, predicted): if flabel != expct_cate: rate += 1 print(file_name,\u0026#34;: 实际类别：\u0026#34;, flabel,\u0026#34;--\u0026gt;预测分类：\u0026#34;, expct_cate) # 精度 print(\u0026#34;error_rate:\u0026#34;,float(rate) *100 /float(total),\u0026#34;%\u0026#34;) from sklearn import metrics def metrics_result(actual,predict): print(\u0026#34;精度：{0:.3f}\u0026#34;.format(metrics.precision_score(actual,predict,average=\u0026#39;weighted\u0026#39;))) print(\u0026#34;召回：{0:0.3f}\u0026#34;.format(metrics.recall_score(actual,predict,average=\u0026#39;weighted\u0026#39;))) print(\u0026#34;f1-score:{0:.3f}\u0026#34;.format(metrics.f1_score(actual,predict,average=\u0026#39;weighted\u0026#39;))) metrics_result(test_set.label, predicted) ","date":"2019-11-04T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%AE%9E%E9%AA%8C/","title":"机器学习 - 贝叶斯分类实验"},{"content":"机器学习 - 线性回归实验 用scikit-learn和pandas学习线性回归 1. 获取数据，定义问题 我们用UCI大学公开的机器学习数据来跑线性回归。\n数据的下载地址在这里：https://archive.ics.uci.edu/ml/datasets/combined+cycle+power+plant 下载后的数据可以发现是一个压缩文件，解压后有一个xlsx文件，用excel打开，另存为csv格式，之后用这个csv格式的文件来运行线性回归。\n这是一个循环发电场数据，共有9568个样本数据，每个数据有5列：$AT$（温度）、$V$（压力）、$AP$（湿度）、$RH$（压强）、$PE$（输出电力）。我们不用纠结于每项的具体意义。\n我们的问题是得到一个线性的关系，对应PE是样本输出，而$AT、V、AP、RH$这四个是样本特征，机器学习的目的是得到一个线性回归模型，即：\n$$ PE= \\theta_0+ \\theta_1 \\times AT+ \\theta_2 \\times V + \\theta_3 \\times AP + \\theta_4 \\times RH $$\n而需要学习的就是$\\theta_0，\\theta_1，\\theta_2，\\theta_3，\\theta_4$这5个参数。\n2. 整理数据 打开这个csv可以发现数据已经整理好，没有非法数据，因此不需要做预处理。但是这些数据并没有归一化，也就是转化为均值0，方差1的格式。（scikit-learn在线性回归时会自动帮我们进行归一化）。\n打开JupyterNotebook。在Home页面导入数据集，别忘了点upload上传。然后新建一个Python3笔记。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #导入相关类库 import matplotlib.pyplot as plt #绘图库 #设置插图，让它们在记事本可见 %matplotlib inline import numpy as np import pandas as pd from sklearn import datasets, linear_model #用pandas读取数据 data = pd.read_csv(\u0026#39;ccpp.csv\u0026#39;) data.describe() #查看数据的前5行 data.head() #查看数据的后5行 data.tail() #查看数据的维度 data.shape #数据可视化，直方图显示 data.hist() #散点矩阵图 from pandas.plotting import scatter_matrix scatter_matrix(data) 3. 准备数据 该数据集有9568个样本，每个样本有5例。\n下面我们开始准备样本特征$X$，我们用$AT，V，AP$和$RH$这4个列作为样本特征。\n1 2 X = data[[\u0026#39;AT\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;AP\u0026#39;,\u0026#39;RH\u0026#39;]] X.head() 准备样本输出$y$，我们用$PE$作为样本输出。\n1 2 y = data[[\u0026#39;PE\u0026#39;]] y.head() 划分训练集和测试集把$X$和$y$的样本组合划分成两部分，一部分是训练集，一部分是测试集。使用train_test_split函数，官方文档地址：\nhttps://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html#sklearn.model_selection.train_test_split\n1 2 from sklearn.model_selection import train_test_split X_train,X_test,y_train,y_test = train_test_split(X, y, random_state=1) 参数：\ntest_size：测试集大小。如果为浮点型，则在0.0-1.0之间，代表测试集的比例；如果为整数型，则为测试集样本的绝对数量；如果没有，则为训练集的补充。默认情况下，值为0.25。此外，还与版本有关。\ntrain_size：训练集大小。如果为浮点型，则在0.0-1.0之间，代表训练集的比例；如果为整数型，则为训练集样本的绝对数量；如果没有，则为测试集的补充。\nrandom_state：指定随机方式。一个整数或者andomState实例，或者None。如果为整数，则它指定了随机数生成器的种子；如果为RandomState实例，则指定了随机数生成器；如果为None，则使用默认的随机数生成器，随机选择一个种子。\nshuffle：布尔值。是否在拆分前重组数据。如果shuffle=False，则stratify必须为None。\nstratify：array-likeorNone。如果不是None,则数据集以分层方式拆分，并使用此作为类标签。\n返回值：拆分得到的train和test数据集。\n1 2 3 4 5 #查看下训练集和测试集的维度，可以看到75%的样本数据被作为训练集，25%的样本被作为测试集。 print(X_train.shape) print(y_train.shape) print(X_test.shape) print(y_test.shape) 4. 训练数据 用scikit-learn的线性模型来拟合我们的问题。\n1 2 3 fromsklearn.linear_modelimportLinearRegression#普通线性回归模型，使用最小二乘法拟合数据 linreg = LinearRegression() linreg.fit(X_train,y_train) 线性回归fit函数用于拟合输入输出数据，调用形式为$model.fit(X,y,sample_weight=None)：\n•X:X为训练向量；\n•y:y为相对于X的目标向量；\n•sample_weight:分配给各个样本的权重数组，一般不需要使用，可省略。 注意：$X$，$y$以及model.fit()返回的值都是2-D数组，如：$a=[[0]]$\n1 2 3 #拟合完毕后，查看得到的模型参数： print(linreg.intercept_) print(linreg.coef_) 这样我们就得到了线性回归模型里面需要求得的5个参数值。\n5. 模型评价 模型训练完以后，需要评估模型的好坏程度，对于线性回归来说，我们一般用均方差（MeanSquaredError,MSE）或者均方根差(RootMeanSquaredError,RMSE)在测试集上的表现来评价模型的好坏。如果我们用其他方法得到了不同的参数，需要选择模型时，就用MSE小的模型参数。\n1 2 3 4 5 6 7 #模型拟合测试集 y_pred = linreg.predict(X_test) from sklearn import metrics #用scikit-learn计算MSE print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) #用scikit-learn计算RMSE print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) 尝试用不同的线性模型进行训练 加入正则化项，岭回归模型,L2范数调用Ridge函数同学们手动调整alpha的值，观察结果的变化。思考：alpha值大小跟过拟合、欠拟合的关系？\n1 2 3 4 5 from sklearn.linear_model import Ridge rdg = Ridge(alpha=10000,fit_intercept=True) rdg.fit(X_train,y_train) print(rdg.intercept_) print(rdg.coef_) #模型拟合测试集\n1 2 3 4 5 6 y_pred = rdg.predict(X_test) from sklearn import metrics #用scikit-learn计算MSE print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) #用scikit-learn计算RMSE print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) 套索回归模型，L1范数\n调用LASSO函数\n1 2 3 4 5 from sklearn.linear_model import Lasso las = Lasso(alpha=0.1) las.fit(X_train,y_train) print(las.intercept_) print(las.coef_) #模型拟合测试集\n1 2 3 4 5 6 7 y_pred = las.predict(X_test) from sklearn import metrics #用scikit-learn计算MSE print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) #用scikit-learn计算RMSE print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) print(\u0026#34;迭代次数：\u0026#34;,las.n_iter_) 交叉验证 我们可以通过交叉验证来持续优化模型，采用10折交叉验证，即cross_val_predict中的cv参数为10：\n1 2 3 4 5 6 7 8 X = data[[\u0026#39;AT\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;AP\u0026#39;,\u0026#39;RH\u0026#39;]] y = data[[\u0026#39;PE\u0026#39;]] from sklearn.model_selection import cross_val_predict predicted=cross_val_predict(linreg,X,y,cv=10) #用scikit-learn计算MSE print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y,predicted)) #用scikit-learn计算RMSE print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y,predicted))) 6. 画图观察结果 画图观察真实值和预测值的变化关系，离中间的直线y=x越近的点，代表预测损失越低。\n1 2 3 4 5 6 7 fig,ax = plt.subplots() ax.scatter(y,predicted) ax.plot([y.min(),y.max()],[y.min(),y.max()],\u0026#39;k--\u0026#39;,lw=4) #尝试将k--改为r--，r-，观察线型。查看某个函数的详细信息，使用help()函数。 ax.set_xlabel(\u0026#39;Measured\u0026#39;) ax.set_ylabel(\u0026#39;Predicted\u0026#39;) plt.show() 7. python程序完整源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import matplotlib.pyplot as plt %matplotlib inline import numpy as np import pandas as pd from sklearn import datasets , linear_model data = pd.read_csv(\u0026#39;ccpp.csv\u0026#39;) data.describe() data.head() data.tail() data.shape data.hist() from pandas.plotting import scatter_matrix scatter_matrix(data) X = data[[\u0026#39;AT\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;AP\u0026#39;,\u0026#39;RH\u0026#39;]] X.head() y = data[[\u0026#39;PE\u0026#39;]] y.head() from sklearn.model_selection import train_test_split X_train , X_test , y_train , y_test = train_test_split(X , y , random_state=1) print (X_train.shape) print (y_train.shape) print (X_test.shape) print (y_test.shape) from sklearn.linear_model import LinearRegression linreg = LinearRegression() linreg.fit(X_train,y_train) print(linreg.intercept_) print(linreg.coef_) y_pred = linreg.predict(X_test) from sklearn import metrics print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) from sklearn.linear_model import Ridge rdg = Ridge(alpha=8000,fit_intercept=True) rdg.fit(X_train,y_train) print(rdg.intercept_) print(rdg.coef_) y_pred = rdg.predict(X_test) from sklearn import metrics print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) from sklearn.linear_model import Lasso las = Lasso(alpha = 0.1) las.fit(X_train,y_train) print (las.intercept_) print (las.coef_) y_pred = las.predict(X_test) from sklearn import metrics print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y_test,y_pred)) print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y_test,y_pred))) print(\u0026#34;迭代次数：\u0026#34;,las.n_iter_) X = data[[\u0026#39;AT\u0026#39;,\u0026#39;V\u0026#39;,\u0026#39;AP\u0026#39;,\u0026#39;RH\u0026#39;]] y = data[[\u0026#39;PE\u0026#39;]] from sklearn.model_selection import cross_val_predict predicted = cross_val_predict(linreg , X , y , cv=10) print(\u0026#34;MSE:\u0026#34;,metrics.mean_squared_error(y,predicted)) print(\u0026#34;RMSE:\u0026#34;,np.sqrt(metrics.mean_squared_error(y,predicted))) fig , ax = plt.subplots() ax.scatter(y,predicted) ax.plot([y.min(),y.max()],[y.min(),y.max()],\u0026#39;k--\u0026#39;,lw=4) ax.set_xlabel(\u0026#39;Measured\u0026#39;) ax.set_ylabel(\u0026#39;Predictted\u0026#39;) plt.show() ","date":"2019-10-21T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%AE%9E%E9%AA%8C/","title":"机器学习 - 线性回归实验"},{"content":"题目 1456: [历届试题]连号区间数 时间限制: 1Sec 内存限制: 128MB\n题目描述 小明这些天一直在思考这样一个奇怪而有趣的问题： 在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是： 如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列，则称这个区间连号区间。 当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。\n输入 第一行是一个正整数N (1 \u0026lt; = N \u0026lt; = 50000), 表示全排列的规模。 第二行是N个不同的数字Pi(1 \u0026lt; = Pi \u0026lt; = N)， 表示这N个数字的某一全排列。\n输出 输出一个整数，表示不同连号区间的数目。\n样例输入 1 2 5 3 4 2 5 1 样例输出 1 9 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; int main() { long int n,i,j,max,min,sum=0; scanf(\u0026#34;%ld\u0026#34;,\u0026amp;n); long int a[n+1]; for(i=1;i\u0026lt;=n;i++) scanf(\u0026#34;%ld\u0026#34;,\u0026amp;a[i]); for(i=1;i\u0026lt;n;i++)//表示 从第i位开始的区间 { min=max=a[i]; for(j=i+1;j\u0026lt;=n;j++)//表示到结束在j位 { if(a[j]\u0026lt;min){min=a[j];} if(a[j]\u0026gt;max){max=a[j];} if(max-min==j-i) sum++; //如果区间最大值与最小值之差等于当前区间数 j-i 则此区间必然重排后必然连续 } } printf(\u0026#34;%ld\\n\u0026#34;,sum+n); return 0; } 通过C语言网编译运行 ","date":"2019-04-01T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1456-%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98%E8%BF%9E%E5%8F%B7%E5%8C%BA%E9%97%B4%E6%95%B0-c%E8%AF%AD%E8%A8%80/","title":"题目 1456 [历届试题]连号区间数 (C语言)"},{"content":"题目 1462: [基础练习VIP]Huffuman树 时间限制: 1Sec 内存限制: 128MB\n题目描述 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。 给出一列数{pi}={p0, p1, …, pn-1}，用这列数构造Huffman树的过程如下： 1. 找到{pi}中最小的两个数，设为pa和pb，将pa和pb从{pi}中删除掉，然后将它们的和加入到{pi}中。这个过程的费用记为pa + pb。 2. 重复步骤1，直到{pi}中只剩下一个数。 在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。 本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。 例如，对于数列{pi}={5, 3, 8, 2, 9}，Huffman树的构造过程如下： 1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{pi}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。 2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{pi}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。 3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{pi}中删除它们并将和17加入，得到{10, 17}，费用为17。 4. 找到{10, 17}中最小的两个数，分别是10和17，从{pi}中删除它们并将和27加入，得到{27}，费用为27。 5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。 输入 输入的第一行包含一个正整数n（n\u0026lt; =100）。\n接下来是n个正整数，表示p0, p1, …, pn-1，每个数不超过1000。\n输出 输出用这些数构造Huffman树的总费用。\n样例输入 1 2 5 5 3 8 2 9 样例输出 1 59 C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; #define AUM(x,y) {int t;t=x;x=y;y=t;} //宏定义，交换数值. int main() { int n,i,sz[100],j,sum=0,t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(i=0;i\u0026lt;n;i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;sz[i]); for(t=n-1;t\u0026gt;=1;t--) { for(i=0;i\u0026lt;n;i++) //每次计算之前都要进行排序，然后把对应位置的两个数加起来。 for(j=0;j\u0026lt;n-1;j++) if(sz[j+1]\u0026gt;sz[j]) AUM(sz[j+1],sz[j]); sz[t-1] = sz[t-1]+sz[t]; sum+=sz[t-1]; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } 通过C语言网编译运行 ","date":"2019-03-01T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1462-%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0viphuffuman%E6%A0%91-c%E8%AF%AD%E8%A8%80/","title":"题目 1462 [基础练习VIP]Huffuman树 (C语言)"},{"content":"学生管理系统（纯C语言实现） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 #include \u0026#34;stdio.h\u0026#34; #include\u0026#34;string.h\u0026#34; #include\u0026#34;stdlib.h\u0026#34; struct Student { char ID[20]; char Name[20]; float Mark1; float Mark2; float Mark3; float Average; }; struct Student students[1000]; int num=0; float Avg(struct Student stu) { return (stu.Mark1+stu.Mark2+stu.Mark3)/3; } int Student_SearchByIndex(char id[]) { int i; for (i=0;i\u0026lt;num;i++) { if (strcmp(students[i].ID,id)==0) { return i; } } return -1; } /*通过姓名返回数组下标*/ int Student_SearchByName(char name[]) { int i; for (i=0;i\u0026lt;num;i++) { if (strcmp(students[i].Name,name)==0) { return i; } } return -1; } /*显示单条学生记录*/ void Student_DisplaySingle(int index) { printf(\u0026#34;%10s%10s%8s%8s%8s%10s\\n\u0026#34;,\u0026#34;学号\u0026#34;,\u0026#34;姓名\u0026#34;,\u0026#34;高数成绩\u0026#34;,\u0026#34;c语言成绩\u0026#34;,\u0026#34;计算机成绩\u0026#34;,\u0026#34;平均成绩\u0026#34;); printf(\u0026#34;-------------------------------------------------------------\\n\u0026#34;); printf(\u0026#34;%10s%10s%8.2f%8.2f%8.2f%10.2f\\n\u0026#34;,students[index].ID,students[index].Name,students[index].Mark1,students[index].Mark2,students[index].Mark3,students[index].Average); } /*插入学生信息*/ void Student_Insert() { while(1) { printf(\u0026#34;请输入学号:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;students[num].ID); getchar(); printf(\u0026#34;请输入姓名:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;students[num].Name); getchar(); printf(\u0026#34;请输入高数成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[num].Mark1); getchar(); printf(\u0026#34;请输入c语言成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[num].Mark2); getchar(); printf(\u0026#34;请输入计算机成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[num].Mark3); getchar(); students[num].Average=Avg(students[num]); num++; printf(\u0026#34;是否继续?(y/n)\u0026#34;); if (getchar()==\u0026#39;n\u0026#39;) { break; } } } /*修改学生信息*/ void Student_Modify() { //float mark1,mark2,mark3; while(1) { char id[20]; int index; printf(\u0026#34;请输入要修改的学生的学号:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;id); getchar(); index=Student_SearchByIndex(id); if (index==-1) { printf(\u0026#34;学生不存在!\\n\u0026#34;); } else { printf(\u0026#34;你要修改的学生信息为:\\n\u0026#34;); Student_DisplaySingle(index); printf(\u0026#34;-- 请输入新值--\\n\u0026#34;); printf(\u0026#34;请输入学号:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;students[index].ID); getchar(); printf(\u0026#34;请输入姓名:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;students[index].Name); getchar(); printf(\u0026#34;请输入高数成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[index].Mark1); getchar(); printf(\u0026#34;请输入c语言成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[index].Mark2); getchar(); printf(\u0026#34;请输入计算机成绩:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;students[index].Mark3); getchar(); students[index].Average=Avg(students[index]); } printf(\u0026#34;是否继续?(y/n)\u0026#34;); if (getchar()==\u0026#39;n\u0026#39;) { break; } } } /*删除学生信息*/ void Student_Delete() { int i; while(1) { char id[20]; int index; printf(\u0026#34;请输入要删除的学生的学号:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;id); getchar(); index=Student_SearchByIndex(id); if (index==-1) { printf(\u0026#34;学生不存在!\\n\u0026#34;); } else { printf(\u0026#34;你要删除的学生信息为:\\n\u0026#34;); Student_DisplaySingle(index); printf(\u0026#34;是否真的要删除?(y/n)\u0026#34;); if (getchar()==\u0026#39;y\u0026#39;) { for (i=index;i\u0026lt;num-1;i++) { students[i]=students[i+1];//把后边的对象都向前移动 } num--; } getchar(); } printf(\u0026#34;是否继续?(y/n)\u0026#34;); if (getchar()==\u0026#39;n\u0026#39;) { break; } } } /*按姓名查询*/ void Student_Select() { while(1) { char name[20]; int index; printf(\u0026#34;请输入要查询的学生的姓名:\u0026#34;); scanf(\u0026#34;%s\u0026#34;,\u0026amp;name); getchar(); index=Student_SearchByName(name); if (index==-1) { printf(\u0026#34;学生不存在!\\n\u0026#34;); } else { printf(\u0026#34;你要查询的学生信息为:\\n\u0026#34;); Student_DisplaySingle(index); } printf(\u0026#34;是否继续?(y/n)\u0026#34;); if (getchar()==\u0026#39;n\u0026#39;) { break; } } } /*按平均值排序*/ void Student_SortByAverage() { int i,j; struct Student tmp; for (i=0;i\u0026lt;num;i++) { for (j=1;j\u0026lt;num-i;j++) { if (students[j-1].Average\u0026lt;students[j].Average) { tmp=students[j-1]; students[j-1]=students[j]; students[j]=tmp; } } } } /*显示学生信息*/ void Student_Display() { int i; printf(\u0026#34;%10s%10s%8s%8s%8s%10s\\n\u0026#34;,\u0026#34;学号\u0026#34;,\u0026#34;姓名\u0026#34;,\u0026#34;高数成绩\u0026#34;,\u0026#34;c语言成绩\u0026#34;,\u0026#34;计算机成绩\u0026#34;,\u0026#34;平均成绩\u0026#34;); printf(\u0026#34;-------------------------------------------------------------\\n\u0026#34;); for (i=0;i\u0026lt;num;i++) { printf(\u0026#34;%10s%10s%8.2f%8.2f%8.2f%10.2f\\n\u0026#34;,students[i].ID,students[i].Name,students[i].Mark1,students[i].Mark2,students[i].Mark3,students[i].Average); } } /*将学生信息从文件读出*/ void IO_ReadInfo() { FILE *fp; int i; if ((fp=fopen(\u0026#34;Database.txt\u0026#34;,\u0026#34;rb\u0026#34;))==NULL) { printf(\u0026#34;不能打开文件!\\n\u0026#34;); return; } if (fread(\u0026amp;num,sizeof(int),1,fp)!=1) { num=-1; } else { for(i=0;i\u0026lt;num;i++) { fread(\u0026amp;students[i],sizeof(struct Student),1,fp); } } fclose(fp); } /*将学生信息写入文件*/ void IO_WriteInfo() { FILE *fp; int i; if ((fp=fopen(\u0026#34;Database.txt\u0026#34;,\u0026#34;wb\u0026#34;))==NULL) { printf(\u0026#34;不能打开文件!\\n\u0026#34;); return; } if (fwrite(\u0026amp;num,sizeof(int),1,fp)!=1) { printf(\u0026#34;写入文件错误!\\n\u0026#34;); } for (i=0;i\u0026lt;num;i++) { if (fwrite(\u0026amp;students[i],sizeof(struct Student),1,fp)!=1) { printf(\u0026#34;写入文件错误!\\n\u0026#34;); } } fclose(fp); } /*主程序*/ void main() { int choice; IO_ReadInfo(); while(1) { /*主菜单*/ printf(\u0026#34;\\n------ 学生管理系统------\\n\u0026#34;); printf(\u0026#34;1. 增加学生记录\\n\u0026#34;); printf(\u0026#34;2. 修改学生记录\\n\u0026#34;); printf(\u0026#34;3. 删除学生记录\\n\u0026#34;); printf(\u0026#34;4. 按姓名查询学生记录\\n\u0026#34;); printf(\u0026#34;5. 按平均成绩排序\\n\u0026#34;); printf(\u0026#34;6. 退出\\n\u0026#34;); printf(\u0026#34;请选择(1-6):\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;choice); getchar(); switch(choice) { case 1: Student_Insert(); break; case 2: Student_Modify(); break; case 3: Student_Delete(); break; case 4: Student_Select(); break; case 5: Student_SortByAverage(); Student_Display(); break; case 6: exit(0); break; } IO_WriteInfo(); } } ","date":"2018-12-20T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%BA%AFc%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/","title":"学生管理系统（纯C语言实现）"},{"content":"题目 1116: IP判断 时间限制: 1Sec 内存限制: 128MB\n题目描述 在基于Internet的程序中，我们常常需要判断一个IP字符串的合法性。 合法的IP是这样的形式： A.B.C.D 其中A、B、C、D均为位于[0, 255]中的整数。为了简单起见，我们规定这四个整数中不允许有前导零存在，如001这种情况。 现在，请你来完成这个判断程序吧^_^\n输入 输入由多行组成，每行是一个字符串，输入由“End of file”结束。 字符串长度最大为30，且不含空格和不可见字符\n输出 对于每一个输入，单独输出一行 如果该字符串是合法的IP，输出Y，否则，输出N\n样例输入 1 2 3 4 5 6 1.2.3.4 a.b.c.d 267.43.64.12 12.34.56.bb 210.43.64.129 -123.4.5.6 样例输出 1 2 3 4 5 6 Y N N N Y N C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int a,b,c,d; int k; char s[100]; char end[100]={\u0026#34;End of file\u0026#34;};//用于判断是否结束 while(~(k=scanf(\u0026#34;%d.%d.%d.%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c,\u0026amp;d))) { gets(s); if(strcmp(s,end)==0) return 0;//判断是否结束 else if(s[0]!=\u0026#39;\\0\u0026#39;) {printf(\u0026#34;N\\n\u0026#34;);continue;} //有多余的字符串时直接打印N，并进行下一个 if(k==4 \u0026amp;\u0026amp; a\u0026gt;=0 \u0026amp;\u0026amp; a\u0026lt;=255 \u0026amp;\u0026amp; b\u0026gt;=0 \u0026amp;\u0026amp; b\u0026lt;=255 \u0026amp;\u0026amp; c\u0026gt;=0 \u0026amp;\u0026amp; c\u0026lt;=255 \u0026amp;\u0026amp; d\u0026gt;=0 \u0026amp;\u0026amp; d\u0026lt;=255)//判断是否符合题意 printf(\u0026#34;Y\\n\u0026#34;); else printf(\u0026#34;N\\n\u0026#34;); fflush(stdin);//清除缓冲区 } return 0; } 通过C语言网编译运行 ","date":"2018-12-01T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1094-ip%E5%88%A4%E6%96%AD-c%E8%AF%AD%E8%A8%80/","title":"题目 1094 IP判断 (C语言)"},{"content":"题目 1004: [递归]母牛的故事 时间限制: 1Sec 内存限制: 128MB\n题目描述 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？\n输入 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0\u0026lt;n\u0026lt;55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。\n输出 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。\n样例输入 2 4 5 0\n样例输出 2 4 6\nC代码 解法A 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; int main() { int sum[60],n[60],i,j; sum[1]=1; sum[2]=2; sum[3]=3; for(i=4;i\u0026lt;=55;i++) { sum[i]=sum[i-1]+sum[i-3]; } i=0; do { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n[i]); i++; }while(n[i-1]); for(j=i;j\u0026gt;1;j--) { printf(\u0026#34;%d\u0026#34;,sum[n[i-j]]); printf(\u0026#34;\\n\u0026#34;); } return 0; } 解法B 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i, t; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;t) != EOF) { if(t == 0) return 0; else { int s[60]; s[0] = 1; s[1] = 2; s[2] = 3; for(i = 3; i \u0026lt; t; i++) { s[i] = s[i - 1] + s[i - 3]; } printf(\u0026#34;%d\\n\u0026#34;, s[t - 1]); } } return 0; } 均通过C语言网编译运行 ","date":"2018-11-02T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1004-%E9%80%92%E5%BD%92%E6%AF%8D%E7%89%9B%E7%9A%84%E6%95%85%E4%BA%8B-c%E8%AF%AD%E8%A8%80/","title":"题目 1004 [递归]母牛的故事 (C语言)"},{"content":"题目 1094: 字符串的输入输出处理 时间限制: 1Sec 内存限制: 128MB\n题目描述 字符串的输入输出处理。\n输入 第一行是一个正整数N，最大为100。之后是多行字符串（行数大于N）， 每一行字符串可能含有空格，字符数不超过1000。\n输出 先将输入中的前N行字符串（可能含有空格）原样输出，再将余下的字符串（不含有空格）以空格或回车分割依次按行输出。每行输出之间输出一个空行。\n样例输入 1 2 3 4 2 www.dotcpp.com DOTCPP A C M D O T CPP 样例输出 1 2 3 4 5 6 7 8 9 10 11 www.dotcpp.com DOTCPP A C M D O T CPP C代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;stdio.h\u0026gt; int main(){ int N, i; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); getchar(); //捕获回车 char str[N][1000]; //用于保存前N行的字符串 char extra[1000]; //用于保存额外的字符串 for(i=0; i\u0026lt;N; i++){ //按规定行数循环输入每行字符串 gets(str[i]); } for(i=0; scanf(\u0026#34;%c\u0026#34;, \u0026amp;extra[i]) != EOF; i++){ //输入额外字符串，一个字符一个字符输入，当输入结尾时（ctrl+Z）输入停止，好处在换行不会终止输入 } for(i=0; i\u0026lt;N; i++){ printf(\u0026#34;%s\\n\\n\u0026#34;, str[i]); } for(i=0; extra[i] != NULL; i++){ if(extra[i] == \u0026#39; \u0026#39;||extra[i] == \u0026#39;\\n\u0026#39;){ //当额外数组中有空格或换行符时换行 printf(\u0026#34;\\n\\n\u0026#34;); continue; } printf(\u0026#34;%c\u0026#34;, extra[i]); } return 0; } 通过C语言网编译运行 ","date":"2018-11-02T00:00:00Z","permalink":"https://javenjin.github.io/blog/zh-cn/p/%E9%A2%98%E7%9B%AE-1094-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86-c%E8%AF%AD%E8%A8%80/","title":"题目 1094 字符串的输入输出处理 (C语言)"}]