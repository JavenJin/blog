---
title: 题目 1616 [算法提高VIP]传球游戏 (C语言)
description: Q 1616 [Algorithm Improvement VIP]Passing Game (C Language)
date: '2020-03-21'
categories:
    - C (Programming Language)
tags:
    - C (Programming Language)
    - Algorithm
---

# 题目 1616: \[算法训练VIP\]传球游戏
时间限制: 1Sec 内存限制: 128MB
## 题目描述
上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。
聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方  法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方  式有1-> 2-> 3-> 1和1-> 3-> 2-> 1，共2种。
## 输入
共一行，有两个用空格隔开的整数n，m（3< =n< =30，1< =m< =30）。 

数据规模和约定
100%的数据满足：3< =n< =30，1< =m< =30
## 输出
t共一行，有一个整数，表示符合题意的方法数。 
## 样例输入
```
3 3
```
## 样例输出
```
2
```
## C代码
```c
#include <stdio.h>
int n;
int main(){
    int at(int);
    int m,i,j,f[31][31] = {0};
    scanf("%d%d",&n,&m);
    f[1][2] = f[1][n] = 1;   //第1次传球，1号只可能传给2号或n号
    for(i = 2;i <= m;i++)    //从第2次到第m次传球
    for(j = 1;j <= n;j++)    //每次传给1号到n号的可能，取决于上次球传到相邻位置的可能
        f[i][j] = f[i - 1][at(j - 1)] + f[i - 1][at(j + 1)];
    printf("%d",f[m][1]);    //第m次传球，传给1号的可能方式有几种
    return 0;
}
int at(int x){               //站成圆圈传球
    if(x<1) return x + n;    //编号减少到0时，传到编号n
    if(x>n) return x - n;    //编号增加到n+1时，传到编号1
    return x;
}
```
#### 通过[C语言网](https://www.dotcpp.com/)编译运行